// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: analytics.proto

#include "analytics.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_EditorChangeValue_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_GameEntityInfo_Ammo_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_GameEnum_EnumPair_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_LineEvent_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Material_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_PointEvent_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_PrimitiveOptions_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_RangeI_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_UTCTime_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Vec3Color_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<0> scc_info_Vec3_analytics_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_analytics_2eproto ::google::protobuf::internal::SCCInfo<2> scc_info_Primitive_analytics_2eproto;
namespace Analytics {
class PointEventDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PointEvent> _instance;
} _PointEvent_default_instance_;
class LineEventDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<LineEvent> _instance;
} _LineEvent_default_instance_;
class EditorChangeValueDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EditorChangeValue> _instance;
} _EditorChangeValue_default_instance_;
class EditorChangesDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<EditorChanges> _instance;
} _EditorChanges_default_instance_;
class RangeFDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RangeF> _instance;
} _RangeF_default_instance_;
class RangeIDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<RangeI> _instance;
} _RangeI_default_instance_;
class Vec3DefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Vec3> _instance;
} _Vec3_default_instance_;
class Vec3ColorDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Vec3Color> _instance;
} _Vec3Color_default_instance_;
class Vec4DefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Vec4> _instance;
} _Vec4_default_instance_;
class LineDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Line> _instance;
} _Line_default_instance_;
class EulerDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Euler> _instance;
} _Euler_default_instance_;
class MaterialDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Material> _instance;
} _Material_default_instance_;
class PrimitiveOptionsDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<PrimitiveOptions> _instance;
} _PrimitiveOptions_default_instance_;
class PrimitiveDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Primitive> _instance;
} _Primitive_default_instance_;
class MeshDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<Mesh> _instance;
} _Mesh_default_instance_;
class UTCTimeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<UTCTime> _instance;
} _UTCTime_default_instance_;
class GameInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameInfo> _instance;
} _GameInfo_default_instance_;
class GameEnum_EnumPairDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameEnum_EnumPair> _instance;
} _GameEnum_EnumPair_default_instance_;
class GameEnumDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameEnum> _instance;
} _GameEnum_default_instance_;
class GameNavNotFoundDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameNavNotFound> _instance;
} _GameNavNotFound_default_instance_;
class GameNavAutoDownloadedDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameNavAutoDownloaded> _instance;
} _GameNavAutoDownloaded_default_instance_;
class GameAssertDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameAssert> _instance;
} _GameAssert_default_instance_;
class GameCrashDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameCrash> _instance;
} _GameCrash_default_instance_;
class GameMeshDataDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameMeshData> _instance;
} _GameMeshData_default_instance_;
class GameEntityInfo_AmmoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameEntityInfo_Ammo> _instance;
} _GameEntityInfo_Ammo_default_instance_;
class GameEntityInfoDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameEntityInfo> _instance;
} _GameEntityInfo_default_instance_;
class GameEntityPositionDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameEntityPosition> _instance;
} _GameEntityPosition_default_instance_;
class GameNodeDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameNode> _instance;
} _GameNode_default_instance_;
class GameWeaponFiredDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameWeaponFired> _instance;
} _GameWeaponFired_default_instance_;
class GameDeathDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameDeath> _instance;
} _GameDeath_default_instance_;
class GameKilledSomeoneDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameKilledSomeone> _instance;
} _GameKilledSomeone_default_instance_;
class GameRecieveDamageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameRecieveDamage> _instance;
} _GameRecieveDamage_default_instance_;
class GameInflictDamageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameInflictDamage> _instance;
} _GameInflictDamage_default_instance_;
class GameRadiusDamageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameRadiusDamage> _instance;
} _GameRadiusDamage_default_instance_;
class GameNavigationStuckDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameNavigationStuck> _instance;
} _GameNavigationStuck_default_instance_;
class GameVoiceMacroDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameVoiceMacro> _instance;
} _GameVoiceMacro_default_instance_;
class GameLogMessageDefaultTypeInternal {
 public:
  ::google::protobuf::internal::ExplicitlyConstructed<GameLogMessage> _instance;
} _GameLogMessage_default_instance_;
}  // namespace Analytics
static void InitDefaultsPointEvent_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_PointEvent_default_instance_;
    new (ptr) ::Analytics::PointEvent();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::PointEvent::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_PointEvent_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPointEvent_analytics_2eproto}, {}};

static void InitDefaultsLineEvent_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_LineEvent_default_instance_;
    new (ptr) ::Analytics::LineEvent();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::LineEvent::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_LineEvent_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsLineEvent_analytics_2eproto}, {}};

static void InitDefaultsEditorChangeValue_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_EditorChangeValue_default_instance_;
    new (ptr) ::Analytics::EditorChangeValue();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::EditorChangeValue::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_EditorChangeValue_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEditorChangeValue_analytics_2eproto}, {}};

static void InitDefaultsEditorChanges_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_EditorChanges_default_instance_;
    new (ptr) ::Analytics::EditorChanges();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::EditorChanges::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_EditorChanges_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsEditorChanges_analytics_2eproto}, {
      &scc_info_EditorChangeValue_analytics_2eproto.base,}};

static void InitDefaultsRangeF_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_RangeF_default_instance_;
    new (ptr) ::Analytics::RangeF();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::RangeF::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_RangeF_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsRangeF_analytics_2eproto}, {}};

static void InitDefaultsRangeI_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_RangeI_default_instance_;
    new (ptr) ::Analytics::RangeI();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::RangeI::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_RangeI_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsRangeI_analytics_2eproto}, {}};

static void InitDefaultsVec3_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_Vec3_default_instance_;
    new (ptr) ::Analytics::Vec3();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::Vec3::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Vec3_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsVec3_analytics_2eproto}, {}};

static void InitDefaultsVec3Color_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_Vec3Color_default_instance_;
    new (ptr) ::Analytics::Vec3Color();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::Vec3Color::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Vec3Color_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsVec3Color_analytics_2eproto}, {}};

static void InitDefaultsVec4_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_Vec4_default_instance_;
    new (ptr) ::Analytics::Vec4();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::Vec4::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Vec4_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsVec4_analytics_2eproto}, {}};

static void InitDefaultsLine_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_Line_default_instance_;
    new (ptr) ::Analytics::Line();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::Line::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_Line_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsLine_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsEuler_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_Euler_default_instance_;
    new (ptr) ::Analytics::Euler();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::Euler::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Euler_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsEuler_analytics_2eproto}, {}};

static void InitDefaultsMaterial_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_Material_default_instance_;
    new (ptr) ::Analytics::Material();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::Material::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_Material_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsMaterial_analytics_2eproto}, {}};

static void InitDefaultsPrimitiveOptions_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_PrimitiveOptions_default_instance_;
    new (ptr) ::Analytics::PrimitiveOptions();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::PrimitiveOptions::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_PrimitiveOptions_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsPrimitiveOptions_analytics_2eproto}, {}};

static void InitDefaultsPrimitive_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_Primitive_default_instance_;
    new (ptr) ::Analytics::Primitive();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::Primitive::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Primitive_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsPrimitive_analytics_2eproto}, {
      &scc_info_PrimitiveOptions_analytics_2eproto.base,
      &scc_info_Vec3Color_analytics_2eproto.base,}};

static void InitDefaultsMesh_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_Mesh_default_instance_;
    new (ptr) ::Analytics::Mesh();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::Mesh::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<2> scc_info_Mesh_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsMesh_analytics_2eproto}, {
      &scc_info_Primitive_analytics_2eproto.base,
      &scc_info_Material_analytics_2eproto.base,}};

static void InitDefaultsUTCTime_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_UTCTime_default_instance_;
    new (ptr) ::Analytics::UTCTime();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::UTCTime::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_UTCTime_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsUTCTime_analytics_2eproto}, {}};

static void InitDefaultsGameInfo_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameInfo_default_instance_;
    new (ptr) ::Analytics::GameInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameInfo_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameInfo_analytics_2eproto}, {
      &scc_info_UTCTime_analytics_2eproto.base,}};

static void InitDefaultsGameEnum_EnumPair_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameEnum_EnumPair_default_instance_;
    new (ptr) ::Analytics::GameEnum_EnumPair();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameEnum_EnumPair::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GameEnum_EnumPair_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGameEnum_EnumPair_analytics_2eproto}, {}};

static void InitDefaultsGameEnum_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameEnum_default_instance_;
    new (ptr) ::Analytics::GameEnum();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameEnum::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameEnum_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameEnum_analytics_2eproto}, {
      &scc_info_GameEnum_EnumPair_analytics_2eproto.base,}};

static void InitDefaultsGameNavNotFound_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameNavNotFound_default_instance_;
    new (ptr) ::Analytics::GameNavNotFound();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameNavNotFound::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GameNavNotFound_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGameNavNotFound_analytics_2eproto}, {}};

static void InitDefaultsGameNavAutoDownloaded_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameNavAutoDownloaded_default_instance_;
    new (ptr) ::Analytics::GameNavAutoDownloaded();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameNavAutoDownloaded::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GameNavAutoDownloaded_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGameNavAutoDownloaded_analytics_2eproto}, {}};

static void InitDefaultsGameAssert_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameAssert_default_instance_;
    new (ptr) ::Analytics::GameAssert();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameAssert::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GameAssert_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGameAssert_analytics_2eproto}, {}};

static void InitDefaultsGameCrash_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameCrash_default_instance_;
    new (ptr) ::Analytics::GameCrash();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameCrash::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GameCrash_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGameCrash_analytics_2eproto}, {}};

static void InitDefaultsGameMeshData_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameMeshData_default_instance_;
    new (ptr) ::Analytics::GameMeshData();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameMeshData::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GameMeshData_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGameMeshData_analytics_2eproto}, {}};

static void InitDefaultsGameEntityInfo_Ammo_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameEntityInfo_Ammo_default_instance_;
    new (ptr) ::Analytics::GameEntityInfo_Ammo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameEntityInfo_Ammo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GameEntityInfo_Ammo_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGameEntityInfo_Ammo_analytics_2eproto}, {}};

static void InitDefaultsGameEntityInfo_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameEntityInfo_default_instance_;
    new (ptr) ::Analytics::GameEntityInfo();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameEntityInfo::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<3> scc_info_GameEntityInfo_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsGameEntityInfo_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,
      &scc_info_RangeI_analytics_2eproto.base,
      &scc_info_GameEntityInfo_Ammo_analytics_2eproto.base,}};

static void InitDefaultsGameEntityPosition_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameEntityPosition_default_instance_;
    new (ptr) ::Analytics::GameEntityPosition();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameEntityPosition::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameEntityPosition_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameEntityPosition_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameNode_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameNode_default_instance_;
    new (ptr) ::Analytics::GameNode();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameNode::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameNode_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameNode_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameWeaponFired_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameWeaponFired_default_instance_;
    new (ptr) ::Analytics::GameWeaponFired();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameWeaponFired::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameWeaponFired_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameWeaponFired_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameDeath_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameDeath_default_instance_;
    new (ptr) ::Analytics::GameDeath();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameDeath::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameDeath_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameDeath_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameKilledSomeone_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameKilledSomeone_default_instance_;
    new (ptr) ::Analytics::GameKilledSomeone();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameKilledSomeone::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameKilledSomeone_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameKilledSomeone_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameRecieveDamage_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameRecieveDamage_default_instance_;
    new (ptr) ::Analytics::GameRecieveDamage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameRecieveDamage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameRecieveDamage_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameRecieveDamage_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameInflictDamage_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameInflictDamage_default_instance_;
    new (ptr) ::Analytics::GameInflictDamage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameInflictDamage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameInflictDamage_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameInflictDamage_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameRadiusDamage_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameRadiusDamage_default_instance_;
    new (ptr) ::Analytics::GameRadiusDamage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameRadiusDamage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameRadiusDamage_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameRadiusDamage_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameNavigationStuck_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameNavigationStuck_default_instance_;
    new (ptr) ::Analytics::GameNavigationStuck();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameNavigationStuck::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameNavigationStuck_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameNavigationStuck_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameVoiceMacro_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameVoiceMacro_default_instance_;
    new (ptr) ::Analytics::GameVoiceMacro();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameVoiceMacro::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<1> scc_info_GameVoiceMacro_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsGameVoiceMacro_analytics_2eproto}, {
      &scc_info_Vec3_analytics_2eproto.base,}};

static void InitDefaultsGameLogMessage_analytics_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::Analytics::_GameLogMessage_default_instance_;
    new (ptr) ::Analytics::GameLogMessage();
    ::google::protobuf::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Analytics::GameLogMessage::InitAsDefaultInstance();
}

::google::protobuf::internal::SCCInfo<0> scc_info_GameLogMessage_analytics_2eproto =
    {{ATOMIC_VAR_INIT(::google::protobuf::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsGameLogMessage_analytics_2eproto}, {}};

void InitDefaults_analytics_2eproto() {
  ::google::protobuf::internal::InitSCC(&scc_info_PointEvent_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_LineEvent_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EditorChangeValue_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_EditorChanges_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RangeF_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_RangeI_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Vec3_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Vec3Color_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Vec4_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Line_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Euler_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Material_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_PrimitiveOptions_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Primitive_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_Mesh_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_UTCTime_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameInfo_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameEnum_EnumPair_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameEnum_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameNavNotFound_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameNavAutoDownloaded_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameAssert_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameCrash_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameMeshData_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameEntityInfo_Ammo_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameEntityInfo_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameEntityPosition_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameNode_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameWeaponFired_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameDeath_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameKilledSomeone_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameRecieveDamage_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameInflictDamage_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameRadiusDamage_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameNavigationStuck_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameVoiceMacro_analytics_2eproto.base);
  ::google::protobuf::internal::InitSCC(&scc_info_GameLogMessage_analytics_2eproto.base);
}

::google::protobuf::Metadata file_level_metadata_analytics_2eproto[37];
const ::google::protobuf::EnumDescriptor* file_level_enum_descriptors_analytics_2eproto[4];
constexpr ::google::protobuf::ServiceDescriptor const** file_level_service_descriptors_analytics_2eproto = nullptr;

const ::google::protobuf::uint32 TableStruct_analytics_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::PointEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::PointEvent, radius_),
  PROTOBUF_FIELD_OFFSET(::Analytics::PointEvent, weight_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::LineEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::LineEvent, radius_),
  PROTOBUF_FIELD_OFFSET(::Analytics::LineEvent, weight_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::EditorChangeValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::EditorChangeValue, messagetype_),
  PROTOBUF_FIELD_OFFSET(::Analytics::EditorChangeValue, fieldname_),
  PROTOBUF_FIELD_OFFSET(::Analytics::EditorChangeValue, payload_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::EditorChanges, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::EditorChanges, changes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::RangeF, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::RangeF, min_),
  PROTOBUF_FIELD_OFFSET(::Analytics::RangeF, max_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::RangeI, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::RangeI, min_),
  PROTOBUF_FIELD_OFFSET(::Analytics::RangeI, max_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec3, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec3, x_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec3, y_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec3, z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec3Color, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec3Color, x_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec3Color, y_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec3Color, z_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec3Color, color_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec4, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec4, x_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec4, y_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec4, z_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Vec4, w_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::Line, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::Line, p0_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Line, p1_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::Euler, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::Euler, heading_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Euler, pitch_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Euler, roll_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::Material, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::Material, name_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Material, contents_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Material, surfaceflags_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Material, renderevents_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::PrimitiveOptions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::PrimitiveOptions, partindex_),
  PROTOBUF_FIELD_OFFSET(::Analytics::PrimitiveOptions, overridesurfaceflags_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::Primitive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::Primitive, type_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Primitive, materialindex_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Primitive, options_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Primitive, size_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Primitive, vertices_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::Mesh, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::Mesh, primitives_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Mesh, materials_),
  PROTOBUF_FIELD_OFFSET(::Analytics::Mesh, name_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::UTCTime, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::UTCTime, hour_),
  PROTOBUF_FIELD_OFFSET(::Analytics::UTCTime, minute_),
  PROTOBUF_FIELD_OFFSET(::Analytics::UTCTime, second_),
  PROTOBUF_FIELD_OFFSET(::Analytics::UTCTime, day_),
  PROTOBUF_FIELD_OFFSET(::Analytics::UTCTime, month_),
  PROTOBUF_FIELD_OFFSET(::Analytics::UTCTime, year_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInfo, timestamp_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInfo, mapname_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInfo, gamename_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInfo, gameversion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEnum_EnumPair, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEnum_EnumPair, name_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEnum_EnumPair, value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEnum, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEnum, values_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEnum, enumname_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEnum, isbitfield_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNavNotFound, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNavNotFound, mapname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNavAutoDownloaded, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNavAutoDownloaded, mapname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameAssert, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameAssert, condition_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameAssert, file_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameAssert, line_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameCrash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameCrash, info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameMeshData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameMeshData, compressiontype_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameMeshData, modelname_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameMeshData, modelbytes_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameMeshData, modelbytesuncompressed_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo_Ammo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo_Ammo, ammotype_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo_Ammo, ammocount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, entityname_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, entityindex_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, entityserial_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, groupid_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, classid_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, team_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, entityflags_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, category_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, powerups_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, navflags_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, eulerrotation_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, position_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, eyeoffset_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, eyedir_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, health_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, armor_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, boundsmin_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, boundsmax_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, ammo_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityInfo, deleted_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityPosition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityPosition, position_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameEntityPosition, team_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, nodepath_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, eulerrotation_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, translation_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, meshname_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, entityid_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, entityname_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, activestate_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, navflagsactive_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, navflagsoverride_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNode, shapemode_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameWeaponFired, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameWeaponFired, position_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameWeaponFired, attackteam_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameWeaponFired, weaponid_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameWeaponFired, firedbyclass_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameDeath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameDeath, position_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameDeath, victimteam_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameDeath, attackteam_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameDeath, meansofdeath_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameKilledSomeone, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameKilledSomeone, position_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameKilledSomeone, victimteam_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameKilledSomeone, attackteam_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameKilledSomeone, meansofdeath_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRecieveDamage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRecieveDamage, position_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRecieveDamage, victimteam_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRecieveDamage, attackteam_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRecieveDamage, weaponid_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRecieveDamage, damagetype_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRecieveDamage, damageamount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInflictDamage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInflictDamage, position_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInflictDamage, victimteam_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInflictDamage, attackteam_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInflictDamage, weaponid_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInflictDamage, damagetype_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameInflictDamage, damageamount_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRadiusDamage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRadiusDamage, position_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRadiusDamage, damagetype_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRadiusDamage, damageamount_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameRadiusDamage, damageradius_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNavigationStuck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNavigationStuck, entityid_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameNavigationStuck, position_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameVoiceMacro, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameVoiceMacro, entityid_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameVoiceMacro, voicemacro_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameVoiceMacro, position_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameLogMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Analytics::GameLogMessage, logtype_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameLogMessage, logmessage_),
  PROTOBUF_FIELD_OFFSET(::Analytics::GameLogMessage, logextrainfo_),
};
static const ::google::protobuf::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::Analytics::PointEvent)},
  { 7, -1, sizeof(::Analytics::LineEvent)},
  { 14, -1, sizeof(::Analytics::EditorChangeValue)},
  { 22, -1, sizeof(::Analytics::EditorChanges)},
  { 28, -1, sizeof(::Analytics::RangeF)},
  { 35, -1, sizeof(::Analytics::RangeI)},
  { 42, -1, sizeof(::Analytics::Vec3)},
  { 50, -1, sizeof(::Analytics::Vec3Color)},
  { 59, -1, sizeof(::Analytics::Vec4)},
  { 68, -1, sizeof(::Analytics::Line)},
  { 75, -1, sizeof(::Analytics::Euler)},
  { 83, -1, sizeof(::Analytics::Material)},
  { 92, -1, sizeof(::Analytics::PrimitiveOptions)},
  { 99, -1, sizeof(::Analytics::Primitive)},
  { 109, -1, sizeof(::Analytics::Mesh)},
  { 117, -1, sizeof(::Analytics::UTCTime)},
  { 128, -1, sizeof(::Analytics::GameInfo)},
  { 137, -1, sizeof(::Analytics::GameEnum_EnumPair)},
  { 144, -1, sizeof(::Analytics::GameEnum)},
  { 152, -1, sizeof(::Analytics::GameNavNotFound)},
  { 158, -1, sizeof(::Analytics::GameNavAutoDownloaded)},
  { 164, -1, sizeof(::Analytics::GameAssert)},
  { 172, -1, sizeof(::Analytics::GameCrash)},
  { 178, -1, sizeof(::Analytics::GameMeshData)},
  { 187, -1, sizeof(::Analytics::GameEntityInfo_Ammo)},
  { 194, -1, sizeof(::Analytics::GameEntityInfo)},
  { 219, -1, sizeof(::Analytics::GameEntityPosition)},
  { 226, -1, sizeof(::Analytics::GameNode)},
  { 241, -1, sizeof(::Analytics::GameWeaponFired)},
  { 250, -1, sizeof(::Analytics::GameDeath)},
  { 259, -1, sizeof(::Analytics::GameKilledSomeone)},
  { 268, -1, sizeof(::Analytics::GameRecieveDamage)},
  { 279, -1, sizeof(::Analytics::GameInflictDamage)},
  { 290, -1, sizeof(::Analytics::GameRadiusDamage)},
  { 299, -1, sizeof(::Analytics::GameNavigationStuck)},
  { 306, -1, sizeof(::Analytics::GameVoiceMacro)},
  { 314, -1, sizeof(::Analytics::GameLogMessage)},
};

static ::google::protobuf::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_PointEvent_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_LineEvent_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_EditorChangeValue_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_EditorChanges_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_RangeF_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_RangeI_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_Vec3_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_Vec3Color_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_Vec4_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_Line_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_Euler_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_Material_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_PrimitiveOptions_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_Primitive_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_Mesh_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_UTCTime_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameEnum_EnumPair_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameEnum_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameNavNotFound_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameNavAutoDownloaded_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameAssert_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameCrash_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameMeshData_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameEntityInfo_Ammo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameEntityInfo_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameEntityPosition_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameNode_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameWeaponFired_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameDeath_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameKilledSomeone_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameRecieveDamage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameInflictDamage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameRadiusDamage_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameNavigationStuck_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameVoiceMacro_default_instance_),
  reinterpret_cast<const ::google::protobuf::Message*>(&::Analytics::_GameLogMessage_default_instance_),
};

::google::protobuf::internal::AssignDescriptorsTable assign_descriptors_table_analytics_2eproto = {
  {}, AddDescriptors_analytics_2eproto, "analytics.proto", schemas,
  file_default_instances, TableStruct_analytics_2eproto::offsets,
  file_level_metadata_analytics_2eproto, 37, file_level_enum_descriptors_analytics_2eproto, file_level_service_descriptors_analytics_2eproto,
};

::google::protobuf::internal::DescriptorTable descriptor_table_analytics_2eproto = {
  false, InitDefaults_analytics_2eproto, 
  "\n\017analytics.proto\022\tAnalytics\032 google/pro"
  "tobuf/descriptor.proto\",\n\nPointEvent\022\016\n\006"
  "radius\030\001 \001(\t\022\016\n\006weight\030\002 \001(\t\"+\n\tLineEven"
  "t\022\016\n\006radius\030\001 \001(\t\022\016\n\006weight\030\002 \001(\t\"L\n\021Edi"
  "torChangeValue\022\023\n\013messageType\030\001 \001(\t\022\021\n\tf"
  "ieldName\030\002 \001(\t\022\017\n\007payload\030\003 \001(\t\">\n\rEdito"
  "rChanges\022-\n\007changes\030\001 \003(\0132\034.Analytics.Ed"
  "itorChangeValue\"\"\n\006RangeF\022\013\n\003min\030\001 \001(\002\022\013"
  "\n\003max\030\002 \001(\002\"\"\n\006RangeI\022\013\n\003min\030\001 \001(\005\022\013\n\003ma"
  "x\030\002 \001(\005\"\'\n\004Vec3\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n"
  "\001z\030\003 \001(\002\";\n\tVec3Color\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 "
  "\001(\002\022\t\n\001z\030\003 \001(\002\022\r\n\005color\030\004 \001(\r\"2\n\004Vec4\022\t\n"
  "\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\t\n\001z\030\003 \001(\002\022\t\n\001w\030\004 \001("
  "\002\"@\n\004Line\022\033\n\002p0\030\001 \001(\0132\017.Analytics.Vec3\022\033"
  "\n\002p1\030\002 \001(\0132\017.Analytics.Vec3\"5\n\005Euler\022\017\n\007"
  "heading\030\001 \001(\002\022\r\n\005pitch\030\002 \001(\002\022\014\n\004roll\030\003 \001"
  "(\002\"\204\001\n\010Material\022\014\n\004name\030\001 \001(\t\022\'\n\010content"
  "s\030\002 \001(\rB\025\212\372\001\rCONTENT_FLAGS\240\372\001\001\022+\n\014surfac"
  "eFlags\030\003 \001(\rB\025\212\372\001\rSURFACE_FLAGS\240\372\001\001\022\024\n\014r"
  "enderEvents\030\004 \001(\010\"d\n\020PrimitiveOptions\022\027\n"
  "\tpartIndex\030\001 \001(\rB\004\300\372\001\001\0227\n\024overrideSurfac"
  "eFlags\030\002 \001(\rB\031\220\372\001\001\212\372\001\rSURFACE_FLAGS\240\372\001\001\""
  "\256\001\n\tPrimitive\022&\n\004type\030\001 \001(\0162\030.Analytics."
  "PrimitiveType\022\025\n\rmaterialIndex\030\002 \001(\r\022,\n\007"
  "options\030\003 \001(\0132\033.Analytics.PrimitiveOptio"
  "ns\022\014\n\004size\030\004 \001(\002\022&\n\010vertices\030\005 \003(\0132\024.Ana"
  "lytics.Vec3Color\"f\n\004Mesh\022(\n\nprimitives\030\001"
  " \003(\0132\024.Analytics.Primitive\022&\n\tmaterials\030"
  "\002 \003(\0132\023.Analytics.Material\022\014\n\004name\030\003 \001(\t"
  "\"a\n\007UTCTime\022\014\n\004hour\030\001 \001(\005\022\016\n\006minute\030\002 \001("
  "\005\022\016\n\006second\030\003 \001(\005\022\013\n\003day\030\004 \001(\005\022\r\n\005month\030"
  "\005 \001(\005\022\014\n\004year\030\006 \001(\005\"s\n\010GameInfo\022%\n\ttimeS"
  "tamp\030\001 \001(\0132\022.Analytics.UTCTime\022\017\n\007mapNam"
  "e\030\002 \001(\t\022\020\n\010gameName\030\003 \001(\t\022\023\n\013gameVersion"
  "\030\004 \001(\t:\010\300\270\002\001\330\270\002\001\"\231\001\n\010GameEnum\022,\n\006values\030"
  "\001 \003(\0132\034.Analytics.GameEnum.EnumPair\022\020\n\010e"
  "numname\030\002 \001(\t\022\022\n\nisbitfield\030\003 \001(\010\032\'\n\010Enu"
  "mPair\022\014\n\004name\030\001 \001(\t\022\r\n\005value\030\002 \001(\003:\020\300\270\002\003"
  "\312\270\002\010enumname\"(\n\017GameNavNotFound\022\017\n\007mapNa"
  "me\030\001 \001(\t:\004\300\270\002\002\".\n\025GameNavAutoDownloaded\022"
  "\017\n\007mapName\030\001 \001(\t:\004\300\270\002\002\"A\n\nGameAssert\022\021\n\t"
  "condition\030\001 \001(\t\022\014\n\004file\030\002 \001(\t\022\014\n\004line\030\003 "
  "\001(\005:\004\300\270\002\002\"\037\n\tGameCrash\022\014\n\004info\030\001 \001(\t:\004\300\270"
  "\002\002\"\231\001\n\014GameMeshData\022/\n\017compressionType\030\001"
  " \001(\0162\026.Analytics.Compression\022\021\n\tmodelNam"
  "e\030\002 \001(\t\022\022\n\nmodelBytes\030\003 \001(\014\022\036\n\026modelByte"
  "sUncompressed\030\004 \001(\r:\021\300\270\002\003\312\270\002\tmodelName\"\265"
  "\006\n\016GameEntityInfo\022\022\n\nentityName\030\001 \001(\t\022\023\n"
  "\013entityIndex\030\002 \001(\005\022\024\n\014entitySerial\030\003 \001(\005"
  "\022\035\n\007groupId\030\004 \001(\005B\014\212\372\001\010GROUP_ID\022\035\n\007class"
  "Id\030\005 \001(\005B\014\212\372\001\010CLASS_ID\022\031\n\004team\030\006 \001(\005B\013\212\372"
  "\001\007TEAM_ID\022)\n\013entityFlags\030\007 \001(\003B\024\212\372\001\014ENTI"
  "TY_FLAGS\270\372\001\001\022%\n\010category\030\010 \001(\005B\023\212\372\001\013CATE"
  "GORY_ID\270\372\001\001\022$\n\010powerUps\030\t \001(\005B\022\212\372\001\nPOWER"
  "UP_ID\270\372\001\001\022\037\n\010navFlags\030\n \001(\003B\r\212\372\001\tNAV_FLA"
  "GS\022,\n\reulerRotation\030\013 \001(\0132\017.Analytics.Ve"
  "c3B\004\260\372\001\001\022\'\n\010position\030\014 \001(\0132\017.Analytics.V"
  "ec3B\004\260\372\001\001\022(\n\teyeOffset\030\r \001(\0132\017.Analytics"
  ".Vec3B\004\260\372\001\001\022%\n\006eyeDir\030\016 \001(\0132\017.Analytics."
  "Vec3B\004\260\372\001\001\022!\n\006health\030\017 \001(\0132\021.Analytics.R"
  "angeI\022 \n\005armor\030\020 \001(\0132\021.Analytics.RangeI\022"
  "\"\n\tboundsMin\030\021 \001(\0132\017.Analytics.Vec3\022\"\n\tb"
  "oundsMax\030\022 \001(\0132\017.Analytics.Vec3\022,\n\004ammo\030"
  "\023 \003(\0132\036.Analytics.GameEntityInfo.Ammo\022\026\n"
  "\007deleted\030\350\007 \001(\010B\004\260\372\001\001\032:\n\004Ammo\022\037\n\010ammoTyp"
  "e\030\001 \001(\rB\r\212\372\001\tAMMO_TYPE\022\021\n\tammoCount\030\002 \001("
  "\r:;\300\270\002\003\312\270\002\013entityIndex\352\270\002$Entity(%entity"
  "Index% - %entityName%)\"m\n\022GameEntityPosi"
  "tion\0222\n\010position\030\001 \001(\0132\017.Analytics.Vec3B"
  "\017\342\372\001\004\n\00232\342\372\001\003\022\0011\022\035\n\004team\030\002 \001(\005B\017\212\372\001\007TEAM"
  "_ID\310\372\001\001:\004\300\270\002\002\"\332\002\n\010GameNode\022\026\n\010nodePath\030\001"
  " \001(\tB\004\300\372\001\001\022&\n\reulerRotation\030\002 \001(\0132\017.Anal"
  "ytics.Vec3\022$\n\013translation\030\003 \001(\0132\017.Analyt"
  "ics.Vec3\022\020\n\010meshName\030\004 \001(\t\022\020\n\010entityId\030\n"
  " \001(\005\022\022\n\nentityName\030\013 \001(\t\022$\n\013activeState\030"
  "\014 \001(\005B\017\212\372\001\013MODEL_STATE\022%\n\016navFlagsActive"
  "\030\r \001(\003B\r\212\372\001\tNAV_FLAGS\022+\n\020navFlagsOverrid"
  "e\030\016 \001(\003B\021\212\372\001\tNAV_FLAGS\220\372\001\001\022$\n\tshapeMode\030"
  "\017 \001(\005B\021\212\372\001\tSHAPEMODE\220\372\001\001:\020\300\270\002\003\312\270\002\010nodePa"
  "th\"\301\001\n\017GameWeaponFired\0222\n\010position\030\001 \001(\013"
  "2\017.Analytics.Vec3B\017\342\372\001\004\n\00264\342\372\001\003\022\0011\022#\n\nat"
  "tackTeam\030\002 \001(\005B\017\212\372\001\007TEAM_ID\310\372\001\001\022#\n\010weapo"
  "nId\030\003 \001(\005B\021\212\372\001\tWEAPON_ID\310\372\001\001\022&\n\014firedByC"
  "lass\030\004 \001(\005B\020\212\372\001\010CLASS_ID\310\372\001\001:\010\300\270\002\002\330\270\002\001\"\253"
  "\001\n\tGameDeath\0222\n\010position\030\001 \001(\0132\017.Analyti"
  "cs.Vec3B\017\342\372\001\004\n\00232\342\372\001\003\022\0011\022#\n\nvictimTeam\030\002"
  " \001(\005B\017\212\372\001\007TEAM_ID\310\372\001\001\022#\n\nattackTeam\030\003 \001("
  "\005B\017\212\372\001\007TEAM_ID\310\372\001\001\022\032\n\014meansOfDeath\030\004 \001(\t"
  "B\004\310\372\001\001:\004\300\270\002\002\"\263\001\n\021GameKilledSomeone\0222\n\010po"
  "sition\030\001 \001(\0132\017.Analytics.Vec3B\017\342\372\001\004\n\00232\342"
  "\372\001\003\022\0011\022#\n\nvictimTeam\030\002 \001(\005B\017\212\372\001\007TEAM_ID\310"
  "\372\001\001\022#\n\nattackTeam\030\003 \001(\005B\017\212\372\001\007TEAM_ID\310\372\001\001"
  "\022\032\n\014meansOfDeath\030\004 \001(\tB\004\310\372\001\001:\004\300\270\002\002\"\367\001\n\021G"
  "ameRecieveDamage\022=\n\010position\030\001 \001(\0132\017.Ana"
  "lytics.Vec3B\032\342\372\001\004\n\00232\342\372\001\016\022\014damageAmount\022"
  "#\n\nvictimTeam\030\002 \001(\005B\017\212\372\001\007TEAM_ID\310\372\001\001\022#\n\n"
  "attackTeam\030\003 \001(\005B\017\212\372\001\007TEAM_ID\310\372\001\001\022#\n\010wea"
  "ponId\030\004 \001(\005B\021\212\372\001\tWEAPON_ID\310\372\001\001\022\030\n\ndamage"
  "Type\030\005 \001(\tB\004\310\372\001\001\022\024\n\014damageAmount\030\006 \001(\002:\004"
  "\300\270\002\002\"\367\001\n\021GameInflictDamage\022=\n\010position\030\001"
  " \001(\0132\017.Analytics.Vec3B\032\342\372\001\004\n\00232\342\372\001\016\022\014dam"
  "ageAmount\022#\n\nvictimTeam\030\002 \001(\005B\017\212\372\001\007TEAM_"
  "ID\310\372\001\001\022#\n\nattackTeam\030\003 \001(\005B\017\212\372\001\007TEAM_ID\310"
  "\372\001\001\022#\n\010weaponId\030\004 \001(\005B\021\212\372\001\tWEAPON_ID\310\372\001\001"
  "\022\030\n\ndamageType\030\005 \001(\tB\004\310\372\001\001\022\024\n\014damageAmou"
  "nt\030\006 \001(\002:\004\300\270\002\002\"\245\001\n\020GameRadiusDamage\022G\n\010p"
  "osition\030\001 \001(\0132\017.Analytics.Vec3B$\342\372\001\016\n\014da"
  "mageRadius\342\372\001\016\022\014damageAmount\022\022\n\ndamageTy"
  "pe\030\002 \001(\t\022\024\n\014damageAmount\030\003 \001(\002\022\024\n\014damage"
  "Radius\030\004 \001(\002:\010\300\270\002\002\330\270\002\001\"a\n\023GameNavigation"
  "Stuck\022\020\n\010entityId\030\001 \001(\005\0222\n\010position\030\002 \001("
  "\0132\017.Analytics.Vec3B\017\342\372\001\004\n\00232\342\372\001\003\022\0011:\004\300\270\002"
  "\002\"\205\001\n\016GameVoiceMacro\022\020\n\010entityId\030\001 \001(\005\022\'"
  "\n\nvoiceMacro\030\002 \001(\005B\023\212\372\001\013VOICE_MACRO\310\372\001\001\022"
  "2\n\010position\030\003 \001(\0132\017.Analytics.Vec3B\017\342\372\001\004"
  "\n\00232\342\372\001\003\022\0011:\004\300\270\002\002\"e\n\016GameLogMessage\022#\n\007l"
  "ogType\030\001 \001(\0162\022.Analytics.LogType\022\022\n\nlogM"
  "essage\030\002 \001(\t\022\024\n\014logExtraInfo\030\003 \001(\t:\004\300\270\002\002"
  "*:\n\014RedisKeyType\022\013\n\007UNKNOWN\020\000\022\007\n\003SET\020\001\022\t"
  "\n\005RPUSH\020\002\022\t\n\005HMSET\020\003*\?\n\rPrimitiveType\022\r\n"
  "\tTriangles\020\000\022\t\n\005Lines\020\001\022\n\n\006Points\020\002\022\010\n\004Q"
  "uad\020\003*;\n\013Compression\022\024\n\020Compression_None"
  "\020\000\022\026\n\022Compression_FastLZ\020\001**\n\007LogType\022\007\n"
  "\003Log\020\000\022\013\n\007Warning\020\001\022\t\n\005Error\020\003:O\n\014redisk"
  "eytype\022\037.google.protobuf.MessageOptions\030"
  "\210\' \001(\0162\027.Analytics.RedisKeyType:7\n\rredis"
  "hmsetkey\022\037.google.protobuf.MessageOption"
  "s\030\211\' \001(\t:8\n\016rediskeysuffix\022\037.google.prot"
  "obuf.MessageOptions\030\212\' \001(\t:9\n\017useJsonEnc"
  "oding\022\037.google.protobuf.MessageOptions\030\213"
  "\' \001(\010:4\n\nobjectname\022\037.google.protobuf.Me"
  "ssageOptions\030\215\' \001(\t:/\n\007enumkey\022\035.google."
  "protobuf.FieldOptions\030\241\037 \001(\t:0\n\010editable"
  "\022\035.google.protobuf.FieldOptions\030\242\037 \001(\010:/"
  "\n\007expires\022\035.google.protobuf.FieldOptions"
  "\030\243\037 \001(\005:1\n\tenumflags\022\035.google.protobuf.F"
  "ieldOptions\030\244\037 \001(\010:/\n\007tooltip\022\035.google.p"
  "rotobuf.FieldOptions\030\245\037 \001(\010:.\n\006hidden\022\035."
  "google.protobuf.FieldOptions\030\246\037 \001(\010:8\n\020e"
  "numflagsindexed\022\035.google.protobuf.FieldO"
  "ptions\030\247\037 \001(\010:4\n\014editable_key\022\035.google.p"
  "rotobuf.FieldOptions\030\250\037 \001(\010:3\n\013track_eve"
  "nt\022\035.google.protobuf.FieldOptions\030\251\037 \001(\010"
  ":J\n\013point_event\022\035.google.protobuf.FieldO"
  "ptions\030\254\037 \001(\0132\025.Analytics.PointEvent:H\n\n"
  "line_event\022\035.google.protobuf.FieldOption"
  "s\030\255\037 \001(\0132\024.Analytics.LineEventb\006proto3"
,
  "analytics.proto", &assign_descriptors_table_analytics_2eproto, 5878,
};

void AddDescriptors_analytics_2eproto() {
  static constexpr ::google::protobuf::internal::InitFunc deps[1] =
  {
    ::AddDescriptors_google_2fprotobuf_2fdescriptor_2eproto,
  };
 ::google::protobuf::internal::AddDescriptors(&descriptor_table_analytics_2eproto, deps, 1);
}

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_analytics_2eproto = []() { AddDescriptors_analytics_2eproto(); return true; }();
namespace Analytics {
const ::google::protobuf::EnumDescriptor* RedisKeyType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_analytics_2eproto);
  return file_level_enum_descriptors_analytics_2eproto[0];
}
bool RedisKeyType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PrimitiveType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_analytics_2eproto);
  return file_level_enum_descriptors_analytics_2eproto[1];
}
bool PrimitiveType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* Compression_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_analytics_2eproto);
  return file_level_enum_descriptors_analytics_2eproto[2];
}
bool Compression_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LogType_descriptor() {
  ::google::protobuf::internal::AssignDescriptors(&assign_descriptors_table_analytics_2eproto);
  return file_level_enum_descriptors_analytics_2eproto[3];
}
bool LogType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void PointEvent::InitAsDefaultInstance() {
}
class PointEvent::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PointEvent::kRadiusFieldNumber;
const int PointEvent::kWeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PointEvent::PointEvent()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.PointEvent)
}
PointEvent::PointEvent(const PointEvent& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  radius_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.radius().size() > 0) {
    radius_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.radius_);
  }
  weight_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.weight().size() > 0) {
    weight_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.weight_);
  }
  // @@protoc_insertion_point(copy_constructor:Analytics.PointEvent)
}

void PointEvent::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_PointEvent_analytics_2eproto.base);
  radius_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weight_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

PointEvent::~PointEvent() {
  // @@protoc_insertion_point(destructor:Analytics.PointEvent)
  SharedDtor();
}

void PointEvent::SharedDtor() {
  radius_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weight_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void PointEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PointEvent& PointEvent::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PointEvent_analytics_2eproto.base);
  return *internal_default_instance();
}


void PointEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.PointEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  radius_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PointEvent::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PointEvent*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string radius = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.PointEvent.radius");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_radius();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // string weight = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.PointEvent.weight");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_weight();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PointEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.PointEvent)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string radius = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_radius()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->radius().data(), static_cast<int>(this->radius().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.PointEvent.radius"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string weight = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_weight()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->weight().data(), static_cast<int>(this->weight().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.PointEvent.weight"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.PointEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.PointEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PointEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.PointEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string radius = 1;
  if (this->radius().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->radius().data(), static_cast<int>(this->radius().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.PointEvent.radius");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->radius(), output);
  }

  // string weight = 2;
  if (this->weight().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->weight().data(), static_cast<int>(this->weight().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.PointEvent.weight");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->weight(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.PointEvent)
}

::google::protobuf::uint8* PointEvent::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.PointEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string radius = 1;
  if (this->radius().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->radius().data(), static_cast<int>(this->radius().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.PointEvent.radius");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->radius(), target);
  }

  // string weight = 2;
  if (this->weight().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->weight().data(), static_cast<int>(this->weight().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.PointEvent.weight");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->weight(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.PointEvent)
  return target;
}

size_t PointEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.PointEvent)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string radius = 1;
  if (this->radius().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->radius());
  }

  // string weight = 2;
  if (this->weight().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->weight());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PointEvent::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.PointEvent)
  GOOGLE_DCHECK_NE(&from, this);
  const PointEvent* source =
      ::google::protobuf::DynamicCastToGenerated<PointEvent>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.PointEvent)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.PointEvent)
    MergeFrom(*source);
  }
}

void PointEvent::MergeFrom(const PointEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.PointEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.radius().size() > 0) {

    radius_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.radius_);
  }
  if (from.weight().size() > 0) {

    weight_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.weight_);
  }
}

void PointEvent::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.PointEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PointEvent::CopyFrom(const PointEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.PointEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PointEvent::IsInitialized() const {
  return true;
}

void PointEvent::Swap(PointEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PointEvent::InternalSwap(PointEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  radius_.Swap(&other->radius_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  weight_.Swap(&other->weight_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata PointEvent::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void LineEvent::InitAsDefaultInstance() {
}
class LineEvent::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LineEvent::kRadiusFieldNumber;
const int LineEvent::kWeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LineEvent::LineEvent()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.LineEvent)
}
LineEvent::LineEvent(const LineEvent& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  radius_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.radius().size() > 0) {
    radius_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.radius_);
  }
  weight_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.weight().size() > 0) {
    weight_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.weight_);
  }
  // @@protoc_insertion_point(copy_constructor:Analytics.LineEvent)
}

void LineEvent::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_LineEvent_analytics_2eproto.base);
  radius_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weight_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

LineEvent::~LineEvent() {
  // @@protoc_insertion_point(destructor:Analytics.LineEvent)
  SharedDtor();
}

void LineEvent::SharedDtor() {
  radius_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weight_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void LineEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LineEvent& LineEvent::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_LineEvent_analytics_2eproto.base);
  return *internal_default_instance();
}


void LineEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.LineEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  radius_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* LineEvent::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<LineEvent*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string radius = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.LineEvent.radius");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_radius();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // string weight = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.LineEvent.weight");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_weight();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool LineEvent::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.LineEvent)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string radius = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_radius()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->radius().data(), static_cast<int>(this->radius().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.LineEvent.radius"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string weight = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_weight()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->weight().data(), static_cast<int>(this->weight().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.LineEvent.weight"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.LineEvent)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.LineEvent)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void LineEvent::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.LineEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string radius = 1;
  if (this->radius().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->radius().data(), static_cast<int>(this->radius().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.LineEvent.radius");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->radius(), output);
  }

  // string weight = 2;
  if (this->weight().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->weight().data(), static_cast<int>(this->weight().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.LineEvent.weight");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->weight(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.LineEvent)
}

::google::protobuf::uint8* LineEvent::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.LineEvent)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string radius = 1;
  if (this->radius().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->radius().data(), static_cast<int>(this->radius().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.LineEvent.radius");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->radius(), target);
  }

  // string weight = 2;
  if (this->weight().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->weight().data(), static_cast<int>(this->weight().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.LineEvent.weight");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->weight(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.LineEvent)
  return target;
}

size_t LineEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.LineEvent)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string radius = 1;
  if (this->radius().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->radius());
  }

  // string weight = 2;
  if (this->weight().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->weight());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LineEvent::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.LineEvent)
  GOOGLE_DCHECK_NE(&from, this);
  const LineEvent* source =
      ::google::protobuf::DynamicCastToGenerated<LineEvent>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.LineEvent)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.LineEvent)
    MergeFrom(*source);
  }
}

void LineEvent::MergeFrom(const LineEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.LineEvent)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.radius().size() > 0) {

    radius_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.radius_);
  }
  if (from.weight().size() > 0) {

    weight_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.weight_);
  }
}

void LineEvent::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.LineEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LineEvent::CopyFrom(const LineEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.LineEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LineEvent::IsInitialized() const {
  return true;
}

void LineEvent::Swap(LineEvent* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LineEvent::InternalSwap(LineEvent* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  radius_.Swap(&other->radius_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  weight_.Swap(&other->weight_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata LineEvent::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EditorChangeValue::InitAsDefaultInstance() {
}
class EditorChangeValue::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EditorChangeValue::kMessageTypeFieldNumber;
const int EditorChangeValue::kFieldNameFieldNumber;
const int EditorChangeValue::kPayloadFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EditorChangeValue::EditorChangeValue()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.EditorChangeValue)
}
EditorChangeValue::EditorChangeValue(const EditorChangeValue& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  messagetype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.messagetype().size() > 0) {
    messagetype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.messagetype_);
  }
  fieldname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.fieldname().size() > 0) {
    fieldname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.fieldname_);
  }
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.payload().size() > 0) {
    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
  // @@protoc_insertion_point(copy_constructor:Analytics.EditorChangeValue)
}

void EditorChangeValue::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EditorChangeValue_analytics_2eproto.base);
  messagetype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fieldname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

EditorChangeValue::~EditorChangeValue() {
  // @@protoc_insertion_point(destructor:Analytics.EditorChangeValue)
  SharedDtor();
}

void EditorChangeValue::SharedDtor() {
  messagetype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fieldname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void EditorChangeValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EditorChangeValue& EditorChangeValue::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EditorChangeValue_analytics_2eproto.base);
  return *internal_default_instance();
}


void EditorChangeValue::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.EditorChangeValue)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  messagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fieldname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EditorChangeValue::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EditorChangeValue*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string messageType = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.EditorChangeValue.messageType");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_messagetype();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // string fieldName = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.EditorChangeValue.fieldName");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_fieldname();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // string payload = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.EditorChangeValue.payload");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_payload();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EditorChangeValue::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.EditorChangeValue)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string messageType = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_messagetype()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->messagetype().data(), static_cast<int>(this->messagetype().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.EditorChangeValue.messageType"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string fieldName = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fieldname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->fieldname().data(), static_cast<int>(this->fieldname().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.EditorChangeValue.fieldName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string payload = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_payload()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->payload().data(), static_cast<int>(this->payload().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.EditorChangeValue.payload"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.EditorChangeValue)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.EditorChangeValue)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EditorChangeValue::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.EditorChangeValue)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string messageType = 1;
  if (this->messagetype().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->messagetype().data(), static_cast<int>(this->messagetype().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.EditorChangeValue.messageType");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->messagetype(), output);
  }

  // string fieldName = 2;
  if (this->fieldname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->fieldname().data(), static_cast<int>(this->fieldname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.EditorChangeValue.fieldName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->fieldname(), output);
  }

  // string payload = 3;
  if (this->payload().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->payload().data(), static_cast<int>(this->payload().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.EditorChangeValue.payload");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->payload(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.EditorChangeValue)
}

::google::protobuf::uint8* EditorChangeValue::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.EditorChangeValue)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string messageType = 1;
  if (this->messagetype().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->messagetype().data(), static_cast<int>(this->messagetype().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.EditorChangeValue.messageType");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->messagetype(), target);
  }

  // string fieldName = 2;
  if (this->fieldname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->fieldname().data(), static_cast<int>(this->fieldname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.EditorChangeValue.fieldName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->fieldname(), target);
  }

  // string payload = 3;
  if (this->payload().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->payload().data(), static_cast<int>(this->payload().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.EditorChangeValue.payload");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->payload(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.EditorChangeValue)
  return target;
}

size_t EditorChangeValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.EditorChangeValue)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string messageType = 1;
  if (this->messagetype().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->messagetype());
  }

  // string fieldName = 2;
  if (this->fieldname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->fieldname());
  }

  // string payload = 3;
  if (this->payload().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->payload());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EditorChangeValue::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.EditorChangeValue)
  GOOGLE_DCHECK_NE(&from, this);
  const EditorChangeValue* source =
      ::google::protobuf::DynamicCastToGenerated<EditorChangeValue>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.EditorChangeValue)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.EditorChangeValue)
    MergeFrom(*source);
  }
}

void EditorChangeValue::MergeFrom(const EditorChangeValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.EditorChangeValue)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.messagetype().size() > 0) {

    messagetype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.messagetype_);
  }
  if (from.fieldname().size() > 0) {

    fieldname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.fieldname_);
  }
  if (from.payload().size() > 0) {

    payload_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.payload_);
  }
}

void EditorChangeValue::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.EditorChangeValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EditorChangeValue::CopyFrom(const EditorChangeValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.EditorChangeValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditorChangeValue::IsInitialized() const {
  return true;
}

void EditorChangeValue::Swap(EditorChangeValue* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EditorChangeValue::InternalSwap(EditorChangeValue* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  messagetype_.Swap(&other->messagetype_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  fieldname_.Swap(&other->fieldname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  payload_.Swap(&other->payload_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata EditorChangeValue::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void EditorChanges::InitAsDefaultInstance() {
}
class EditorChanges::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int EditorChanges::kChangesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

EditorChanges::EditorChanges()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.EditorChanges)
}
EditorChanges::EditorChanges(const EditorChanges& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      changes_(from.changes_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Analytics.EditorChanges)
}

void EditorChanges::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_EditorChanges_analytics_2eproto.base);
}

EditorChanges::~EditorChanges() {
  // @@protoc_insertion_point(destructor:Analytics.EditorChanges)
  SharedDtor();
}

void EditorChanges::SharedDtor() {
}

void EditorChanges::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EditorChanges& EditorChanges::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_EditorChanges_analytics_2eproto.base);
  return *internal_default_instance();
}


void EditorChanges::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.EditorChanges)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  changes_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* EditorChanges::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<EditorChanges*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .Analytics.EditorChangeValue changes = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = Varint::Parse32Inline(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::Analytics::EditorChangeValue::_InternalParse;
          object = msg->add_changes();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          bool ok = ctx->ParseExactRange({parser_till_end, object},
                                         ptr, newend);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          ptr = newend;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool EditorChanges::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.EditorChanges)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Analytics.EditorChangeValue changes = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_changes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.EditorChanges)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.EditorChanges)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void EditorChanges::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.EditorChanges)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Analytics.EditorChangeValue changes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->changes_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->changes(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.EditorChanges)
}

::google::protobuf::uint8* EditorChanges::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.EditorChanges)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Analytics.EditorChangeValue changes = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->changes_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->changes(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.EditorChanges)
  return target;
}

size_t EditorChanges::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.EditorChanges)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Analytics.EditorChangeValue changes = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->changes_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->changes(static_cast<int>(i)));
    }
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EditorChanges::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.EditorChanges)
  GOOGLE_DCHECK_NE(&from, this);
  const EditorChanges* source =
      ::google::protobuf::DynamicCastToGenerated<EditorChanges>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.EditorChanges)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.EditorChanges)
    MergeFrom(*source);
  }
}

void EditorChanges::MergeFrom(const EditorChanges& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.EditorChanges)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  changes_.MergeFrom(from.changes_);
}

void EditorChanges::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.EditorChanges)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EditorChanges::CopyFrom(const EditorChanges& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.EditorChanges)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EditorChanges::IsInitialized() const {
  return true;
}

void EditorChanges::Swap(EditorChanges* other) {
  if (other == this) return;
  InternalSwap(other);
}
void EditorChanges::InternalSwap(EditorChanges* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&changes_)->InternalSwap(CastToBase(&other->changes_));
}

::google::protobuf::Metadata EditorChanges::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void RangeF::InitAsDefaultInstance() {
}
class RangeF::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RangeF::kMinFieldNumber;
const int RangeF::kMaxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RangeF::RangeF()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.RangeF)
}
RangeF::RangeF(const RangeF& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&min_, &from.min_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_) -
    reinterpret_cast<char*>(&min_)) + sizeof(max_));
  // @@protoc_insertion_point(copy_constructor:Analytics.RangeF)
}

void RangeF::SharedCtor() {
  ::memset(&min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_) -
      reinterpret_cast<char*>(&min_)) + sizeof(max_));
}

RangeF::~RangeF() {
  // @@protoc_insertion_point(destructor:Analytics.RangeF)
  SharedDtor();
}

void RangeF::SharedDtor() {
}

void RangeF::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RangeF& RangeF::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_RangeF_analytics_2eproto.base);
  return *internal_default_instance();
}


void RangeF::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.RangeF)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_) -
      reinterpret_cast<char*>(&min_)) + sizeof(max_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RangeF::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<RangeF*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // float min = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_min(val);
        break;
      }
      // float max = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_max(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RangeF::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.RangeF)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float min = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &min_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float max = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &max_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.RangeF)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.RangeF)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RangeF::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.RangeF)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float min = 1;
  if (this->min() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->min(), output);
  }

  // float max = 2;
  if (this->max() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->max(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.RangeF)
}

::google::protobuf::uint8* RangeF::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.RangeF)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float min = 1;
  if (this->min() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->min(), target);
  }

  // float max = 2;
  if (this->max() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->max(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.RangeF)
  return target;
}

size_t RangeF::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.RangeF)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float min = 1;
  if (this->min() != 0) {
    total_size += 1 + 4;
  }

  // float max = 2;
  if (this->max() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RangeF::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.RangeF)
  GOOGLE_DCHECK_NE(&from, this);
  const RangeF* source =
      ::google::protobuf::DynamicCastToGenerated<RangeF>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.RangeF)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.RangeF)
    MergeFrom(*source);
  }
}

void RangeF::MergeFrom(const RangeF& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.RangeF)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.min() != 0) {
    set_min(from.min());
  }
  if (from.max() != 0) {
    set_max(from.max());
  }
}

void RangeF::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.RangeF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeF::CopyFrom(const RangeF& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.RangeF)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeF::IsInitialized() const {
  return true;
}

void RangeF::Swap(RangeF* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeF::InternalSwap(RangeF* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(min_, other->min_);
  swap(max_, other->max_);
}

::google::protobuf::Metadata RangeF::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void RangeI::InitAsDefaultInstance() {
}
class RangeI::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RangeI::kMinFieldNumber;
const int RangeI::kMaxFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RangeI::RangeI()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.RangeI)
}
RangeI::RangeI(const RangeI& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&min_, &from.min_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_) -
    reinterpret_cast<char*>(&min_)) + sizeof(max_));
  // @@protoc_insertion_point(copy_constructor:Analytics.RangeI)
}

void RangeI::SharedCtor() {
  ::memset(&min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_) -
      reinterpret_cast<char*>(&min_)) + sizeof(max_));
}

RangeI::~RangeI() {
  // @@protoc_insertion_point(destructor:Analytics.RangeI)
  SharedDtor();
}

void RangeI::SharedDtor() {
}

void RangeI::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RangeI& RangeI::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_RangeI_analytics_2eproto.base);
  return *internal_default_instance();
}


void RangeI::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.RangeI)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&min_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&max_) -
      reinterpret_cast<char*>(&min_)) + sizeof(max_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RangeI::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<RangeI*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int32 min = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_min(value);
        break;
      }
      // int32 max = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_max(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RangeI::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.RangeI)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 min = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &min_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 max = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.RangeI)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.RangeI)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RangeI::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.RangeI)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 min = 1;
  if (this->min() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->min(), output);
  }

  // int32 max = 2;
  if (this->max() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->max(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.RangeI)
}

::google::protobuf::uint8* RangeI::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.RangeI)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 min = 1;
  if (this->min() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->min(), target);
  }

  // int32 max = 2;
  if (this->max() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->max(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.RangeI)
  return target;
}

size_t RangeI::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.RangeI)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 min = 1;
  if (this->min() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->min());
  }

  // int32 max = 2;
  if (this->max() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->max());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RangeI::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.RangeI)
  GOOGLE_DCHECK_NE(&from, this);
  const RangeI* source =
      ::google::protobuf::DynamicCastToGenerated<RangeI>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.RangeI)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.RangeI)
    MergeFrom(*source);
  }
}

void RangeI::MergeFrom(const RangeI& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.RangeI)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.min() != 0) {
    set_min(from.min());
  }
  if (from.max() != 0) {
    set_max(from.max());
  }
}

void RangeI::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.RangeI)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RangeI::CopyFrom(const RangeI& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.RangeI)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RangeI::IsInitialized() const {
  return true;
}

void RangeI::Swap(RangeI* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RangeI::InternalSwap(RangeI* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(min_, other->min_);
  swap(max_, other->max_);
}

::google::protobuf::Metadata RangeI::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Vec3::InitAsDefaultInstance() {
}
class Vec3::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Vec3::kXFieldNumber;
const int Vec3::kYFieldNumber;
const int Vec3::kZFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Vec3::Vec3()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.Vec3)
}
Vec3::Vec3(const Vec3& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:Analytics.Vec3)
}

void Vec3::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Vec3::~Vec3() {
  // @@protoc_insertion_point(destructor:Analytics.Vec3)
  SharedDtor();
}

void Vec3::SharedDtor() {
}

void Vec3::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Vec3& Vec3::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Vec3_analytics_2eproto.base);
  return *internal_default_instance();
}


void Vec3::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.Vec3)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Vec3::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Vec3*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // float x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_x(val);
        break;
      }
      // float y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_y(val);
        break;
      }
      // float z = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_z(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Vec3::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.Vec3)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.Vec3)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.Vec3)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Vec3::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.Vec3)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // float y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // float z = 3;
  if (this->z() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.Vec3)
}

::google::protobuf::uint8* Vec3::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.Vec3)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // float y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // float z = 3;
  if (this->z() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.Vec3)
  return target;
}

size_t Vec3::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.Vec3)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (this->y() != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  if (this->z() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Vec3::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.Vec3)
  GOOGLE_DCHECK_NE(&from, this);
  const Vec3* source =
      ::google::protobuf::DynamicCastToGenerated<Vec3>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.Vec3)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.Vec3)
    MergeFrom(*source);
  }
}

void Vec3::MergeFrom(const Vec3& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.Vec3)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.z() != 0) {
    set_z(from.z());
  }
}

void Vec3::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.Vec3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vec3::CopyFrom(const Vec3& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.Vec3)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vec3::IsInitialized() const {
  return true;
}

void Vec3::Swap(Vec3* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Vec3::InternalSwap(Vec3* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
}

::google::protobuf::Metadata Vec3::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Vec3Color::InitAsDefaultInstance() {
}
class Vec3Color::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Vec3Color::kXFieldNumber;
const int Vec3Color::kYFieldNumber;
const int Vec3Color::kZFieldNumber;
const int Vec3Color::kColorFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Vec3Color::Vec3Color()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.Vec3Color)
}
Vec3Color::Vec3Color(const Vec3Color& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&color_) -
    reinterpret_cast<char*>(&x_)) + sizeof(color_));
  // @@protoc_insertion_point(copy_constructor:Analytics.Vec3Color)
}

void Vec3Color::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&color_) -
      reinterpret_cast<char*>(&x_)) + sizeof(color_));
}

Vec3Color::~Vec3Color() {
  // @@protoc_insertion_point(destructor:Analytics.Vec3Color)
  SharedDtor();
}

void Vec3Color::SharedDtor() {
}

void Vec3Color::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Vec3Color& Vec3Color::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Vec3Color_analytics_2eproto.base);
  return *internal_default_instance();
}


void Vec3Color::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.Vec3Color)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&color_) -
      reinterpret_cast<char*>(&x_)) + sizeof(color_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Vec3Color::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Vec3Color*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // float x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_x(val);
        break;
      }
      // float y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_y(val);
        break;
      }
      // float z = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_z(val);
        break;
      }
      // uint32 color = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_color(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Vec3Color::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.Vec3Color)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 color = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &color_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.Vec3Color)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.Vec3Color)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Vec3Color::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.Vec3Color)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // float y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // float z = 3;
  if (this->z() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  // uint32 color = 4;
  if (this->color() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->color(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.Vec3Color)
}

::google::protobuf::uint8* Vec3Color::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.Vec3Color)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // float y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // float z = 3;
  if (this->z() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  // uint32 color = 4;
  if (this->color() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->color(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.Vec3Color)
  return target;
}

size_t Vec3Color::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.Vec3Color)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (this->y() != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  if (this->z() != 0) {
    total_size += 1 + 4;
  }

  // uint32 color = 4;
  if (this->color() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->color());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Vec3Color::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.Vec3Color)
  GOOGLE_DCHECK_NE(&from, this);
  const Vec3Color* source =
      ::google::protobuf::DynamicCastToGenerated<Vec3Color>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.Vec3Color)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.Vec3Color)
    MergeFrom(*source);
  }
}

void Vec3Color::MergeFrom(const Vec3Color& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.Vec3Color)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.z() != 0) {
    set_z(from.z());
  }
  if (from.color() != 0) {
    set_color(from.color());
  }
}

void Vec3Color::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.Vec3Color)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vec3Color::CopyFrom(const Vec3Color& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.Vec3Color)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vec3Color::IsInitialized() const {
  return true;
}

void Vec3Color::Swap(Vec3Color* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Vec3Color::InternalSwap(Vec3Color* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(color_, other->color_);
}

::google::protobuf::Metadata Vec3Color::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Vec4::InitAsDefaultInstance() {
}
class Vec4::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Vec4::kXFieldNumber;
const int Vec4::kYFieldNumber;
const int Vec4::kZFieldNumber;
const int Vec4::kWFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Vec4::Vec4()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.Vec4)
}
Vec4::Vec4(const Vec4& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&w_) -
    reinterpret_cast<char*>(&x_)) + sizeof(w_));
  // @@protoc_insertion_point(copy_constructor:Analytics.Vec4)
}

void Vec4::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&w_) -
      reinterpret_cast<char*>(&x_)) + sizeof(w_));
}

Vec4::~Vec4() {
  // @@protoc_insertion_point(destructor:Analytics.Vec4)
  SharedDtor();
}

void Vec4::SharedDtor() {
}

void Vec4::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Vec4& Vec4::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Vec4_analytics_2eproto.base);
  return *internal_default_instance();
}


void Vec4::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.Vec4)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&w_) -
      reinterpret_cast<char*>(&x_)) + sizeof(w_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Vec4::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Vec4*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // float x = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_x(val);
        break;
      }
      // float y = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_y(val);
        break;
      }
      // float z = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_z(val);
        break;
      }
      // float w = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_w(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Vec4::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.Vec4)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float x = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float y = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float z = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float w = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &w_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.Vec4)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.Vec4)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Vec4::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.Vec4)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // float y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // float z = 3;
  if (this->z() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->z(), output);
  }

  // float w = 4;
  if (this->w() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->w(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.Vec4)
}

::google::protobuf::uint8* Vec4::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.Vec4)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // float y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // float z = 3;
  if (this->z() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->z(), target);
  }

  // float w = 4;
  if (this->w() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->w(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.Vec4)
  return target;
}

size_t Vec4::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.Vec4)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  if (this->x() != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  if (this->y() != 0) {
    total_size += 1 + 4;
  }

  // float z = 3;
  if (this->z() != 0) {
    total_size += 1 + 4;
  }

  // float w = 4;
  if (this->w() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Vec4::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.Vec4)
  GOOGLE_DCHECK_NE(&from, this);
  const Vec4* source =
      ::google::protobuf::DynamicCastToGenerated<Vec4>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.Vec4)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.Vec4)
    MergeFrom(*source);
  }
}

void Vec4::MergeFrom(const Vec4& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.Vec4)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.z() != 0) {
    set_z(from.z());
  }
  if (from.w() != 0) {
    set_w(from.w());
  }
}

void Vec4::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.Vec4)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Vec4::CopyFrom(const Vec4& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.Vec4)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Vec4::IsInitialized() const {
  return true;
}

void Vec4::Swap(Vec4* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Vec4::InternalSwap(Vec4* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(x_, other->x_);
  swap(y_, other->y_);
  swap(z_, other->z_);
  swap(w_, other->w_);
}

::google::protobuf::Metadata Vec4::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Line::InitAsDefaultInstance() {
  ::Analytics::_Line_default_instance_._instance.get_mutable()->p0_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
  ::Analytics::_Line_default_instance_._instance.get_mutable()->p1_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class Line::HasBitSetters {
 public:
  static const ::Analytics::Vec3& p0(const Line* msg);
  static const ::Analytics::Vec3& p1(const Line* msg);
};

const ::Analytics::Vec3&
Line::HasBitSetters::p0(const Line* msg) {
  return *msg->p0_;
}
const ::Analytics::Vec3&
Line::HasBitSetters::p1(const Line* msg) {
  return *msg->p1_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Line::kP0FieldNumber;
const int Line::kP1FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Line::Line()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.Line)
}
Line::Line(const Line& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_p0()) {
    p0_ = new ::Analytics::Vec3(*from.p0_);
  } else {
    p0_ = NULL;
  }
  if (from.has_p1()) {
    p1_ = new ::Analytics::Vec3(*from.p1_);
  } else {
    p1_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:Analytics.Line)
}

void Line::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Line_analytics_2eproto.base);
  ::memset(&p0_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&p1_) -
      reinterpret_cast<char*>(&p0_)) + sizeof(p1_));
}

Line::~Line() {
  // @@protoc_insertion_point(destructor:Analytics.Line)
  SharedDtor();
}

void Line::SharedDtor() {
  if (this != internal_default_instance()) delete p0_;
  if (this != internal_default_instance()) delete p1_;
}

void Line::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Line& Line::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Line_analytics_2eproto.base);
  return *internal_default_instance();
}


void Line::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.Line)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && p0_ != NULL) {
    delete p0_;
  }
  p0_ = NULL;
  if (GetArenaNoVirtual() == NULL && p1_ != NULL) {
    delete p1_;
  }
  p1_ = NULL;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Line::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Line*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.Vec3 p0 = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_p0();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // .Analytics.Vec3 p1 = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_p1();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Line::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.Line)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.Vec3 p0 = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_p0()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 p1 = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_p1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.Line)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.Line)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Line::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.Line)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 p0 = 1;
  if (this->has_p0()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::p0(this), output);
  }

  // .Analytics.Vec3 p1 = 2;
  if (this->has_p1()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::p1(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.Line)
}

::google::protobuf::uint8* Line::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.Line)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 p0 = 1;
  if (this->has_p0()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::p0(this), deterministic, target);
  }

  // .Analytics.Vec3 p1 = 2;
  if (this->has_p1()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::p1(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.Line)
  return target;
}

size_t Line::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.Line)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Analytics.Vec3 p0 = 1;
  if (this->has_p0()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *p0_);
  }

  // .Analytics.Vec3 p1 = 2;
  if (this->has_p1()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *p1_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Line::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.Line)
  GOOGLE_DCHECK_NE(&from, this);
  const Line* source =
      ::google::protobuf::DynamicCastToGenerated<Line>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.Line)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.Line)
    MergeFrom(*source);
  }
}

void Line::MergeFrom(const Line& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.Line)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_p0()) {
    mutable_p0()->::Analytics::Vec3::MergeFrom(from.p0());
  }
  if (from.has_p1()) {
    mutable_p1()->::Analytics::Vec3::MergeFrom(from.p1());
  }
}

void Line::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.Line)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Line::CopyFrom(const Line& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.Line)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Line::IsInitialized() const {
  return true;
}

void Line::Swap(Line* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Line::InternalSwap(Line* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(p0_, other->p0_);
  swap(p1_, other->p1_);
}

::google::protobuf::Metadata Line::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Euler::InitAsDefaultInstance() {
}
class Euler::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Euler::kHeadingFieldNumber;
const int Euler::kPitchFieldNumber;
const int Euler::kRollFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Euler::Euler()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.Euler)
}
Euler::Euler(const Euler& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&heading_, &from.heading_,
    static_cast<size_t>(reinterpret_cast<char*>(&roll_) -
    reinterpret_cast<char*>(&heading_)) + sizeof(roll_));
  // @@protoc_insertion_point(copy_constructor:Analytics.Euler)
}

void Euler::SharedCtor() {
  ::memset(&heading_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&roll_) -
      reinterpret_cast<char*>(&heading_)) + sizeof(roll_));
}

Euler::~Euler() {
  // @@protoc_insertion_point(destructor:Analytics.Euler)
  SharedDtor();
}

void Euler::SharedDtor() {
}

void Euler::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Euler& Euler::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Euler_analytics_2eproto.base);
  return *internal_default_instance();
}


void Euler::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&heading_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&roll_) -
      reinterpret_cast<char*>(&heading_)) + sizeof(roll_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Euler::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Euler*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // float heading = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 13) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_heading(val);
        break;
      }
      // float pitch = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 21) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_pitch(val);
        break;
      }
      // float roll = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_roll(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Euler::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.Euler)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // float heading = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (13 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &heading_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float pitch = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (21 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pitch_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float roll = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &roll_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.Euler)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.Euler)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Euler::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float heading = 1;
  if (this->heading() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->heading(), output);
  }

  // float pitch = 2;
  if (this->pitch() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->pitch(), output);
  }

  // float roll = 3;
  if (this->roll() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->roll(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.Euler)
}

::google::protobuf::uint8* Euler::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.Euler)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // float heading = 1;
  if (this->heading() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->heading(), target);
  }

  // float pitch = 2;
  if (this->pitch() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->pitch(), target);
  }

  // float roll = 3;
  if (this->roll() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->roll(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.Euler)
  return target;
}

size_t Euler::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.Euler)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float heading = 1;
  if (this->heading() != 0) {
    total_size += 1 + 4;
  }

  // float pitch = 2;
  if (this->pitch() != 0) {
    total_size += 1 + 4;
  }

  // float roll = 3;
  if (this->roll() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Euler::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.Euler)
  GOOGLE_DCHECK_NE(&from, this);
  const Euler* source =
      ::google::protobuf::DynamicCastToGenerated<Euler>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.Euler)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.Euler)
    MergeFrom(*source);
  }
}

void Euler::MergeFrom(const Euler& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.Euler)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.heading() != 0) {
    set_heading(from.heading());
  }
  if (from.pitch() != 0) {
    set_pitch(from.pitch());
  }
  if (from.roll() != 0) {
    set_roll(from.roll());
  }
}

void Euler::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Euler::CopyFrom(const Euler& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.Euler)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Euler::IsInitialized() const {
  return true;
}

void Euler::Swap(Euler* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Euler::InternalSwap(Euler* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(heading_, other->heading_);
  swap(pitch_, other->pitch_);
  swap(roll_, other->roll_);
}

::google::protobuf::Metadata Euler::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Material::InitAsDefaultInstance() {
}
class Material::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Material::kNameFieldNumber;
const int Material::kContentsFieldNumber;
const int Material::kSurfaceFlagsFieldNumber;
const int Material::kRenderEventsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Material::Material()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.Material)
}
Material::Material(const Material& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.name().size() > 0) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  ::memcpy(&contents_, &from.contents_,
    static_cast<size_t>(reinterpret_cast<char*>(&renderevents_) -
    reinterpret_cast<char*>(&contents_)) + sizeof(renderevents_));
  // @@protoc_insertion_point(copy_constructor:Analytics.Material)
}

void Material::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Material_analytics_2eproto.base);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&contents_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&renderevents_) -
      reinterpret_cast<char*>(&contents_)) + sizeof(renderevents_));
}

Material::~Material() {
  // @@protoc_insertion_point(destructor:Analytics.Material)
  SharedDtor();
}

void Material::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Material::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Material& Material::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Material_analytics_2eproto.base);
  return *internal_default_instance();
}


void Material::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.Material)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&contents_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&renderevents_) -
      reinterpret_cast<char*>(&contents_)) + sizeof(renderevents_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Material::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Material*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.Material.name");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_name();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // uint32 contents = 2 [(.Analytics.enumkey) = "CONTENT_FLAGS", (.Analytics.enumflags) = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_contents(value);
        break;
      }
      // uint32 surfaceFlags = 3 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.enumflags) = true];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_surfaceflags(value);
        break;
      }
      // bool renderEvents = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_renderevents(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Material::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.Material)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.Material.name"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 contents = 2 [(.Analytics.enumkey) = "CONTENT_FLAGS", (.Analytics.enumflags) = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &contents_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 surfaceFlags = 3 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.enumflags) = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &surfaceflags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool renderEvents = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &renderevents_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.Material)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.Material)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Material::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.Material)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.Material.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // uint32 contents = 2 [(.Analytics.enumkey) = "CONTENT_FLAGS", (.Analytics.enumflags) = true];
  if (this->contents() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->contents(), output);
  }

  // uint32 surfaceFlags = 3 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.enumflags) = true];
  if (this->surfaceflags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->surfaceflags(), output);
  }

  // bool renderEvents = 4;
  if (this->renderevents() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->renderevents(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.Material)
}

::google::protobuf::uint8* Material::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.Material)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.Material.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // uint32 contents = 2 [(.Analytics.enumkey) = "CONTENT_FLAGS", (.Analytics.enumflags) = true];
  if (this->contents() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->contents(), target);
  }

  // uint32 surfaceFlags = 3 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.enumflags) = true];
  if (this->surfaceflags() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->surfaceflags(), target);
  }

  // bool renderEvents = 4;
  if (this->renderevents() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->renderevents(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.Material)
  return target;
}

size_t Material::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.Material)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // uint32 contents = 2 [(.Analytics.enumkey) = "CONTENT_FLAGS", (.Analytics.enumflags) = true];
  if (this->contents() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->contents());
  }

  // uint32 surfaceFlags = 3 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.enumflags) = true];
  if (this->surfaceflags() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->surfaceflags());
  }

  // bool renderEvents = 4;
  if (this->renderevents() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Material::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.Material)
  GOOGLE_DCHECK_NE(&from, this);
  const Material* source =
      ::google::protobuf::DynamicCastToGenerated<Material>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.Material)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.Material)
    MergeFrom(*source);
  }
}

void Material::MergeFrom(const Material& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.Material)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.contents() != 0) {
    set_contents(from.contents());
  }
  if (from.surfaceflags() != 0) {
    set_surfaceflags(from.surfaceflags());
  }
  if (from.renderevents() != 0) {
    set_renderevents(from.renderevents());
  }
}

void Material::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.Material)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Material::CopyFrom(const Material& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.Material)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Material::IsInitialized() const {
  return true;
}

void Material::Swap(Material* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Material::InternalSwap(Material* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(contents_, other->contents_);
  swap(surfaceflags_, other->surfaceflags_);
  swap(renderevents_, other->renderevents_);
}

::google::protobuf::Metadata Material::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void PrimitiveOptions::InitAsDefaultInstance() {
}
class PrimitiveOptions::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PrimitiveOptions::kPartIndexFieldNumber;
const int PrimitiveOptions::kOverrideSurfaceFlagsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PrimitiveOptions::PrimitiveOptions()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.PrimitiveOptions)
}
PrimitiveOptions::PrimitiveOptions(const PrimitiveOptions& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&partindex_, &from.partindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&overridesurfaceflags_) -
    reinterpret_cast<char*>(&partindex_)) + sizeof(overridesurfaceflags_));
  // @@protoc_insertion_point(copy_constructor:Analytics.PrimitiveOptions)
}

void PrimitiveOptions::SharedCtor() {
  ::memset(&partindex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&overridesurfaceflags_) -
      reinterpret_cast<char*>(&partindex_)) + sizeof(overridesurfaceflags_));
}

PrimitiveOptions::~PrimitiveOptions() {
  // @@protoc_insertion_point(destructor:Analytics.PrimitiveOptions)
  SharedDtor();
}

void PrimitiveOptions::SharedDtor() {
}

void PrimitiveOptions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const PrimitiveOptions& PrimitiveOptions::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_PrimitiveOptions_analytics_2eproto.base);
  return *internal_default_instance();
}


void PrimitiveOptions::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.PrimitiveOptions)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&partindex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&overridesurfaceflags_) -
      reinterpret_cast<char*>(&partindex_)) + sizeof(overridesurfaceflags_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* PrimitiveOptions::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<PrimitiveOptions*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // uint32 partIndex = 1 [(.Analytics.editable_key) = true];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_partindex(value);
        break;
      }
      // uint32 overrideSurfaceFlags = 2 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.editable) = true, (.Analytics.enumflags) = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_overridesurfaceflags(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool PrimitiveOptions::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.PrimitiveOptions)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 partIndex = 1 [(.Analytics.editable_key) = true];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &partindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 overrideSurfaceFlags = 2 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.editable) = true, (.Analytics.enumflags) = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &overridesurfaceflags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.PrimitiveOptions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.PrimitiveOptions)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void PrimitiveOptions::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.PrimitiveOptions)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 partIndex = 1 [(.Analytics.editable_key) = true];
  if (this->partindex() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->partindex(), output);
  }

  // uint32 overrideSurfaceFlags = 2 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.editable) = true, (.Analytics.enumflags) = true];
  if (this->overridesurfaceflags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->overridesurfaceflags(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.PrimitiveOptions)
}

::google::protobuf::uint8* PrimitiveOptions::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.PrimitiveOptions)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 partIndex = 1 [(.Analytics.editable_key) = true];
  if (this->partindex() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->partindex(), target);
  }

  // uint32 overrideSurfaceFlags = 2 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.editable) = true, (.Analytics.enumflags) = true];
  if (this->overridesurfaceflags() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->overridesurfaceflags(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.PrimitiveOptions)
  return target;
}

size_t PrimitiveOptions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.PrimitiveOptions)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 partIndex = 1 [(.Analytics.editable_key) = true];
  if (this->partindex() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->partindex());
  }

  // uint32 overrideSurfaceFlags = 2 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.editable) = true, (.Analytics.enumflags) = true];
  if (this->overridesurfaceflags() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->overridesurfaceflags());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PrimitiveOptions::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.PrimitiveOptions)
  GOOGLE_DCHECK_NE(&from, this);
  const PrimitiveOptions* source =
      ::google::protobuf::DynamicCastToGenerated<PrimitiveOptions>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.PrimitiveOptions)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.PrimitiveOptions)
    MergeFrom(*source);
  }
}

void PrimitiveOptions::MergeFrom(const PrimitiveOptions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.PrimitiveOptions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.partindex() != 0) {
    set_partindex(from.partindex());
  }
  if (from.overridesurfaceflags() != 0) {
    set_overridesurfaceflags(from.overridesurfaceflags());
  }
}

void PrimitiveOptions::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.PrimitiveOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PrimitiveOptions::CopyFrom(const PrimitiveOptions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.PrimitiveOptions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PrimitiveOptions::IsInitialized() const {
  return true;
}

void PrimitiveOptions::Swap(PrimitiveOptions* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PrimitiveOptions::InternalSwap(PrimitiveOptions* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(partindex_, other->partindex_);
  swap(overridesurfaceflags_, other->overridesurfaceflags_);
}

::google::protobuf::Metadata PrimitiveOptions::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Primitive::InitAsDefaultInstance() {
  ::Analytics::_Primitive_default_instance_._instance.get_mutable()->options_ = const_cast< ::Analytics::PrimitiveOptions*>(
      ::Analytics::PrimitiveOptions::internal_default_instance());
}
class Primitive::HasBitSetters {
 public:
  static const ::Analytics::PrimitiveOptions& options(const Primitive* msg);
};

const ::Analytics::PrimitiveOptions&
Primitive::HasBitSetters::options(const Primitive* msg) {
  return *msg->options_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Primitive::kTypeFieldNumber;
const int Primitive::kMaterialIndexFieldNumber;
const int Primitive::kOptionsFieldNumber;
const int Primitive::kSizeFieldNumber;
const int Primitive::kVerticesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Primitive::Primitive()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.Primitive)
}
Primitive::Primitive(const Primitive& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      vertices_(from.vertices_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_options()) {
    options_ = new ::Analytics::PrimitiveOptions(*from.options_);
  } else {
    options_ = NULL;
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&size_) -
    reinterpret_cast<char*>(&type_)) + sizeof(size_));
  // @@protoc_insertion_point(copy_constructor:Analytics.Primitive)
}

void Primitive::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Primitive_analytics_2eproto.base);
  ::memset(&options_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&size_) -
      reinterpret_cast<char*>(&options_)) + sizeof(size_));
}

Primitive::~Primitive() {
  // @@protoc_insertion_point(destructor:Analytics.Primitive)
  SharedDtor();
}

void Primitive::SharedDtor() {
  if (this != internal_default_instance()) delete options_;
}

void Primitive::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Primitive& Primitive::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Primitive_analytics_2eproto.base);
  return *internal_default_instance();
}


void Primitive::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.Primitive)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  vertices_.Clear();
  if (GetArenaNoVirtual() == NULL && options_ != NULL) {
    delete options_;
  }
  options_ = NULL;
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&size_) -
      reinterpret_cast<char*>(&type_)) + sizeof(size_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Primitive::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Primitive*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.PrimitiveType type = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::Analytics::PrimitiveType value = static_cast<::Analytics::PrimitiveType>(val);
        msg->set_type(value);
        break;
      }
      // uint32 materialIndex = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_materialindex(value);
        break;
      }
      // .Analytics.PrimitiveOptions options = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::PrimitiveOptions::_InternalParse;
        object = msg->mutable_options();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // float size = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_size(val);
        break;
      }
      // repeated .Analytics.Vec3Color vertices = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        do {
          ptr = Varint::Parse32Inline(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::Analytics::Vec3Color::_InternalParse;
          object = msg->add_vertices();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          bool ok = ctx->ParseExactRange({parser_till_end, object},
                                         ptr, newend);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          ptr = newend;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 42 && (ptr += 1));
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Primitive::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.Primitive)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.PrimitiveType type = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::Analytics::PrimitiveType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 materialIndex = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &materialindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.PrimitiveOptions options = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_options()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float size = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Analytics.Vec3Color vertices = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_vertices()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.Primitive)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.Primitive)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Primitive::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.Primitive)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.PrimitiveType type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // uint32 materialIndex = 2;
  if (this->materialindex() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->materialindex(), output);
  }

  // .Analytics.PrimitiveOptions options = 3;
  if (this->has_options()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::options(this), output);
  }

  // float size = 4;
  if (this->size() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->size(), output);
  }

  // repeated .Analytics.Vec3Color vertices = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->vertices_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5,
      this->vertices(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.Primitive)
}

::google::protobuf::uint8* Primitive::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.Primitive)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.PrimitiveType type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // uint32 materialIndex = 2;
  if (this->materialindex() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->materialindex(), target);
  }

  // .Analytics.PrimitiveOptions options = 3;
  if (this->has_options()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::options(this), deterministic, target);
  }

  // float size = 4;
  if (this->size() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->size(), target);
  }

  // repeated .Analytics.Vec3Color vertices = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->vertices_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, this->vertices(static_cast<int>(i)), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.Primitive)
  return target;
}

size_t Primitive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.Primitive)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Analytics.Vec3Color vertices = 5;
  {
    unsigned int count = static_cast<unsigned int>(this->vertices_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->vertices(static_cast<int>(i)));
    }
  }

  // .Analytics.PrimitiveOptions options = 3;
  if (this->has_options()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *options_);
  }

  // .Analytics.PrimitiveType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // uint32 materialIndex = 2;
  if (this->materialindex() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->materialindex());
  }

  // float size = 4;
  if (this->size() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Primitive::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.Primitive)
  GOOGLE_DCHECK_NE(&from, this);
  const Primitive* source =
      ::google::protobuf::DynamicCastToGenerated<Primitive>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.Primitive)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.Primitive)
    MergeFrom(*source);
  }
}

void Primitive::MergeFrom(const Primitive& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.Primitive)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  vertices_.MergeFrom(from.vertices_);
  if (from.has_options()) {
    mutable_options()->::Analytics::PrimitiveOptions::MergeFrom(from.options());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.materialindex() != 0) {
    set_materialindex(from.materialindex());
  }
  if (from.size() != 0) {
    set_size(from.size());
  }
}

void Primitive::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.Primitive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Primitive::CopyFrom(const Primitive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.Primitive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Primitive::IsInitialized() const {
  return true;
}

void Primitive::Swap(Primitive* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Primitive::InternalSwap(Primitive* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&vertices_)->InternalSwap(CastToBase(&other->vertices_));
  swap(options_, other->options_);
  swap(type_, other->type_);
  swap(materialindex_, other->materialindex_);
  swap(size_, other->size_);
}

::google::protobuf::Metadata Primitive::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void Mesh::InitAsDefaultInstance() {
}
class Mesh::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Mesh::kPrimitivesFieldNumber;
const int Mesh::kMaterialsFieldNumber;
const int Mesh::kNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Mesh::Mesh()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.Mesh)
}
Mesh::Mesh(const Mesh& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      primitives_(from.primitives_),
      materials_(from.materials_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.name().size() > 0) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  // @@protoc_insertion_point(copy_constructor:Analytics.Mesh)
}

void Mesh::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_Mesh_analytics_2eproto.base);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Mesh::~Mesh() {
  // @@protoc_insertion_point(destructor:Analytics.Mesh)
  SharedDtor();
}

void Mesh::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void Mesh::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Mesh& Mesh::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_Mesh_analytics_2eproto.base);
  return *internal_default_instance();
}


void Mesh::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.Mesh)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  primitives_.Clear();
  materials_.Clear();
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Mesh::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<Mesh*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .Analytics.Primitive primitives = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = Varint::Parse32Inline(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::Analytics::Primitive::_InternalParse;
          object = msg->add_primitives();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          bool ok = ctx->ParseExactRange({parser_till_end, object},
                                         ptr, newend);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          ptr = newend;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // repeated .Analytics.Material materials = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        do {
          ptr = Varint::Parse32Inline(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::Analytics::Material::_InternalParse;
          object = msg->add_materials();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          bool ok = ctx->ParseExactRange({parser_till_end, object},
                                         ptr, newend);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          ptr = newend;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 18 && (ptr += 1));
        break;
      }
      // string name = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.Mesh.name");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_name();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Mesh::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.Mesh)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Analytics.Primitive primitives = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_primitives()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Analytics.Material materials = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_materials()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string name = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.Mesh.name"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.Mesh)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.Mesh)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Mesh::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.Mesh)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Analytics.Primitive primitives = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->primitives_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->primitives(static_cast<int>(i)),
      output);
  }

  // repeated .Analytics.Material materials = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->materials_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->materials(static_cast<int>(i)),
      output);
  }

  // string name = 3;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.Mesh.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.Mesh)
}

::google::protobuf::uint8* Mesh::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.Mesh)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Analytics.Primitive primitives = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->primitives_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->primitives(static_cast<int>(i)), deterministic, target);
  }

  // repeated .Analytics.Material materials = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->materials_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->materials(static_cast<int>(i)), deterministic, target);
  }

  // string name = 3;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.Mesh.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.Mesh)
  return target;
}

size_t Mesh::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.Mesh)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Analytics.Primitive primitives = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->primitives_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->primitives(static_cast<int>(i)));
    }
  }

  // repeated .Analytics.Material materials = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->materials_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->materials(static_cast<int>(i)));
    }
  }

  // string name = 3;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Mesh::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.Mesh)
  GOOGLE_DCHECK_NE(&from, this);
  const Mesh* source =
      ::google::protobuf::DynamicCastToGenerated<Mesh>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.Mesh)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.Mesh)
    MergeFrom(*source);
  }
}

void Mesh::MergeFrom(const Mesh& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.Mesh)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  primitives_.MergeFrom(from.primitives_);
  materials_.MergeFrom(from.materials_);
  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
}

void Mesh::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.Mesh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Mesh::CopyFrom(const Mesh& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.Mesh)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Mesh::IsInitialized() const {
  return true;
}

void Mesh::Swap(Mesh* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Mesh::InternalSwap(Mesh* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&primitives_)->InternalSwap(CastToBase(&other->primitives_));
  CastToBase(&materials_)->InternalSwap(CastToBase(&other->materials_));
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata Mesh::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void UTCTime::InitAsDefaultInstance() {
}
class UTCTime::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UTCTime::kHourFieldNumber;
const int UTCTime::kMinuteFieldNumber;
const int UTCTime::kSecondFieldNumber;
const int UTCTime::kDayFieldNumber;
const int UTCTime::kMonthFieldNumber;
const int UTCTime::kYearFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UTCTime::UTCTime()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.UTCTime)
}
UTCTime::UTCTime(const UTCTime& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&hour_, &from.hour_,
    static_cast<size_t>(reinterpret_cast<char*>(&year_) -
    reinterpret_cast<char*>(&hour_)) + sizeof(year_));
  // @@protoc_insertion_point(copy_constructor:Analytics.UTCTime)
}

void UTCTime::SharedCtor() {
  ::memset(&hour_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&year_) -
      reinterpret_cast<char*>(&hour_)) + sizeof(year_));
}

UTCTime::~UTCTime() {
  // @@protoc_insertion_point(destructor:Analytics.UTCTime)
  SharedDtor();
}

void UTCTime::SharedDtor() {
}

void UTCTime::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UTCTime& UTCTime::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_UTCTime_analytics_2eproto.base);
  return *internal_default_instance();
}


void UTCTime::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.UTCTime)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&hour_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&year_) -
      reinterpret_cast<char*>(&hour_)) + sizeof(year_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UTCTime::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<UTCTime*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int32 hour = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_hour(value);
        break;
      }
      // int32 minute = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_minute(value);
        break;
      }
      // int32 second = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_second(value);
        break;
      }
      // int32 day = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_day(value);
        break;
      }
      // int32 month = 5;
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_month(value);
        break;
      }
      // int32 year = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_year(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UTCTime::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.UTCTime)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 hour = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &hour_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 minute = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minute_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 second = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &second_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 day = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &day_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 month = 5;
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &month_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 year = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &year_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.UTCTime)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.UTCTime)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UTCTime::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.UTCTime)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 hour = 1;
  if (this->hour() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->hour(), output);
  }

  // int32 minute = 2;
  if (this->minute() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->minute(), output);
  }

  // int32 second = 3;
  if (this->second() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->second(), output);
  }

  // int32 day = 4;
  if (this->day() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->day(), output);
  }

  // int32 month = 5;
  if (this->month() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->month(), output);
  }

  // int32 year = 6;
  if (this->year() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->year(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.UTCTime)
}

::google::protobuf::uint8* UTCTime::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.UTCTime)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 hour = 1;
  if (this->hour() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->hour(), target);
  }

  // int32 minute = 2;
  if (this->minute() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->minute(), target);
  }

  // int32 second = 3;
  if (this->second() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->second(), target);
  }

  // int32 day = 4;
  if (this->day() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->day(), target);
  }

  // int32 month = 5;
  if (this->month() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->month(), target);
  }

  // int32 year = 6;
  if (this->year() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->year(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.UTCTime)
  return target;
}

size_t UTCTime::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.UTCTime)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 hour = 1;
  if (this->hour() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->hour());
  }

  // int32 minute = 2;
  if (this->minute() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->minute());
  }

  // int32 second = 3;
  if (this->second() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->second());
  }

  // int32 day = 4;
  if (this->day() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->day());
  }

  // int32 month = 5;
  if (this->month() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->month());
  }

  // int32 year = 6;
  if (this->year() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->year());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UTCTime::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.UTCTime)
  GOOGLE_DCHECK_NE(&from, this);
  const UTCTime* source =
      ::google::protobuf::DynamicCastToGenerated<UTCTime>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.UTCTime)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.UTCTime)
    MergeFrom(*source);
  }
}

void UTCTime::MergeFrom(const UTCTime& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.UTCTime)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.hour() != 0) {
    set_hour(from.hour());
  }
  if (from.minute() != 0) {
    set_minute(from.minute());
  }
  if (from.second() != 0) {
    set_second(from.second());
  }
  if (from.day() != 0) {
    set_day(from.day());
  }
  if (from.month() != 0) {
    set_month(from.month());
  }
  if (from.year() != 0) {
    set_year(from.year());
  }
}

void UTCTime::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.UTCTime)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UTCTime::CopyFrom(const UTCTime& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.UTCTime)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UTCTime::IsInitialized() const {
  return true;
}

void UTCTime::Swap(UTCTime* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UTCTime::InternalSwap(UTCTime* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(hour_, other->hour_);
  swap(minute_, other->minute_);
  swap(second_, other->second_);
  swap(day_, other->day_);
  swap(month_, other->month_);
  swap(year_, other->year_);
}

::google::protobuf::Metadata UTCTime::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameInfo::InitAsDefaultInstance() {
  ::Analytics::_GameInfo_default_instance_._instance.get_mutable()->timestamp_ = const_cast< ::Analytics::UTCTime*>(
      ::Analytics::UTCTime::internal_default_instance());
}
class GameInfo::HasBitSetters {
 public:
  static const ::Analytics::UTCTime& timestamp(const GameInfo* msg);
};

const ::Analytics::UTCTime&
GameInfo::HasBitSetters::timestamp(const GameInfo* msg) {
  return *msg->timestamp_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameInfo::kTimeStampFieldNumber;
const int GameInfo::kMapNameFieldNumber;
const int GameInfo::kGameNameFieldNumber;
const int GameInfo::kGameVersionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameInfo::GameInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameInfo)
}
GameInfo::GameInfo(const GameInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  mapname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.mapname().size() > 0) {
    mapname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mapname_);
  }
  gamename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.gamename().size() > 0) {
    gamename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gamename_);
  }
  gameversion_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.gameversion().size() > 0) {
    gameversion_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gameversion_);
  }
  if (from.has_timestamp()) {
    timestamp_ = new ::Analytics::UTCTime(*from.timestamp_);
  } else {
    timestamp_ = NULL;
  }
  // @@protoc_insertion_point(copy_constructor:Analytics.GameInfo)
}

void GameInfo::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameInfo_analytics_2eproto.base);
  mapname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gamename_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gameversion_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  timestamp_ = NULL;
}

GameInfo::~GameInfo() {
  // @@protoc_insertion_point(destructor:Analytics.GameInfo)
  SharedDtor();
}

void GameInfo::SharedDtor() {
  mapname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gamename_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gameversion_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete timestamp_;
}

void GameInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameInfo& GameInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameInfo_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gamename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gameversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) {
    delete timestamp_;
  }
  timestamp_ = NULL;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameInfo::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameInfo*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.UTCTime timeStamp = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::UTCTime::_InternalParse;
        object = msg->mutable_timestamp();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // string mapName = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameInfo.mapName");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_mapname();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // string gameName = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameInfo.gameName");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_gamename();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // string gameVersion = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameInfo.gameVersion");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_gameversion();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.UTCTime timeStamp = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_timestamp()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string mapName = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mapname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->mapname().data(), static_cast<int>(this->mapname().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameInfo.mapName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string gameName = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gamename()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->gamename().data(), static_cast<int>(this->gamename().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameInfo.gameName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string gameVersion = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gameversion()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->gameversion().data(), static_cast<int>(this->gameversion().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameInfo.gameVersion"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.UTCTime timeStamp = 1;
  if (this->has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::timestamp(this), output);
  }

  // string mapName = 2;
  if (this->mapname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->mapname().data(), static_cast<int>(this->mapname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameInfo.mapName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->mapname(), output);
  }

  // string gameName = 3;
  if (this->gamename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->gamename().data(), static_cast<int>(this->gamename().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameInfo.gameName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->gamename(), output);
  }

  // string gameVersion = 4;
  if (this->gameversion().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->gameversion().data(), static_cast<int>(this->gameversion().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameInfo.gameVersion");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->gameversion(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameInfo)
}

::google::protobuf::uint8* GameInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.UTCTime timeStamp = 1;
  if (this->has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::timestamp(this), deterministic, target);
  }

  // string mapName = 2;
  if (this->mapname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->mapname().data(), static_cast<int>(this->mapname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameInfo.mapName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->mapname(), target);
  }

  // string gameName = 3;
  if (this->gamename().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->gamename().data(), static_cast<int>(this->gamename().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameInfo.gameName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->gamename(), target);
  }

  // string gameVersion = 4;
  if (this->gameversion().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->gameversion().data(), static_cast<int>(this->gameversion().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameInfo.gameVersion");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->gameversion(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameInfo)
  return target;
}

size_t GameInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mapName = 2;
  if (this->mapname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->mapname());
  }

  // string gameName = 3;
  if (this->gamename().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->gamename());
  }

  // string gameVersion = 4;
  if (this->gameversion().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->gameversion());
  }

  // .Analytics.UTCTime timeStamp = 1;
  if (this->has_timestamp()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *timestamp_);
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const GameInfo* source =
      ::google::protobuf::DynamicCastToGenerated<GameInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameInfo)
    MergeFrom(*source);
  }
}

void GameInfo::MergeFrom(const GameInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.mapname().size() > 0) {

    mapname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mapname_);
  }
  if (from.gamename().size() > 0) {

    gamename_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gamename_);
  }
  if (from.gameversion().size() > 0) {

    gameversion_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gameversion_);
  }
  if (from.has_timestamp()) {
    mutable_timestamp()->::Analytics::UTCTime::MergeFrom(from.timestamp());
  }
}

void GameInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameInfo::CopyFrom(const GameInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameInfo::IsInitialized() const {
  return true;
}

void GameInfo::Swap(GameInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameInfo::InternalSwap(GameInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  mapname_.Swap(&other->mapname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  gamename_.Swap(&other->gamename_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  gameversion_.Swap(&other->gameversion_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(timestamp_, other->timestamp_);
}

::google::protobuf::Metadata GameInfo::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameEnum_EnumPair::InitAsDefaultInstance() {
}
class GameEnum_EnumPair::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameEnum_EnumPair::kNameFieldNumber;
const int GameEnum_EnumPair::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameEnum_EnumPair::GameEnum_EnumPair()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameEnum.EnumPair)
}
GameEnum_EnumPair::GameEnum_EnumPair(const GameEnum_EnumPair& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.name().size() > 0) {
    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:Analytics.GameEnum.EnumPair)
}

void GameEnum_EnumPair::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameEnum_EnumPair_analytics_2eproto.base);
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = PROTOBUF_LONGLONG(0);
}

GameEnum_EnumPair::~GameEnum_EnumPair() {
  // @@protoc_insertion_point(destructor:Analytics.GameEnum.EnumPair)
  SharedDtor();
}

void GameEnum_EnumPair::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void GameEnum_EnumPair::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameEnum_EnumPair& GameEnum_EnumPair::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameEnum_EnumPair_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameEnum_EnumPair::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameEnum.EnumPair)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = PROTOBUF_LONGLONG(0);
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameEnum_EnumPair::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameEnum_EnumPair*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string name = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameEnum.EnumPair.name");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_name();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // int64 value = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int64 value = val;
        msg->set_value(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameEnum_EnumPair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameEnum.EnumPair)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string name = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->name().data(), static_cast<int>(this->name().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameEnum.EnumPair.name"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 value = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &value_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameEnum.EnumPair)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameEnum.EnumPair)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameEnum_EnumPair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameEnum.EnumPair)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameEnum.EnumPair.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // int64 value = 2;
  if (this->value() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameEnum.EnumPair)
}

::google::protobuf::uint8* GameEnum_EnumPair::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameEnum.EnumPair)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->name().data(), static_cast<int>(this->name().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameEnum.EnumPair.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // int64 value = 2;
  if (this->value() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameEnum.EnumPair)
  return target;
}

size_t GameEnum_EnumPair::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameEnum.EnumPair)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (this->name().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  // int64 value = 2;
  if (this->value() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->value());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameEnum_EnumPair::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameEnum.EnumPair)
  GOOGLE_DCHECK_NE(&from, this);
  const GameEnum_EnumPair* source =
      ::google::protobuf::DynamicCastToGenerated<GameEnum_EnumPair>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameEnum.EnumPair)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameEnum.EnumPair)
    MergeFrom(*source);
  }
}

void GameEnum_EnumPair::MergeFrom(const GameEnum_EnumPair& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameEnum.EnumPair)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.name().size() > 0) {

    name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.value() != 0) {
    set_value(from.value());
  }
}

void GameEnum_EnumPair::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameEnum.EnumPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameEnum_EnumPair::CopyFrom(const GameEnum_EnumPair& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameEnum.EnumPair)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameEnum_EnumPair::IsInitialized() const {
  return true;
}

void GameEnum_EnumPair::Swap(GameEnum_EnumPair* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameEnum_EnumPair::InternalSwap(GameEnum_EnumPair* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  name_.Swap(&other->name_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(value_, other->value_);
}

::google::protobuf::Metadata GameEnum_EnumPair::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameEnum::InitAsDefaultInstance() {
}
class GameEnum::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameEnum::kValuesFieldNumber;
const int GameEnum::kEnumnameFieldNumber;
const int GameEnum::kIsbitfieldFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameEnum::GameEnum()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameEnum)
}
GameEnum::GameEnum(const GameEnum& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      values_(from.values_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  enumname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.enumname().size() > 0) {
    enumname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.enumname_);
  }
  isbitfield_ = from.isbitfield_;
  // @@protoc_insertion_point(copy_constructor:Analytics.GameEnum)
}

void GameEnum::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameEnum_analytics_2eproto.base);
  enumname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  isbitfield_ = false;
}

GameEnum::~GameEnum() {
  // @@protoc_insertion_point(destructor:Analytics.GameEnum)
  SharedDtor();
}

void GameEnum::SharedDtor() {
  enumname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void GameEnum::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameEnum& GameEnum::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameEnum_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameEnum::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameEnum)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  enumname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  isbitfield_ = false;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameEnum::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameEnum*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // repeated .Analytics.GameEnum.EnumPair values = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        do {
          ptr = Varint::Parse32Inline(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::Analytics::GameEnum_EnumPair::_InternalParse;
          object = msg->add_values();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          bool ok = ctx->ParseExactRange({parser_till_end, object},
                                         ptr, newend);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          ptr = newend;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 255) == 10 && (ptr += 1));
        break;
      }
      // string enumname = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameEnum.enumname");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_enumname();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // bool isbitfield = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_isbitfield(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameEnum::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameEnum)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Analytics.GameEnum.EnumPair values = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_values()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string enumname = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_enumname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->enumname().data(), static_cast<int>(this->enumname().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameEnum.enumname"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool isbitfield = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isbitfield_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameEnum)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameEnum)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameEnum::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameEnum)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Analytics.GameEnum.EnumPair values = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->values_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->values(static_cast<int>(i)),
      output);
  }

  // string enumname = 2;
  if (this->enumname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->enumname().data(), static_cast<int>(this->enumname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameEnum.enumname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->enumname(), output);
  }

  // bool isbitfield = 3;
  if (this->isbitfield() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->isbitfield(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameEnum)
}

::google::protobuf::uint8* GameEnum::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameEnum)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Analytics.GameEnum.EnumPair values = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->values_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->values(static_cast<int>(i)), deterministic, target);
  }

  // string enumname = 2;
  if (this->enumname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->enumname().data(), static_cast<int>(this->enumname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameEnum.enumname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->enumname(), target);
  }

  // bool isbitfield = 3;
  if (this->isbitfield() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->isbitfield(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameEnum)
  return target;
}

size_t GameEnum::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameEnum)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Analytics.GameEnum.EnumPair values = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->values_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->values(static_cast<int>(i)));
    }
  }

  // string enumname = 2;
  if (this->enumname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->enumname());
  }

  // bool isbitfield = 3;
  if (this->isbitfield() != 0) {
    total_size += 1 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameEnum::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameEnum)
  GOOGLE_DCHECK_NE(&from, this);
  const GameEnum* source =
      ::google::protobuf::DynamicCastToGenerated<GameEnum>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameEnum)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameEnum)
    MergeFrom(*source);
  }
}

void GameEnum::MergeFrom(const GameEnum& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameEnum)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  if (from.enumname().size() > 0) {

    enumname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.enumname_);
  }
  if (from.isbitfield() != 0) {
    set_isbitfield(from.isbitfield());
  }
}

void GameEnum::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameEnum::CopyFrom(const GameEnum& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameEnum)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameEnum::IsInitialized() const {
  return true;
}

void GameEnum::Swap(GameEnum* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameEnum::InternalSwap(GameEnum* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&values_)->InternalSwap(CastToBase(&other->values_));
  enumname_.Swap(&other->enumname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(isbitfield_, other->isbitfield_);
}

::google::protobuf::Metadata GameEnum::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameNavNotFound::InitAsDefaultInstance() {
}
class GameNavNotFound::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameNavNotFound::kMapNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameNavNotFound::GameNavNotFound()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameNavNotFound)
}
GameNavNotFound::GameNavNotFound(const GameNavNotFound& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  mapname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.mapname().size() > 0) {
    mapname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mapname_);
  }
  // @@protoc_insertion_point(copy_constructor:Analytics.GameNavNotFound)
}

void GameNavNotFound::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameNavNotFound_analytics_2eproto.base);
  mapname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

GameNavNotFound::~GameNavNotFound() {
  // @@protoc_insertion_point(destructor:Analytics.GameNavNotFound)
  SharedDtor();
}

void GameNavNotFound::SharedDtor() {
  mapname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void GameNavNotFound::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameNavNotFound& GameNavNotFound::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameNavNotFound_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameNavNotFound::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameNavNotFound)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameNavNotFound::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameNavNotFound*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string mapName = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameNavNotFound.mapName");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_mapname();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameNavNotFound::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameNavNotFound)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string mapName = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mapname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->mapname().data(), static_cast<int>(this->mapname().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameNavNotFound.mapName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameNavNotFound)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameNavNotFound)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameNavNotFound::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameNavNotFound)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string mapName = 1;
  if (this->mapname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->mapname().data(), static_cast<int>(this->mapname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNavNotFound.mapName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->mapname(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameNavNotFound)
}

::google::protobuf::uint8* GameNavNotFound::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameNavNotFound)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string mapName = 1;
  if (this->mapname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->mapname().data(), static_cast<int>(this->mapname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNavNotFound.mapName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mapname(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameNavNotFound)
  return target;
}

size_t GameNavNotFound::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameNavNotFound)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mapName = 1;
  if (this->mapname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->mapname());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameNavNotFound::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameNavNotFound)
  GOOGLE_DCHECK_NE(&from, this);
  const GameNavNotFound* source =
      ::google::protobuf::DynamicCastToGenerated<GameNavNotFound>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameNavNotFound)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameNavNotFound)
    MergeFrom(*source);
  }
}

void GameNavNotFound::MergeFrom(const GameNavNotFound& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameNavNotFound)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.mapname().size() > 0) {

    mapname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mapname_);
  }
}

void GameNavNotFound::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameNavNotFound)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameNavNotFound::CopyFrom(const GameNavNotFound& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameNavNotFound)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameNavNotFound::IsInitialized() const {
  return true;
}

void GameNavNotFound::Swap(GameNavNotFound* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameNavNotFound::InternalSwap(GameNavNotFound* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  mapname_.Swap(&other->mapname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata GameNavNotFound::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameNavAutoDownloaded::InitAsDefaultInstance() {
}
class GameNavAutoDownloaded::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameNavAutoDownloaded::kMapNameFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameNavAutoDownloaded::GameNavAutoDownloaded()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameNavAutoDownloaded)
}
GameNavAutoDownloaded::GameNavAutoDownloaded(const GameNavAutoDownloaded& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  mapname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.mapname().size() > 0) {
    mapname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mapname_);
  }
  // @@protoc_insertion_point(copy_constructor:Analytics.GameNavAutoDownloaded)
}

void GameNavAutoDownloaded::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameNavAutoDownloaded_analytics_2eproto.base);
  mapname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

GameNavAutoDownloaded::~GameNavAutoDownloaded() {
  // @@protoc_insertion_point(destructor:Analytics.GameNavAutoDownloaded)
  SharedDtor();
}

void GameNavAutoDownloaded::SharedDtor() {
  mapname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void GameNavAutoDownloaded::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameNavAutoDownloaded& GameNavAutoDownloaded::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameNavAutoDownloaded_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameNavAutoDownloaded::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameNavAutoDownloaded)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameNavAutoDownloaded::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameNavAutoDownloaded*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string mapName = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameNavAutoDownloaded.mapName");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_mapname();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameNavAutoDownloaded::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameNavAutoDownloaded)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string mapName = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_mapname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->mapname().data(), static_cast<int>(this->mapname().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameNavAutoDownloaded.mapName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameNavAutoDownloaded)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameNavAutoDownloaded)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameNavAutoDownloaded::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameNavAutoDownloaded)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string mapName = 1;
  if (this->mapname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->mapname().data(), static_cast<int>(this->mapname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNavAutoDownloaded.mapName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->mapname(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameNavAutoDownloaded)
}

::google::protobuf::uint8* GameNavAutoDownloaded::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameNavAutoDownloaded)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string mapName = 1;
  if (this->mapname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->mapname().data(), static_cast<int>(this->mapname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNavAutoDownloaded.mapName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->mapname(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameNavAutoDownloaded)
  return target;
}

size_t GameNavAutoDownloaded::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameNavAutoDownloaded)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string mapName = 1;
  if (this->mapname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->mapname());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameNavAutoDownloaded::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameNavAutoDownloaded)
  GOOGLE_DCHECK_NE(&from, this);
  const GameNavAutoDownloaded* source =
      ::google::protobuf::DynamicCastToGenerated<GameNavAutoDownloaded>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameNavAutoDownloaded)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameNavAutoDownloaded)
    MergeFrom(*source);
  }
}

void GameNavAutoDownloaded::MergeFrom(const GameNavAutoDownloaded& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameNavAutoDownloaded)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.mapname().size() > 0) {

    mapname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.mapname_);
  }
}

void GameNavAutoDownloaded::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameNavAutoDownloaded)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameNavAutoDownloaded::CopyFrom(const GameNavAutoDownloaded& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameNavAutoDownloaded)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameNavAutoDownloaded::IsInitialized() const {
  return true;
}

void GameNavAutoDownloaded::Swap(GameNavAutoDownloaded* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameNavAutoDownloaded::InternalSwap(GameNavAutoDownloaded* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  mapname_.Swap(&other->mapname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata GameNavAutoDownloaded::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameAssert::InitAsDefaultInstance() {
}
class GameAssert::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameAssert::kConditionFieldNumber;
const int GameAssert::kFileFieldNumber;
const int GameAssert::kLineFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameAssert::GameAssert()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameAssert)
}
GameAssert::GameAssert(const GameAssert& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  condition_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.condition().size() > 0) {
    condition_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.condition_);
  }
  file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.file().size() > 0) {
    file_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.file_);
  }
  line_ = from.line_;
  // @@protoc_insertion_point(copy_constructor:Analytics.GameAssert)
}

void GameAssert::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameAssert_analytics_2eproto.base);
  condition_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  line_ = 0;
}

GameAssert::~GameAssert() {
  // @@protoc_insertion_point(destructor:Analytics.GameAssert)
  SharedDtor();
}

void GameAssert::SharedDtor() {
  condition_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void GameAssert::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameAssert& GameAssert::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameAssert_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameAssert::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameAssert)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  condition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  line_ = 0;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameAssert::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameAssert*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string condition = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameAssert.condition");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_condition();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // string file = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameAssert.file");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_file();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // int32 line = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_line(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameAssert::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameAssert)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string condition = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_condition()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->condition().data(), static_cast<int>(this->condition().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameAssert.condition"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string file = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->file().data(), static_cast<int>(this->file().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameAssert.file"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 line = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &line_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameAssert)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameAssert)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameAssert::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameAssert)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string condition = 1;
  if (this->condition().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->condition().data(), static_cast<int>(this->condition().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameAssert.condition");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->condition(), output);
  }

  // string file = 2;
  if (this->file().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->file().data(), static_cast<int>(this->file().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameAssert.file");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->file(), output);
  }

  // int32 line = 3;
  if (this->line() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->line(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameAssert)
}

::google::protobuf::uint8* GameAssert::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameAssert)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string condition = 1;
  if (this->condition().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->condition().data(), static_cast<int>(this->condition().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameAssert.condition");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->condition(), target);
  }

  // string file = 2;
  if (this->file().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->file().data(), static_cast<int>(this->file().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameAssert.file");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->file(), target);
  }

  // int32 line = 3;
  if (this->line() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->line(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameAssert)
  return target;
}

size_t GameAssert::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameAssert)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string condition = 1;
  if (this->condition().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->condition());
  }

  // string file = 2;
  if (this->file().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->file());
  }

  // int32 line = 3;
  if (this->line() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->line());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameAssert::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameAssert)
  GOOGLE_DCHECK_NE(&from, this);
  const GameAssert* source =
      ::google::protobuf::DynamicCastToGenerated<GameAssert>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameAssert)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameAssert)
    MergeFrom(*source);
  }
}

void GameAssert::MergeFrom(const GameAssert& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameAssert)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.condition().size() > 0) {

    condition_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.condition_);
  }
  if (from.file().size() > 0) {

    file_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.file_);
  }
  if (from.line() != 0) {
    set_line(from.line());
  }
}

void GameAssert::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameAssert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameAssert::CopyFrom(const GameAssert& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameAssert)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameAssert::IsInitialized() const {
  return true;
}

void GameAssert::Swap(GameAssert* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameAssert::InternalSwap(GameAssert* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  condition_.Swap(&other->condition_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  file_.Swap(&other->file_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(line_, other->line_);
}

::google::protobuf::Metadata GameAssert::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameCrash::InitAsDefaultInstance() {
}
class GameCrash::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameCrash::kInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameCrash::GameCrash()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameCrash)
}
GameCrash::GameCrash(const GameCrash& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.info().size() > 0) {
    info_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.info_);
  }
  // @@protoc_insertion_point(copy_constructor:Analytics.GameCrash)
}

void GameCrash::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameCrash_analytics_2eproto.base);
  info_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

GameCrash::~GameCrash() {
  // @@protoc_insertion_point(destructor:Analytics.GameCrash)
  SharedDtor();
}

void GameCrash::SharedDtor() {
  info_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void GameCrash::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameCrash& GameCrash::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameCrash_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameCrash::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameCrash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameCrash::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameCrash*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string info = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameCrash.info");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_info();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameCrash::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameCrash)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string info = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_info()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->info().data(), static_cast<int>(this->info().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameCrash.info"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameCrash)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameCrash)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameCrash::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameCrash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string info = 1;
  if (this->info().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->info().data(), static_cast<int>(this->info().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameCrash.info");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->info(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameCrash)
}

::google::protobuf::uint8* GameCrash::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameCrash)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string info = 1;
  if (this->info().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->info().data(), static_cast<int>(this->info().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameCrash.info");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->info(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameCrash)
  return target;
}

size_t GameCrash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameCrash)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string info = 1;
  if (this->info().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->info());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameCrash::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameCrash)
  GOOGLE_DCHECK_NE(&from, this);
  const GameCrash* source =
      ::google::protobuf::DynamicCastToGenerated<GameCrash>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameCrash)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameCrash)
    MergeFrom(*source);
  }
}

void GameCrash::MergeFrom(const GameCrash& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameCrash)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.info().size() > 0) {

    info_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.info_);
  }
}

void GameCrash::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameCrash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameCrash::CopyFrom(const GameCrash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameCrash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameCrash::IsInitialized() const {
  return true;
}

void GameCrash::Swap(GameCrash* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameCrash::InternalSwap(GameCrash* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  info_.Swap(&other->info_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::google::protobuf::Metadata GameCrash::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameMeshData::InitAsDefaultInstance() {
}
class GameMeshData::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameMeshData::kCompressionTypeFieldNumber;
const int GameMeshData::kModelNameFieldNumber;
const int GameMeshData::kModelBytesFieldNumber;
const int GameMeshData::kModelBytesUncompressedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameMeshData::GameMeshData()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameMeshData)
}
GameMeshData::GameMeshData(const GameMeshData& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  modelname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.modelname().size() > 0) {
    modelname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.modelname_);
  }
  modelbytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.modelbytes().size() > 0) {
    modelbytes_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.modelbytes_);
  }
  ::memcpy(&compressiontype_, &from.compressiontype_,
    static_cast<size_t>(reinterpret_cast<char*>(&modelbytesuncompressed_) -
    reinterpret_cast<char*>(&compressiontype_)) + sizeof(modelbytesuncompressed_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameMeshData)
}

void GameMeshData::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameMeshData_analytics_2eproto.base);
  modelname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  modelbytes_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&compressiontype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&modelbytesuncompressed_) -
      reinterpret_cast<char*>(&compressiontype_)) + sizeof(modelbytesuncompressed_));
}

GameMeshData::~GameMeshData() {
  // @@protoc_insertion_point(destructor:Analytics.GameMeshData)
  SharedDtor();
}

void GameMeshData::SharedDtor() {
  modelname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  modelbytes_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void GameMeshData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameMeshData& GameMeshData::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameMeshData_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameMeshData::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameMeshData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  modelname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  modelbytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&compressiontype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&modelbytesuncompressed_) -
      reinterpret_cast<char*>(&compressiontype_)) + sizeof(modelbytesuncompressed_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameMeshData::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameMeshData*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.Compression compressionType = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::Analytics::Compression value = static_cast<::Analytics::Compression>(val);
        msg->set_compressiontype(value);
        break;
      }
      // string modelName = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameMeshData.modelName");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_modelname();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // bytes modelBytes = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::google::protobuf::internal::StringParser;
        ::std::string* str = msg->mutable_modelbytes();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        str->append(ptr, size);
        ptr += size;
        break;
      }
      // uint32 modelBytesUncompressed = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_modelbytesuncompressed(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameMeshData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameMeshData)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.Compression compressionType = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_compressiontype(static_cast< ::Analytics::Compression >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string modelName = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_modelname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->modelname().data(), static_cast<int>(this->modelname().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameMeshData.modelName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bytes modelBytes = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_modelbytes()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 modelBytesUncompressed = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &modelbytesuncompressed_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameMeshData)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameMeshData)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameMeshData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameMeshData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Compression compressionType = 1;
  if (this->compressiontype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->compressiontype(), output);
  }

  // string modelName = 2;
  if (this->modelname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->modelname().data(), static_cast<int>(this->modelname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameMeshData.modelName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->modelname(), output);
  }

  // bytes modelBytes = 3;
  if (this->modelbytes().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->modelbytes(), output);
  }

  // uint32 modelBytesUncompressed = 4;
  if (this->modelbytesuncompressed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->modelbytesuncompressed(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameMeshData)
}

::google::protobuf::uint8* GameMeshData::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameMeshData)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Compression compressionType = 1;
  if (this->compressiontype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->compressiontype(), target);
  }

  // string modelName = 2;
  if (this->modelname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->modelname().data(), static_cast<int>(this->modelname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameMeshData.modelName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->modelname(), target);
  }

  // bytes modelBytes = 3;
  if (this->modelbytes().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->modelbytes(), target);
  }

  // uint32 modelBytesUncompressed = 4;
  if (this->modelbytesuncompressed() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->modelbytesuncompressed(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameMeshData)
  return target;
}

size_t GameMeshData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameMeshData)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string modelName = 2;
  if (this->modelname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->modelname());
  }

  // bytes modelBytes = 3;
  if (this->modelbytes().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->modelbytes());
  }

  // .Analytics.Compression compressionType = 1;
  if (this->compressiontype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->compressiontype());
  }

  // uint32 modelBytesUncompressed = 4;
  if (this->modelbytesuncompressed() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->modelbytesuncompressed());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameMeshData::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameMeshData)
  GOOGLE_DCHECK_NE(&from, this);
  const GameMeshData* source =
      ::google::protobuf::DynamicCastToGenerated<GameMeshData>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameMeshData)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameMeshData)
    MergeFrom(*source);
  }
}

void GameMeshData::MergeFrom(const GameMeshData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameMeshData)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.modelname().size() > 0) {

    modelname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.modelname_);
  }
  if (from.modelbytes().size() > 0) {

    modelbytes_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.modelbytes_);
  }
  if (from.compressiontype() != 0) {
    set_compressiontype(from.compressiontype());
  }
  if (from.modelbytesuncompressed() != 0) {
    set_modelbytesuncompressed(from.modelbytesuncompressed());
  }
}

void GameMeshData::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameMeshData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameMeshData::CopyFrom(const GameMeshData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameMeshData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameMeshData::IsInitialized() const {
  return true;
}

void GameMeshData::Swap(GameMeshData* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameMeshData::InternalSwap(GameMeshData* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  modelname_.Swap(&other->modelname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  modelbytes_.Swap(&other->modelbytes_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(compressiontype_, other->compressiontype_);
  swap(modelbytesuncompressed_, other->modelbytesuncompressed_);
}

::google::protobuf::Metadata GameMeshData::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameEntityInfo_Ammo::InitAsDefaultInstance() {
}
class GameEntityInfo_Ammo::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameEntityInfo_Ammo::kAmmoTypeFieldNumber;
const int GameEntityInfo_Ammo::kAmmoCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameEntityInfo_Ammo::GameEntityInfo_Ammo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameEntityInfo.Ammo)
}
GameEntityInfo_Ammo::GameEntityInfo_Ammo(const GameEntityInfo_Ammo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&ammotype_, &from.ammotype_,
    static_cast<size_t>(reinterpret_cast<char*>(&ammocount_) -
    reinterpret_cast<char*>(&ammotype_)) + sizeof(ammocount_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameEntityInfo.Ammo)
}

void GameEntityInfo_Ammo::SharedCtor() {
  ::memset(&ammotype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ammocount_) -
      reinterpret_cast<char*>(&ammotype_)) + sizeof(ammocount_));
}

GameEntityInfo_Ammo::~GameEntityInfo_Ammo() {
  // @@protoc_insertion_point(destructor:Analytics.GameEntityInfo.Ammo)
  SharedDtor();
}

void GameEntityInfo_Ammo::SharedDtor() {
}

void GameEntityInfo_Ammo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameEntityInfo_Ammo& GameEntityInfo_Ammo::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameEntityInfo_Ammo_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameEntityInfo_Ammo::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameEntityInfo.Ammo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&ammotype_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ammocount_) -
      reinterpret_cast<char*>(&ammotype_)) + sizeof(ammocount_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameEntityInfo_Ammo::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameEntityInfo_Ammo*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // uint32 ammoType = 1 [(.Analytics.enumkey) = "AMMO_TYPE"];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_ammotype(value);
        break;
      }
      // uint32 ammoCount = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::uint32 value = val;
        msg->set_ammocount(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameEntityInfo_Ammo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameEntityInfo.Ammo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // uint32 ammoType = 1 [(.Analytics.enumkey) = "AMMO_TYPE"];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ammotype_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // uint32 ammoCount = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ammocount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameEntityInfo.Ammo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameEntityInfo.Ammo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameEntityInfo_Ammo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameEntityInfo.Ammo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 ammoType = 1 [(.Analytics.enumkey) = "AMMO_TYPE"];
  if (this->ammotype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->ammotype(), output);
  }

  // uint32 ammoCount = 2;
  if (this->ammocount() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ammocount(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameEntityInfo.Ammo)
}

::google::protobuf::uint8* GameEntityInfo_Ammo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameEntityInfo.Ammo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 ammoType = 1 [(.Analytics.enumkey) = "AMMO_TYPE"];
  if (this->ammotype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->ammotype(), target);
  }

  // uint32 ammoCount = 2;
  if (this->ammocount() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ammocount(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameEntityInfo.Ammo)
  return target;
}

size_t GameEntityInfo_Ammo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameEntityInfo.Ammo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 ammoType = 1 [(.Analytics.enumkey) = "AMMO_TYPE"];
  if (this->ammotype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ammotype());
  }

  // uint32 ammoCount = 2;
  if (this->ammocount() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ammocount());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameEntityInfo_Ammo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameEntityInfo.Ammo)
  GOOGLE_DCHECK_NE(&from, this);
  const GameEntityInfo_Ammo* source =
      ::google::protobuf::DynamicCastToGenerated<GameEntityInfo_Ammo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameEntityInfo.Ammo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameEntityInfo.Ammo)
    MergeFrom(*source);
  }
}

void GameEntityInfo_Ammo::MergeFrom(const GameEntityInfo_Ammo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameEntityInfo.Ammo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.ammotype() != 0) {
    set_ammotype(from.ammotype());
  }
  if (from.ammocount() != 0) {
    set_ammocount(from.ammocount());
  }
}

void GameEntityInfo_Ammo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameEntityInfo.Ammo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameEntityInfo_Ammo::CopyFrom(const GameEntityInfo_Ammo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameEntityInfo.Ammo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameEntityInfo_Ammo::IsInitialized() const {
  return true;
}

void GameEntityInfo_Ammo::Swap(GameEntityInfo_Ammo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameEntityInfo_Ammo::InternalSwap(GameEntityInfo_Ammo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(ammotype_, other->ammotype_);
  swap(ammocount_, other->ammocount_);
}

::google::protobuf::Metadata GameEntityInfo_Ammo::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameEntityInfo::InitAsDefaultInstance() {
  ::Analytics::_GameEntityInfo_default_instance_._instance.get_mutable()->eulerrotation_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
  ::Analytics::_GameEntityInfo_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
  ::Analytics::_GameEntityInfo_default_instance_._instance.get_mutable()->eyeoffset_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
  ::Analytics::_GameEntityInfo_default_instance_._instance.get_mutable()->eyedir_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
  ::Analytics::_GameEntityInfo_default_instance_._instance.get_mutable()->health_ = const_cast< ::Analytics::RangeI*>(
      ::Analytics::RangeI::internal_default_instance());
  ::Analytics::_GameEntityInfo_default_instance_._instance.get_mutable()->armor_ = const_cast< ::Analytics::RangeI*>(
      ::Analytics::RangeI::internal_default_instance());
  ::Analytics::_GameEntityInfo_default_instance_._instance.get_mutable()->boundsmin_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
  ::Analytics::_GameEntityInfo_default_instance_._instance.get_mutable()->boundsmax_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameEntityInfo::HasBitSetters {
 public:
  static const ::Analytics::Vec3& eulerrotation(const GameEntityInfo* msg);
  static const ::Analytics::Vec3& position(const GameEntityInfo* msg);
  static const ::Analytics::Vec3& eyeoffset(const GameEntityInfo* msg);
  static const ::Analytics::Vec3& eyedir(const GameEntityInfo* msg);
  static const ::Analytics::RangeI& health(const GameEntityInfo* msg);
  static const ::Analytics::RangeI& armor(const GameEntityInfo* msg);
  static const ::Analytics::Vec3& boundsmin(const GameEntityInfo* msg);
  static const ::Analytics::Vec3& boundsmax(const GameEntityInfo* msg);
};

const ::Analytics::Vec3&
GameEntityInfo::HasBitSetters::eulerrotation(const GameEntityInfo* msg) {
  return *msg->eulerrotation_;
}
const ::Analytics::Vec3&
GameEntityInfo::HasBitSetters::position(const GameEntityInfo* msg) {
  return *msg->position_;
}
const ::Analytics::Vec3&
GameEntityInfo::HasBitSetters::eyeoffset(const GameEntityInfo* msg) {
  return *msg->eyeoffset_;
}
const ::Analytics::Vec3&
GameEntityInfo::HasBitSetters::eyedir(const GameEntityInfo* msg) {
  return *msg->eyedir_;
}
const ::Analytics::RangeI&
GameEntityInfo::HasBitSetters::health(const GameEntityInfo* msg) {
  return *msg->health_;
}
const ::Analytics::RangeI&
GameEntityInfo::HasBitSetters::armor(const GameEntityInfo* msg) {
  return *msg->armor_;
}
const ::Analytics::Vec3&
GameEntityInfo::HasBitSetters::boundsmin(const GameEntityInfo* msg) {
  return *msg->boundsmin_;
}
const ::Analytics::Vec3&
GameEntityInfo::HasBitSetters::boundsmax(const GameEntityInfo* msg) {
  return *msg->boundsmax_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameEntityInfo::kEntityNameFieldNumber;
const int GameEntityInfo::kEntityIndexFieldNumber;
const int GameEntityInfo::kEntitySerialFieldNumber;
const int GameEntityInfo::kGroupIdFieldNumber;
const int GameEntityInfo::kClassIdFieldNumber;
const int GameEntityInfo::kTeamFieldNumber;
const int GameEntityInfo::kEntityFlagsFieldNumber;
const int GameEntityInfo::kCategoryFieldNumber;
const int GameEntityInfo::kPowerUpsFieldNumber;
const int GameEntityInfo::kNavFlagsFieldNumber;
const int GameEntityInfo::kEulerRotationFieldNumber;
const int GameEntityInfo::kPositionFieldNumber;
const int GameEntityInfo::kEyeOffsetFieldNumber;
const int GameEntityInfo::kEyeDirFieldNumber;
const int GameEntityInfo::kHealthFieldNumber;
const int GameEntityInfo::kArmorFieldNumber;
const int GameEntityInfo::kBoundsMinFieldNumber;
const int GameEntityInfo::kBoundsMaxFieldNumber;
const int GameEntityInfo::kAmmoFieldNumber;
const int GameEntityInfo::kDeletedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameEntityInfo::GameEntityInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameEntityInfo)
}
GameEntityInfo::GameEntityInfo(const GameEntityInfo& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL),
      ammo_(from.ammo_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  entityname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.entityname().size() > 0) {
    entityname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entityname_);
  }
  if (from.has_eulerrotation()) {
    eulerrotation_ = new ::Analytics::Vec3(*from.eulerrotation_);
  } else {
    eulerrotation_ = NULL;
  }
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  if (from.has_eyeoffset()) {
    eyeoffset_ = new ::Analytics::Vec3(*from.eyeoffset_);
  } else {
    eyeoffset_ = NULL;
  }
  if (from.has_eyedir()) {
    eyedir_ = new ::Analytics::Vec3(*from.eyedir_);
  } else {
    eyedir_ = NULL;
  }
  if (from.has_health()) {
    health_ = new ::Analytics::RangeI(*from.health_);
  } else {
    health_ = NULL;
  }
  if (from.has_armor()) {
    armor_ = new ::Analytics::RangeI(*from.armor_);
  } else {
    armor_ = NULL;
  }
  if (from.has_boundsmin()) {
    boundsmin_ = new ::Analytics::Vec3(*from.boundsmin_);
  } else {
    boundsmin_ = NULL;
  }
  if (from.has_boundsmax()) {
    boundsmax_ = new ::Analytics::Vec3(*from.boundsmax_);
  } else {
    boundsmax_ = NULL;
  }
  ::memcpy(&entityindex_, &from.entityindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&deleted_) -
    reinterpret_cast<char*>(&entityindex_)) + sizeof(deleted_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameEntityInfo)
}

void GameEntityInfo::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameEntityInfo_analytics_2eproto.base);
  entityname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&eulerrotation_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&deleted_) -
      reinterpret_cast<char*>(&eulerrotation_)) + sizeof(deleted_));
}

GameEntityInfo::~GameEntityInfo() {
  // @@protoc_insertion_point(destructor:Analytics.GameEntityInfo)
  SharedDtor();
}

void GameEntityInfo::SharedDtor() {
  entityname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete eulerrotation_;
  if (this != internal_default_instance()) delete position_;
  if (this != internal_default_instance()) delete eyeoffset_;
  if (this != internal_default_instance()) delete eyedir_;
  if (this != internal_default_instance()) delete health_;
  if (this != internal_default_instance()) delete armor_;
  if (this != internal_default_instance()) delete boundsmin_;
  if (this != internal_default_instance()) delete boundsmax_;
}

void GameEntityInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameEntityInfo& GameEntityInfo::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameEntityInfo_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameEntityInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameEntityInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ammo_.Clear();
  entityname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && eulerrotation_ != NULL) {
    delete eulerrotation_;
  }
  eulerrotation_ = NULL;
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  if (GetArenaNoVirtual() == NULL && eyeoffset_ != NULL) {
    delete eyeoffset_;
  }
  eyeoffset_ = NULL;
  if (GetArenaNoVirtual() == NULL && eyedir_ != NULL) {
    delete eyedir_;
  }
  eyedir_ = NULL;
  if (GetArenaNoVirtual() == NULL && health_ != NULL) {
    delete health_;
  }
  health_ = NULL;
  if (GetArenaNoVirtual() == NULL && armor_ != NULL) {
    delete armor_;
  }
  armor_ = NULL;
  if (GetArenaNoVirtual() == NULL && boundsmin_ != NULL) {
    delete boundsmin_;
  }
  boundsmin_ = NULL;
  if (GetArenaNoVirtual() == NULL && boundsmax_ != NULL) {
    delete boundsmax_;
  }
  boundsmax_ = NULL;
  ::memset(&entityindex_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&deleted_) -
      reinterpret_cast<char*>(&entityindex_)) + sizeof(deleted_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameEntityInfo::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameEntityInfo*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string entityName = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameEntityInfo.entityName");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_entityname();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // int32 entityIndex = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_entityindex(value);
        break;
      }
      // int32 entitySerial = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_entityserial(value);
        break;
      }
      // int32 groupId = 4 [(.Analytics.enumkey) = "GROUP_ID"];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_groupid(value);
        break;
      }
      // int32 classId = 5 [(.Analytics.enumkey) = "CLASS_ID"];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 40) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_classid(value);
        break;
      }
      // int32 team = 6 [(.Analytics.enumkey) = "TEAM_ID"];
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 48) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_team(value);
        break;
      }
      // int64 entityFlags = 7 [(.Analytics.enumkey) = "ENTITY_FLAGS", (.Analytics.enumflagsindexed) = true];
      case 7: {
        if (static_cast<::google::protobuf::uint8>(tag) != 56) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int64 value = val;
        msg->set_entityflags(value);
        break;
      }
      // int32 category = 8 [(.Analytics.enumkey) = "CATEGORY_ID", (.Analytics.enumflagsindexed) = true];
      case 8: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_category(value);
        break;
      }
      // int32 powerUps = 9 [(.Analytics.enumkey) = "POWERUP_ID", (.Analytics.enumflagsindexed) = true];
      case 9: {
        if (static_cast<::google::protobuf::uint8>(tag) != 72) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_powerups(value);
        break;
      }
      // int64 navFlags = 10 [(.Analytics.enumkey) = "NAV_FLAGS"];
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int64 value = val;
        msg->set_navflags(value);
        break;
      }
      // .Analytics.Vec3 eulerRotation = 11 [(.Analytics.hidden) = true];
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_eulerrotation();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // .Analytics.Vec3 position = 12 [(.Analytics.hidden) = true];
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 98) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // .Analytics.Vec3 eyeOffset = 13 [(.Analytics.hidden) = true];
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 106) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_eyeoffset();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // .Analytics.Vec3 eyeDir = 14 [(.Analytics.hidden) = true];
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 114) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_eyedir();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // .Analytics.RangeI health = 15;
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 122) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::RangeI::_InternalParse;
        object = msg->mutable_health();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // .Analytics.RangeI armor = 16;
      case 16: {
        if (static_cast<::google::protobuf::uint8>(tag) != 130) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::RangeI::_InternalParse;
        object = msg->mutable_armor();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // .Analytics.Vec3 boundsMin = 17;
      case 17: {
        if (static_cast<::google::protobuf::uint8>(tag) != 138) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_boundsmin();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // .Analytics.Vec3 boundsMax = 18;
      case 18: {
        if (static_cast<::google::protobuf::uint8>(tag) != 146) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_boundsmax();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // repeated .Analytics.GameEntityInfo.Ammo ammo = 19;
      case 19: {
        if (static_cast<::google::protobuf::uint8>(tag) != 154) goto handle_unusual;
        do {
          ptr = Varint::Parse32Inline(ptr, &size);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
          parser_till_end = ::Analytics::GameEntityInfo_Ammo::_InternalParse;
          object = msg->add_ammo();
          if (size > end - ptr) goto len_delim_till_end;
          auto newend = ptr + size;
          bool ok = ctx->ParseExactRange({parser_till_end, object},
                                         ptr, newend);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          ptr = newend;
          if (ptr >= end) break;
        } while ((::google::protobuf::io::UnalignedLoad<::google::protobuf::uint64>(ptr) & 65535) == 410 && (ptr += 2));
        break;
      }
      // bool deleted = 1000 [(.Analytics.hidden) = true];
      case 1000: {
        if (static_cast<::google::protobuf::uint8>(tag) != 64) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        bool value = val;
        msg->set_deleted(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameEntityInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameEntityInfo)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(16383u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string entityName = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_entityname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->entityname().data(), static_cast<int>(this->entityname().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameEntityInfo.entityName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 entityIndex = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &entityindex_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 entitySerial = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &entityserial_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 groupId = 4 [(.Analytics.enumkey) = "GROUP_ID"];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &groupid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 classId = 5 [(.Analytics.enumkey) = "CLASS_ID"];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (40 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &classid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 team = 6 [(.Analytics.enumkey) = "TEAM_ID"];
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (48 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &team_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 entityFlags = 7 [(.Analytics.enumkey) = "ENTITY_FLAGS", (.Analytics.enumflagsindexed) = true];
      case 7: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (56 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &entityflags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 category = 8 [(.Analytics.enumkey) = "CATEGORY_ID", (.Analytics.enumflagsindexed) = true];
      case 8: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (64 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &category_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 powerUps = 9 [(.Analytics.enumkey) = "POWERUP_ID", (.Analytics.enumflagsindexed) = true];
      case 9: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (72 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &powerups_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 navFlags = 10 [(.Analytics.enumkey) = "NAV_FLAGS"];
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &navflags_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 eulerRotation = 11 [(.Analytics.hidden) = true];
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_eulerrotation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 position = 12 [(.Analytics.hidden) = true];
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (98 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 eyeOffset = 13 [(.Analytics.hidden) = true];
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (106 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_eyeoffset()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 eyeDir = 14 [(.Analytics.hidden) = true];
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (114 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_eyedir()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.RangeI health = 15;
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (122 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_health()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.RangeI armor = 16;
      case 16: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (130 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_armor()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 boundsMin = 17;
      case 17: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (138 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_boundsmin()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 boundsMax = 18;
      case 18: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (146 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_boundsmax()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .Analytics.GameEntityInfo.Ammo ammo = 19;
      case 19: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (154 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
                input, add_ammo()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // bool deleted = 1000 [(.Analytics.hidden) = true];
      case 1000: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8000 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &deleted_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameEntityInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameEntityInfo)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameEntityInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameEntityInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string entityName = 1;
  if (this->entityname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->entityname().data(), static_cast<int>(this->entityname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameEntityInfo.entityName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->entityname(), output);
  }

  // int32 entityIndex = 2;
  if (this->entityindex() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->entityindex(), output);
  }

  // int32 entitySerial = 3;
  if (this->entityserial() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->entityserial(), output);
  }

  // int32 groupId = 4 [(.Analytics.enumkey) = "GROUP_ID"];
  if (this->groupid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->groupid(), output);
  }

  // int32 classId = 5 [(.Analytics.enumkey) = "CLASS_ID"];
  if (this->classid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->classid(), output);
  }

  // int32 team = 6 [(.Analytics.enumkey) = "TEAM_ID"];
  if (this->team() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->team(), output);
  }

  // int64 entityFlags = 7 [(.Analytics.enumkey) = "ENTITY_FLAGS", (.Analytics.enumflagsindexed) = true];
  if (this->entityflags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->entityflags(), output);
  }

  // int32 category = 8 [(.Analytics.enumkey) = "CATEGORY_ID", (.Analytics.enumflagsindexed) = true];
  if (this->category() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->category(), output);
  }

  // int32 powerUps = 9 [(.Analytics.enumkey) = "POWERUP_ID", (.Analytics.enumflagsindexed) = true];
  if (this->powerups() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->powerups(), output);
  }

  // int64 navFlags = 10 [(.Analytics.enumkey) = "NAV_FLAGS"];
  if (this->navflags() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->navflags(), output);
  }

  // .Analytics.Vec3 eulerRotation = 11 [(.Analytics.hidden) = true];
  if (this->has_eulerrotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, HasBitSetters::eulerrotation(this), output);
  }

  // .Analytics.Vec3 position = 12 [(.Analytics.hidden) = true];
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, HasBitSetters::position(this), output);
  }

  // .Analytics.Vec3 eyeOffset = 13 [(.Analytics.hidden) = true];
  if (this->has_eyeoffset()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, HasBitSetters::eyeoffset(this), output);
  }

  // .Analytics.Vec3 eyeDir = 14 [(.Analytics.hidden) = true];
  if (this->has_eyedir()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, HasBitSetters::eyedir(this), output);
  }

  // .Analytics.RangeI health = 15;
  if (this->has_health()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, HasBitSetters::health(this), output);
  }

  // .Analytics.RangeI armor = 16;
  if (this->has_armor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, HasBitSetters::armor(this), output);
  }

  // .Analytics.Vec3 boundsMin = 17;
  if (this->has_boundsmin()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      17, HasBitSetters::boundsmin(this), output);
  }

  // .Analytics.Vec3 boundsMax = 18;
  if (this->has_boundsmax()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      18, HasBitSetters::boundsmax(this), output);
  }

  // repeated .Analytics.GameEntityInfo.Ammo ammo = 19;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->ammo_size()); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      19,
      this->ammo(static_cast<int>(i)),
      output);
  }

  // bool deleted = 1000 [(.Analytics.hidden) = true];
  if (this->deleted() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1000, this->deleted(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameEntityInfo)
}

::google::protobuf::uint8* GameEntityInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameEntityInfo)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string entityName = 1;
  if (this->entityname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->entityname().data(), static_cast<int>(this->entityname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameEntityInfo.entityName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->entityname(), target);
  }

  // int32 entityIndex = 2;
  if (this->entityindex() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->entityindex(), target);
  }

  // int32 entitySerial = 3;
  if (this->entityserial() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->entityserial(), target);
  }

  // int32 groupId = 4 [(.Analytics.enumkey) = "GROUP_ID"];
  if (this->groupid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->groupid(), target);
  }

  // int32 classId = 5 [(.Analytics.enumkey) = "CLASS_ID"];
  if (this->classid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->classid(), target);
  }

  // int32 team = 6 [(.Analytics.enumkey) = "TEAM_ID"];
  if (this->team() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->team(), target);
  }

  // int64 entityFlags = 7 [(.Analytics.enumkey) = "ENTITY_FLAGS", (.Analytics.enumflagsindexed) = true];
  if (this->entityflags() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->entityflags(), target);
  }

  // int32 category = 8 [(.Analytics.enumkey) = "CATEGORY_ID", (.Analytics.enumflagsindexed) = true];
  if (this->category() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->category(), target);
  }

  // int32 powerUps = 9 [(.Analytics.enumkey) = "POWERUP_ID", (.Analytics.enumflagsindexed) = true];
  if (this->powerups() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(9, this->powerups(), target);
  }

  // int64 navFlags = 10 [(.Analytics.enumkey) = "NAV_FLAGS"];
  if (this->navflags() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->navflags(), target);
  }

  // .Analytics.Vec3 eulerRotation = 11 [(.Analytics.hidden) = true];
  if (this->has_eulerrotation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        11, HasBitSetters::eulerrotation(this), deterministic, target);
  }

  // .Analytics.Vec3 position = 12 [(.Analytics.hidden) = true];
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        12, HasBitSetters::position(this), deterministic, target);
  }

  // .Analytics.Vec3 eyeOffset = 13 [(.Analytics.hidden) = true];
  if (this->has_eyeoffset()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        13, HasBitSetters::eyeoffset(this), deterministic, target);
  }

  // .Analytics.Vec3 eyeDir = 14 [(.Analytics.hidden) = true];
  if (this->has_eyedir()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        14, HasBitSetters::eyedir(this), deterministic, target);
  }

  // .Analytics.RangeI health = 15;
  if (this->has_health()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        15, HasBitSetters::health(this), deterministic, target);
  }

  // .Analytics.RangeI armor = 16;
  if (this->has_armor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        16, HasBitSetters::armor(this), deterministic, target);
  }

  // .Analytics.Vec3 boundsMin = 17;
  if (this->has_boundsmin()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        17, HasBitSetters::boundsmin(this), deterministic, target);
  }

  // .Analytics.Vec3 boundsMax = 18;
  if (this->has_boundsmax()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        18, HasBitSetters::boundsmax(this), deterministic, target);
  }

  // repeated .Analytics.GameEntityInfo.Ammo ammo = 19;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->ammo_size()); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        19, this->ammo(static_cast<int>(i)), deterministic, target);
  }

  // bool deleted = 1000 [(.Analytics.hidden) = true];
  if (this->deleted() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1000, this->deleted(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameEntityInfo)
  return target;
}

size_t GameEntityInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameEntityInfo)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Analytics.GameEntityInfo.Ammo ammo = 19;
  {
    unsigned int count = static_cast<unsigned int>(this->ammo_size());
    total_size += 2UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::google::protobuf::internal::WireFormatLite::MessageSize(
          this->ammo(static_cast<int>(i)));
    }
  }

  // string entityName = 1;
  if (this->entityname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->entityname());
  }

  // .Analytics.Vec3 eulerRotation = 11 [(.Analytics.hidden) = true];
  if (this->has_eulerrotation()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *eulerrotation_);
  }

  // .Analytics.Vec3 position = 12 [(.Analytics.hidden) = true];
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // .Analytics.Vec3 eyeOffset = 13 [(.Analytics.hidden) = true];
  if (this->has_eyeoffset()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *eyeoffset_);
  }

  // .Analytics.Vec3 eyeDir = 14 [(.Analytics.hidden) = true];
  if (this->has_eyedir()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *eyedir_);
  }

  // .Analytics.RangeI health = 15;
  if (this->has_health()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *health_);
  }

  // .Analytics.RangeI armor = 16;
  if (this->has_armor()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *armor_);
  }

  // .Analytics.Vec3 boundsMin = 17;
  if (this->has_boundsmin()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *boundsmin_);
  }

  // .Analytics.Vec3 boundsMax = 18;
  if (this->has_boundsmax()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *boundsmax_);
  }

  // int32 entityIndex = 2;
  if (this->entityindex() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->entityindex());
  }

  // int32 entitySerial = 3;
  if (this->entityserial() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->entityserial());
  }

  // int32 groupId = 4 [(.Analytics.enumkey) = "GROUP_ID"];
  if (this->groupid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->groupid());
  }

  // int32 classId = 5 [(.Analytics.enumkey) = "CLASS_ID"];
  if (this->classid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->classid());
  }

  // int64 entityFlags = 7 [(.Analytics.enumkey) = "ENTITY_FLAGS", (.Analytics.enumflagsindexed) = true];
  if (this->entityflags() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->entityflags());
  }

  // int32 team = 6 [(.Analytics.enumkey) = "TEAM_ID"];
  if (this->team() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->team());
  }

  // int32 category = 8 [(.Analytics.enumkey) = "CATEGORY_ID", (.Analytics.enumflagsindexed) = true];
  if (this->category() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->category());
  }

  // int64 navFlags = 10 [(.Analytics.enumkey) = "NAV_FLAGS"];
  if (this->navflags() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->navflags());
  }

  // int32 powerUps = 9 [(.Analytics.enumkey) = "POWERUP_ID", (.Analytics.enumflagsindexed) = true];
  if (this->powerups() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->powerups());
  }

  // bool deleted = 1000 [(.Analytics.hidden) = true];
  if (this->deleted() != 0) {
    total_size += 2 + 1;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameEntityInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameEntityInfo)
  GOOGLE_DCHECK_NE(&from, this);
  const GameEntityInfo* source =
      ::google::protobuf::DynamicCastToGenerated<GameEntityInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameEntityInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameEntityInfo)
    MergeFrom(*source);
  }
}

void GameEntityInfo::MergeFrom(const GameEntityInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameEntityInfo)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  ammo_.MergeFrom(from.ammo_);
  if (from.entityname().size() > 0) {

    entityname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entityname_);
  }
  if (from.has_eulerrotation()) {
    mutable_eulerrotation()->::Analytics::Vec3::MergeFrom(from.eulerrotation());
  }
  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.has_eyeoffset()) {
    mutable_eyeoffset()->::Analytics::Vec3::MergeFrom(from.eyeoffset());
  }
  if (from.has_eyedir()) {
    mutable_eyedir()->::Analytics::Vec3::MergeFrom(from.eyedir());
  }
  if (from.has_health()) {
    mutable_health()->::Analytics::RangeI::MergeFrom(from.health());
  }
  if (from.has_armor()) {
    mutable_armor()->::Analytics::RangeI::MergeFrom(from.armor());
  }
  if (from.has_boundsmin()) {
    mutable_boundsmin()->::Analytics::Vec3::MergeFrom(from.boundsmin());
  }
  if (from.has_boundsmax()) {
    mutable_boundsmax()->::Analytics::Vec3::MergeFrom(from.boundsmax());
  }
  if (from.entityindex() != 0) {
    set_entityindex(from.entityindex());
  }
  if (from.entityserial() != 0) {
    set_entityserial(from.entityserial());
  }
  if (from.groupid() != 0) {
    set_groupid(from.groupid());
  }
  if (from.classid() != 0) {
    set_classid(from.classid());
  }
  if (from.entityflags() != 0) {
    set_entityflags(from.entityflags());
  }
  if (from.team() != 0) {
    set_team(from.team());
  }
  if (from.category() != 0) {
    set_category(from.category());
  }
  if (from.navflags() != 0) {
    set_navflags(from.navflags());
  }
  if (from.powerups() != 0) {
    set_powerups(from.powerups());
  }
  if (from.deleted() != 0) {
    set_deleted(from.deleted());
  }
}

void GameEntityInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameEntityInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameEntityInfo::CopyFrom(const GameEntityInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameEntityInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameEntityInfo::IsInitialized() const {
  return true;
}

void GameEntityInfo::Swap(GameEntityInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameEntityInfo::InternalSwap(GameEntityInfo* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  CastToBase(&ammo_)->InternalSwap(CastToBase(&other->ammo_));
  entityname_.Swap(&other->entityname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(eulerrotation_, other->eulerrotation_);
  swap(position_, other->position_);
  swap(eyeoffset_, other->eyeoffset_);
  swap(eyedir_, other->eyedir_);
  swap(health_, other->health_);
  swap(armor_, other->armor_);
  swap(boundsmin_, other->boundsmin_);
  swap(boundsmax_, other->boundsmax_);
  swap(entityindex_, other->entityindex_);
  swap(entityserial_, other->entityserial_);
  swap(groupid_, other->groupid_);
  swap(classid_, other->classid_);
  swap(entityflags_, other->entityflags_);
  swap(team_, other->team_);
  swap(category_, other->category_);
  swap(navflags_, other->navflags_);
  swap(powerups_, other->powerups_);
  swap(deleted_, other->deleted_);
}

::google::protobuf::Metadata GameEntityInfo::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameEntityPosition::InitAsDefaultInstance() {
  ::Analytics::_GameEntityPosition_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameEntityPosition::HasBitSetters {
 public:
  static const ::Analytics::Vec3& position(const GameEntityPosition* msg);
};

const ::Analytics::Vec3&
GameEntityPosition::HasBitSetters::position(const GameEntityPosition* msg) {
  return *msg->position_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameEntityPosition::kPositionFieldNumber;
const int GameEntityPosition::kTeamFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameEntityPosition::GameEntityPosition()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameEntityPosition)
}
GameEntityPosition::GameEntityPosition(const GameEntityPosition& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  team_ = from.team_;
  // @@protoc_insertion_point(copy_constructor:Analytics.GameEntityPosition)
}

void GameEntityPosition::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameEntityPosition_analytics_2eproto.base);
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&team_) -
      reinterpret_cast<char*>(&position_)) + sizeof(team_));
}

GameEntityPosition::~GameEntityPosition() {
  // @@protoc_insertion_point(destructor:Analytics.GameEntityPosition)
  SharedDtor();
}

void GameEntityPosition::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
}

void GameEntityPosition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameEntityPosition& GameEntityPosition::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameEntityPosition_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameEntityPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameEntityPosition)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  team_ = 0;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameEntityPosition::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameEntityPosition*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // int32 team = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_team(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameEntityPosition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameEntityPosition)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 team = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &team_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameEntityPosition)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameEntityPosition)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameEntityPosition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameEntityPosition)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::position(this), output);
  }

  // int32 team = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->team() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->team(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameEntityPosition)
}

::google::protobuf::uint8* GameEntityPosition::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameEntityPosition)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::position(this), deterministic, target);
  }

  // int32 team = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->team() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->team(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameEntityPosition)
  return target;
}

size_t GameEntityPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameEntityPosition)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // int32 team = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->team() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->team());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameEntityPosition::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameEntityPosition)
  GOOGLE_DCHECK_NE(&from, this);
  const GameEntityPosition* source =
      ::google::protobuf::DynamicCastToGenerated<GameEntityPosition>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameEntityPosition)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameEntityPosition)
    MergeFrom(*source);
  }
}

void GameEntityPosition::MergeFrom(const GameEntityPosition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameEntityPosition)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.team() != 0) {
    set_team(from.team());
  }
}

void GameEntityPosition::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameEntityPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameEntityPosition::CopyFrom(const GameEntityPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameEntityPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameEntityPosition::IsInitialized() const {
  return true;
}

void GameEntityPosition::Swap(GameEntityPosition* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameEntityPosition::InternalSwap(GameEntityPosition* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(position_, other->position_);
  swap(team_, other->team_);
}

::google::protobuf::Metadata GameEntityPosition::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameNode::InitAsDefaultInstance() {
  ::Analytics::_GameNode_default_instance_._instance.get_mutable()->eulerrotation_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
  ::Analytics::_GameNode_default_instance_._instance.get_mutable()->translation_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameNode::HasBitSetters {
 public:
  static const ::Analytics::Vec3& eulerrotation(const GameNode* msg);
  static const ::Analytics::Vec3& translation(const GameNode* msg);
};

const ::Analytics::Vec3&
GameNode::HasBitSetters::eulerrotation(const GameNode* msg) {
  return *msg->eulerrotation_;
}
const ::Analytics::Vec3&
GameNode::HasBitSetters::translation(const GameNode* msg) {
  return *msg->translation_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameNode::kNodePathFieldNumber;
const int GameNode::kEulerRotationFieldNumber;
const int GameNode::kTranslationFieldNumber;
const int GameNode::kMeshNameFieldNumber;
const int GameNode::kEntityIdFieldNumber;
const int GameNode::kEntityNameFieldNumber;
const int GameNode::kActiveStateFieldNumber;
const int GameNode::kNavFlagsActiveFieldNumber;
const int GameNode::kNavFlagsOverrideFieldNumber;
const int GameNode::kShapeModeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameNode::GameNode()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameNode)
}
GameNode::GameNode(const GameNode& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  nodepath_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.nodepath().size() > 0) {
    nodepath_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodepath_);
  }
  meshname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.meshname().size() > 0) {
    meshname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.meshname_);
  }
  entityname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.entityname().size() > 0) {
    entityname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entityname_);
  }
  if (from.has_eulerrotation()) {
    eulerrotation_ = new ::Analytics::Vec3(*from.eulerrotation_);
  } else {
    eulerrotation_ = NULL;
  }
  if (from.has_translation()) {
    translation_ = new ::Analytics::Vec3(*from.translation_);
  } else {
    translation_ = NULL;
  }
  ::memcpy(&entityid_, &from.entityid_,
    static_cast<size_t>(reinterpret_cast<char*>(&navflagsoverride_) -
    reinterpret_cast<char*>(&entityid_)) + sizeof(navflagsoverride_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameNode)
}

void GameNode::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameNode_analytics_2eproto.base);
  nodepath_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  meshname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  entityname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&eulerrotation_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&navflagsoverride_) -
      reinterpret_cast<char*>(&eulerrotation_)) + sizeof(navflagsoverride_));
}

GameNode::~GameNode() {
  // @@protoc_insertion_point(destructor:Analytics.GameNode)
  SharedDtor();
}

void GameNode::SharedDtor() {
  nodepath_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  meshname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  entityname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete eulerrotation_;
  if (this != internal_default_instance()) delete translation_;
}

void GameNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameNode& GameNode::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameNode_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameNode::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nodepath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  meshname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  entityname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && eulerrotation_ != NULL) {
    delete eulerrotation_;
  }
  eulerrotation_ = NULL;
  if (GetArenaNoVirtual() == NULL && translation_ != NULL) {
    delete translation_;
  }
  translation_ = NULL;
  ::memset(&entityid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&navflagsoverride_) -
      reinterpret_cast<char*>(&entityid_)) + sizeof(navflagsoverride_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameNode::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameNode*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // string nodePath = 1 [(.Analytics.editable_key) = true];
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameNode.nodePath");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_nodepath();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // .Analytics.Vec3 eulerRotation = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_eulerrotation();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // .Analytics.Vec3 translation = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_translation();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // string meshName = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameNode.meshName");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_meshname();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // int32 entityId = 10;
      case 10: {
        if (static_cast<::google::protobuf::uint8>(tag) != 80) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_entityid(value);
        break;
      }
      // string entityName = 11;
      case 11: {
        if (static_cast<::google::protobuf::uint8>(tag) != 90) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameNode.entityName");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_entityname();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // int32 activeState = 12 [(.Analytics.enumkey) = "MODEL_STATE"];
      case 12: {
        if (static_cast<::google::protobuf::uint8>(tag) != 96) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_activestate(value);
        break;
      }
      // int64 navFlagsActive = 13 [(.Analytics.enumkey) = "NAV_FLAGS"];
      case 13: {
        if (static_cast<::google::protobuf::uint8>(tag) != 104) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int64 value = val;
        msg->set_navflagsactive(value);
        break;
      }
      // int64 navFlagsOverride = 14 [(.Analytics.enumkey) = "NAV_FLAGS", (.Analytics.editable) = true];
      case 14: {
        if (static_cast<::google::protobuf::uint8>(tag) != 112) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int64 value = val;
        msg->set_navflagsoverride(value);
        break;
      }
      // int32 shapeMode = 15 [(.Analytics.enumkey) = "SHAPEMODE", (.Analytics.editable) = true];
      case 15: {
        if (static_cast<::google::protobuf::uint8>(tag) != 120) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_shapemode(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameNode::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameNode)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // string nodePath = 1 [(.Analytics.editable_key) = true];
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nodepath()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->nodepath().data(), static_cast<int>(this->nodepath().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameNode.nodePath"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 eulerRotation = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_eulerrotation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 translation = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_translation()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string meshName = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_meshname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->meshname().data(), static_cast<int>(this->meshname().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameNode.meshName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 entityId = 10;
      case 10: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (80 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &entityid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string entityName = 11;
      case 11: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (90 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_entityname()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->entityname().data(), static_cast<int>(this->entityname().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameNode.entityName"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 activeState = 12 [(.Analytics.enumkey) = "MODEL_STATE"];
      case 12: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (96 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &activestate_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 navFlagsActive = 13 [(.Analytics.enumkey) = "NAV_FLAGS"];
      case 13: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (104 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &navflagsactive_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int64 navFlagsOverride = 14 [(.Analytics.enumkey) = "NAV_FLAGS", (.Analytics.editable) = true];
      case 14: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (112 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &navflagsoverride_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 shapeMode = 15 [(.Analytics.enumkey) = "SHAPEMODE", (.Analytics.editable) = true];
      case 15: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (120 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &shapemode_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameNode)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameNode)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameNode::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string nodePath = 1 [(.Analytics.editable_key) = true];
  if (this->nodepath().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->nodepath().data(), static_cast<int>(this->nodepath().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNode.nodePath");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->nodepath(), output);
  }

  // .Analytics.Vec3 eulerRotation = 2;
  if (this->has_eulerrotation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::eulerrotation(this), output);
  }

  // .Analytics.Vec3 translation = 3;
  if (this->has_translation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::translation(this), output);
  }

  // string meshName = 4;
  if (this->meshname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->meshname().data(), static_cast<int>(this->meshname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNode.meshName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->meshname(), output);
  }

  // int32 entityId = 10;
  if (this->entityid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->entityid(), output);
  }

  // string entityName = 11;
  if (this->entityname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->entityname().data(), static_cast<int>(this->entityname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNode.entityName");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->entityname(), output);
  }

  // int32 activeState = 12 [(.Analytics.enumkey) = "MODEL_STATE"];
  if (this->activestate() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(12, this->activestate(), output);
  }

  // int64 navFlagsActive = 13 [(.Analytics.enumkey) = "NAV_FLAGS"];
  if (this->navflagsactive() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(13, this->navflagsactive(), output);
  }

  // int64 navFlagsOverride = 14 [(.Analytics.enumkey) = "NAV_FLAGS", (.Analytics.editable) = true];
  if (this->navflagsoverride() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->navflagsoverride(), output);
  }

  // int32 shapeMode = 15 [(.Analytics.enumkey) = "SHAPEMODE", (.Analytics.editable) = true];
  if (this->shapemode() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(15, this->shapemode(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameNode)
}

::google::protobuf::uint8* GameNode::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameNode)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // string nodePath = 1 [(.Analytics.editable_key) = true];
  if (this->nodepath().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->nodepath().data(), static_cast<int>(this->nodepath().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNode.nodePath");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->nodepath(), target);
  }

  // .Analytics.Vec3 eulerRotation = 2;
  if (this->has_eulerrotation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::eulerrotation(this), deterministic, target);
  }

  // .Analytics.Vec3 translation = 3;
  if (this->has_translation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::translation(this), deterministic, target);
  }

  // string meshName = 4;
  if (this->meshname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->meshname().data(), static_cast<int>(this->meshname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNode.meshName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->meshname(), target);
  }

  // int32 entityId = 10;
  if (this->entityid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(10, this->entityid(), target);
  }

  // string entityName = 11;
  if (this->entityname().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->entityname().data(), static_cast<int>(this->entityname().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameNode.entityName");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->entityname(), target);
  }

  // int32 activeState = 12 [(.Analytics.enumkey) = "MODEL_STATE"];
  if (this->activestate() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(12, this->activestate(), target);
  }

  // int64 navFlagsActive = 13 [(.Analytics.enumkey) = "NAV_FLAGS"];
  if (this->navflagsactive() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(13, this->navflagsactive(), target);
  }

  // int64 navFlagsOverride = 14 [(.Analytics.enumkey) = "NAV_FLAGS", (.Analytics.editable) = true];
  if (this->navflagsoverride() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(14, this->navflagsoverride(), target);
  }

  // int32 shapeMode = 15 [(.Analytics.enumkey) = "SHAPEMODE", (.Analytics.editable) = true];
  if (this->shapemode() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(15, this->shapemode(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameNode)
  return target;
}

size_t GameNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameNode)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nodePath = 1 [(.Analytics.editable_key) = true];
  if (this->nodepath().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->nodepath());
  }

  // string meshName = 4;
  if (this->meshname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->meshname());
  }

  // string entityName = 11;
  if (this->entityname().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->entityname());
  }

  // .Analytics.Vec3 eulerRotation = 2;
  if (this->has_eulerrotation()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *eulerrotation_);
  }

  // .Analytics.Vec3 translation = 3;
  if (this->has_translation()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *translation_);
  }

  // int32 entityId = 10;
  if (this->entityid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->entityid());
  }

  // int32 activeState = 12 [(.Analytics.enumkey) = "MODEL_STATE"];
  if (this->activestate() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->activestate());
  }

  // int32 shapeMode = 15 [(.Analytics.enumkey) = "SHAPEMODE", (.Analytics.editable) = true];
  if (this->shapemode() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->shapemode());
  }

  // int64 navFlagsActive = 13 [(.Analytics.enumkey) = "NAV_FLAGS"];
  if (this->navflagsactive() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->navflagsactive());
  }

  // int64 navFlagsOverride = 14 [(.Analytics.enumkey) = "NAV_FLAGS", (.Analytics.editable) = true];
  if (this->navflagsoverride() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->navflagsoverride());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameNode::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameNode)
  GOOGLE_DCHECK_NE(&from, this);
  const GameNode* source =
      ::google::protobuf::DynamicCastToGenerated<GameNode>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameNode)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameNode)
    MergeFrom(*source);
  }
}

void GameNode::MergeFrom(const GameNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameNode)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.nodepath().size() > 0) {

    nodepath_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nodepath_);
  }
  if (from.meshname().size() > 0) {

    meshname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.meshname_);
  }
  if (from.entityname().size() > 0) {

    entityname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.entityname_);
  }
  if (from.has_eulerrotation()) {
    mutable_eulerrotation()->::Analytics::Vec3::MergeFrom(from.eulerrotation());
  }
  if (from.has_translation()) {
    mutable_translation()->::Analytics::Vec3::MergeFrom(from.translation());
  }
  if (from.entityid() != 0) {
    set_entityid(from.entityid());
  }
  if (from.activestate() != 0) {
    set_activestate(from.activestate());
  }
  if (from.shapemode() != 0) {
    set_shapemode(from.shapemode());
  }
  if (from.navflagsactive() != 0) {
    set_navflagsactive(from.navflagsactive());
  }
  if (from.navflagsoverride() != 0) {
    set_navflagsoverride(from.navflagsoverride());
  }
}

void GameNode::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameNode::CopyFrom(const GameNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameNode::IsInitialized() const {
  return true;
}

void GameNode::Swap(GameNode* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameNode::InternalSwap(GameNode* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  nodepath_.Swap(&other->nodepath_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  meshname_.Swap(&other->meshname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  entityname_.Swap(&other->entityname_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(eulerrotation_, other->eulerrotation_);
  swap(translation_, other->translation_);
  swap(entityid_, other->entityid_);
  swap(activestate_, other->activestate_);
  swap(shapemode_, other->shapemode_);
  swap(navflagsactive_, other->navflagsactive_);
  swap(navflagsoverride_, other->navflagsoverride_);
}

::google::protobuf::Metadata GameNode::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameWeaponFired::InitAsDefaultInstance() {
  ::Analytics::_GameWeaponFired_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameWeaponFired::HasBitSetters {
 public:
  static const ::Analytics::Vec3& position(const GameWeaponFired* msg);
};

const ::Analytics::Vec3&
GameWeaponFired::HasBitSetters::position(const GameWeaponFired* msg) {
  return *msg->position_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameWeaponFired::kPositionFieldNumber;
const int GameWeaponFired::kAttackTeamFieldNumber;
const int GameWeaponFired::kWeaponIdFieldNumber;
const int GameWeaponFired::kFiredByClassFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameWeaponFired::GameWeaponFired()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameWeaponFired)
}
GameWeaponFired::GameWeaponFired(const GameWeaponFired& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  ::memcpy(&attackteam_, &from.attackteam_,
    static_cast<size_t>(reinterpret_cast<char*>(&firedbyclass_) -
    reinterpret_cast<char*>(&attackteam_)) + sizeof(firedbyclass_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameWeaponFired)
}

void GameWeaponFired::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameWeaponFired_analytics_2eproto.base);
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&firedbyclass_) -
      reinterpret_cast<char*>(&position_)) + sizeof(firedbyclass_));
}

GameWeaponFired::~GameWeaponFired() {
  // @@protoc_insertion_point(destructor:Analytics.GameWeaponFired)
  SharedDtor();
}

void GameWeaponFired::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
}

void GameWeaponFired::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameWeaponFired& GameWeaponFired::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameWeaponFired_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameWeaponFired::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameWeaponFired)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  ::memset(&attackteam_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&firedbyclass_) -
      reinterpret_cast<char*>(&attackteam_)) + sizeof(firedbyclass_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameWeaponFired::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameWeaponFired*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // int32 attackTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_attackteam(value);
        break;
      }
      // int32 weaponId = 3 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_weaponid(value);
        break;
      }
      // int32 firedByClass = 4 [(.Analytics.enumkey) = "CLASS_ID", (.Analytics.track_event) = true];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_firedbyclass(value);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameWeaponFired::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameWeaponFired)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 attackTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attackteam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 weaponId = 3 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weaponid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 firedByClass = 4 [(.Analytics.enumkey) = "CLASS_ID", (.Analytics.track_event) = true];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &firedbyclass_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameWeaponFired)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameWeaponFired)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameWeaponFired::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameWeaponFired)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::position(this), output);
  }

  // int32 attackTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->attackteam(), output);
  }

  // int32 weaponId = 3 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  if (this->weaponid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->weaponid(), output);
  }

  // int32 firedByClass = 4 [(.Analytics.enumkey) = "CLASS_ID", (.Analytics.track_event) = true];
  if (this->firedbyclass() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->firedbyclass(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameWeaponFired)
}

::google::protobuf::uint8* GameWeaponFired::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameWeaponFired)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::position(this), deterministic, target);
  }

  // int32 attackTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->attackteam(), target);
  }

  // int32 weaponId = 3 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  if (this->weaponid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->weaponid(), target);
  }

  // int32 firedByClass = 4 [(.Analytics.enumkey) = "CLASS_ID", (.Analytics.track_event) = true];
  if (this->firedbyclass() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->firedbyclass(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameWeaponFired)
  return target;
}

size_t GameWeaponFired::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameWeaponFired)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // int32 attackTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attackteam());
  }

  // int32 weaponId = 3 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  if (this->weaponid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->weaponid());
  }

  // int32 firedByClass = 4 [(.Analytics.enumkey) = "CLASS_ID", (.Analytics.track_event) = true];
  if (this->firedbyclass() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->firedbyclass());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameWeaponFired::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameWeaponFired)
  GOOGLE_DCHECK_NE(&from, this);
  const GameWeaponFired* source =
      ::google::protobuf::DynamicCastToGenerated<GameWeaponFired>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameWeaponFired)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameWeaponFired)
    MergeFrom(*source);
  }
}

void GameWeaponFired::MergeFrom(const GameWeaponFired& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameWeaponFired)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.attackteam() != 0) {
    set_attackteam(from.attackteam());
  }
  if (from.weaponid() != 0) {
    set_weaponid(from.weaponid());
  }
  if (from.firedbyclass() != 0) {
    set_firedbyclass(from.firedbyclass());
  }
}

void GameWeaponFired::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameWeaponFired)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameWeaponFired::CopyFrom(const GameWeaponFired& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameWeaponFired)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameWeaponFired::IsInitialized() const {
  return true;
}

void GameWeaponFired::Swap(GameWeaponFired* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameWeaponFired::InternalSwap(GameWeaponFired* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(position_, other->position_);
  swap(attackteam_, other->attackteam_);
  swap(weaponid_, other->weaponid_);
  swap(firedbyclass_, other->firedbyclass_);
}

::google::protobuf::Metadata GameWeaponFired::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameDeath::InitAsDefaultInstance() {
  ::Analytics::_GameDeath_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameDeath::HasBitSetters {
 public:
  static const ::Analytics::Vec3& position(const GameDeath* msg);
};

const ::Analytics::Vec3&
GameDeath::HasBitSetters::position(const GameDeath* msg) {
  return *msg->position_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameDeath::kPositionFieldNumber;
const int GameDeath::kVictimTeamFieldNumber;
const int GameDeath::kAttackTeamFieldNumber;
const int GameDeath::kMeansOfDeathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameDeath::GameDeath()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameDeath)
}
GameDeath::GameDeath(const GameDeath& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  meansofdeath_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.meansofdeath().size() > 0) {
    meansofdeath_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.meansofdeath_);
  }
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  ::memcpy(&victimteam_, &from.victimteam_,
    static_cast<size_t>(reinterpret_cast<char*>(&attackteam_) -
    reinterpret_cast<char*>(&victimteam_)) + sizeof(attackteam_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameDeath)
}

void GameDeath::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameDeath_analytics_2eproto.base);
  meansofdeath_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&attackteam_) -
      reinterpret_cast<char*>(&position_)) + sizeof(attackteam_));
}

GameDeath::~GameDeath() {
  // @@protoc_insertion_point(destructor:Analytics.GameDeath)
  SharedDtor();
}

void GameDeath::SharedDtor() {
  meansofdeath_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete position_;
}

void GameDeath::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameDeath& GameDeath::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameDeath_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameDeath::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameDeath)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  meansofdeath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  ::memset(&victimteam_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&attackteam_) -
      reinterpret_cast<char*>(&victimteam_)) + sizeof(attackteam_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameDeath::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameDeath*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_victimteam(value);
        break;
      }
      // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_attackteam(value);
        break;
      }
      // string meansOfDeath = 4 [(.Analytics.track_event) = true];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameDeath.meansOfDeath");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_meansofdeath();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameDeath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameDeath)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &victimteam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attackteam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string meansOfDeath = 4 [(.Analytics.track_event) = true];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_meansofdeath()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->meansofdeath().data(), static_cast<int>(this->meansofdeath().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameDeath.meansOfDeath"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameDeath)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameDeath)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameDeath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameDeath)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::position(this), output);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->victimteam(), output);
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->attackteam(), output);
  }

  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  if (this->meansofdeath().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->meansofdeath().data(), static_cast<int>(this->meansofdeath().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameDeath.meansOfDeath");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->meansofdeath(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameDeath)
}

::google::protobuf::uint8* GameDeath::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameDeath)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::position(this), deterministic, target);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->victimteam(), target);
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->attackteam(), target);
  }

  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  if (this->meansofdeath().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->meansofdeath().data(), static_cast<int>(this->meansofdeath().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameDeath.meansOfDeath");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->meansofdeath(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameDeath)
  return target;
}

size_t GameDeath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameDeath)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  if (this->meansofdeath().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->meansofdeath());
  }

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->victimteam());
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attackteam());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameDeath::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameDeath)
  GOOGLE_DCHECK_NE(&from, this);
  const GameDeath* source =
      ::google::protobuf::DynamicCastToGenerated<GameDeath>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameDeath)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameDeath)
    MergeFrom(*source);
  }
}

void GameDeath::MergeFrom(const GameDeath& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameDeath)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.meansofdeath().size() > 0) {

    meansofdeath_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.meansofdeath_);
  }
  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.victimteam() != 0) {
    set_victimteam(from.victimteam());
  }
  if (from.attackteam() != 0) {
    set_attackteam(from.attackteam());
  }
}

void GameDeath::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameDeath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameDeath::CopyFrom(const GameDeath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameDeath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameDeath::IsInitialized() const {
  return true;
}

void GameDeath::Swap(GameDeath* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameDeath::InternalSwap(GameDeath* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  meansofdeath_.Swap(&other->meansofdeath_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(position_, other->position_);
  swap(victimteam_, other->victimteam_);
  swap(attackteam_, other->attackteam_);
}

::google::protobuf::Metadata GameDeath::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameKilledSomeone::InitAsDefaultInstance() {
  ::Analytics::_GameKilledSomeone_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameKilledSomeone::HasBitSetters {
 public:
  static const ::Analytics::Vec3& position(const GameKilledSomeone* msg);
};

const ::Analytics::Vec3&
GameKilledSomeone::HasBitSetters::position(const GameKilledSomeone* msg) {
  return *msg->position_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameKilledSomeone::kPositionFieldNumber;
const int GameKilledSomeone::kVictimTeamFieldNumber;
const int GameKilledSomeone::kAttackTeamFieldNumber;
const int GameKilledSomeone::kMeansOfDeathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameKilledSomeone::GameKilledSomeone()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameKilledSomeone)
}
GameKilledSomeone::GameKilledSomeone(const GameKilledSomeone& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  meansofdeath_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.meansofdeath().size() > 0) {
    meansofdeath_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.meansofdeath_);
  }
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  ::memcpy(&victimteam_, &from.victimteam_,
    static_cast<size_t>(reinterpret_cast<char*>(&attackteam_) -
    reinterpret_cast<char*>(&victimteam_)) + sizeof(attackteam_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameKilledSomeone)
}

void GameKilledSomeone::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameKilledSomeone_analytics_2eproto.base);
  meansofdeath_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&attackteam_) -
      reinterpret_cast<char*>(&position_)) + sizeof(attackteam_));
}

GameKilledSomeone::~GameKilledSomeone() {
  // @@protoc_insertion_point(destructor:Analytics.GameKilledSomeone)
  SharedDtor();
}

void GameKilledSomeone::SharedDtor() {
  meansofdeath_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete position_;
}

void GameKilledSomeone::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameKilledSomeone& GameKilledSomeone::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameKilledSomeone_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameKilledSomeone::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameKilledSomeone)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  meansofdeath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  ::memset(&victimteam_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&attackteam_) -
      reinterpret_cast<char*>(&victimteam_)) + sizeof(attackteam_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameKilledSomeone::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameKilledSomeone*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_victimteam(value);
        break;
      }
      // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_attackteam(value);
        break;
      }
      // string meansOfDeath = 4 [(.Analytics.track_event) = true];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 34) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameKilledSomeone.meansOfDeath");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_meansofdeath();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameKilledSomeone::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameKilledSomeone)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &victimteam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attackteam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string meansOfDeath = 4 [(.Analytics.track_event) = true];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (34 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_meansofdeath()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->meansofdeath().data(), static_cast<int>(this->meansofdeath().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameKilledSomeone.meansOfDeath"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameKilledSomeone)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameKilledSomeone)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameKilledSomeone::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameKilledSomeone)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::position(this), output);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->victimteam(), output);
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->attackteam(), output);
  }

  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  if (this->meansofdeath().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->meansofdeath().data(), static_cast<int>(this->meansofdeath().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameKilledSomeone.meansOfDeath");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->meansofdeath(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameKilledSomeone)
}

::google::protobuf::uint8* GameKilledSomeone::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameKilledSomeone)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::position(this), deterministic, target);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->victimteam(), target);
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->attackteam(), target);
  }

  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  if (this->meansofdeath().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->meansofdeath().data(), static_cast<int>(this->meansofdeath().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameKilledSomeone.meansOfDeath");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->meansofdeath(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameKilledSomeone)
  return target;
}

size_t GameKilledSomeone::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameKilledSomeone)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  if (this->meansofdeath().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->meansofdeath());
  }

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->victimteam());
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attackteam());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameKilledSomeone::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameKilledSomeone)
  GOOGLE_DCHECK_NE(&from, this);
  const GameKilledSomeone* source =
      ::google::protobuf::DynamicCastToGenerated<GameKilledSomeone>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameKilledSomeone)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameKilledSomeone)
    MergeFrom(*source);
  }
}

void GameKilledSomeone::MergeFrom(const GameKilledSomeone& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameKilledSomeone)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.meansofdeath().size() > 0) {

    meansofdeath_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.meansofdeath_);
  }
  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.victimteam() != 0) {
    set_victimteam(from.victimteam());
  }
  if (from.attackteam() != 0) {
    set_attackteam(from.attackteam());
  }
}

void GameKilledSomeone::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameKilledSomeone)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameKilledSomeone::CopyFrom(const GameKilledSomeone& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameKilledSomeone)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameKilledSomeone::IsInitialized() const {
  return true;
}

void GameKilledSomeone::Swap(GameKilledSomeone* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameKilledSomeone::InternalSwap(GameKilledSomeone* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  meansofdeath_.Swap(&other->meansofdeath_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(position_, other->position_);
  swap(victimteam_, other->victimteam_);
  swap(attackteam_, other->attackteam_);
}

::google::protobuf::Metadata GameKilledSomeone::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameRecieveDamage::InitAsDefaultInstance() {
  ::Analytics::_GameRecieveDamage_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameRecieveDamage::HasBitSetters {
 public:
  static const ::Analytics::Vec3& position(const GameRecieveDamage* msg);
};

const ::Analytics::Vec3&
GameRecieveDamage::HasBitSetters::position(const GameRecieveDamage* msg) {
  return *msg->position_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameRecieveDamage::kPositionFieldNumber;
const int GameRecieveDamage::kVictimTeamFieldNumber;
const int GameRecieveDamage::kAttackTeamFieldNumber;
const int GameRecieveDamage::kWeaponIdFieldNumber;
const int GameRecieveDamage::kDamageTypeFieldNumber;
const int GameRecieveDamage::kDamageAmountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameRecieveDamage::GameRecieveDamage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameRecieveDamage)
}
GameRecieveDamage::GameRecieveDamage(const GameRecieveDamage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  damagetype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.damagetype().size() > 0) {
    damagetype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.damagetype_);
  }
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  ::memcpy(&victimteam_, &from.victimteam_,
    static_cast<size_t>(reinterpret_cast<char*>(&damageamount_) -
    reinterpret_cast<char*>(&victimteam_)) + sizeof(damageamount_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameRecieveDamage)
}

void GameRecieveDamage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameRecieveDamage_analytics_2eproto.base);
  damagetype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&damageamount_) -
      reinterpret_cast<char*>(&position_)) + sizeof(damageamount_));
}

GameRecieveDamage::~GameRecieveDamage() {
  // @@protoc_insertion_point(destructor:Analytics.GameRecieveDamage)
  SharedDtor();
}

void GameRecieveDamage::SharedDtor() {
  damagetype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete position_;
}

void GameRecieveDamage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameRecieveDamage& GameRecieveDamage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameRecieveDamage_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameRecieveDamage::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameRecieveDamage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  damagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  ::memset(&victimteam_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&damageamount_) -
      reinterpret_cast<char*>(&victimteam_)) + sizeof(damageamount_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameRecieveDamage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameRecieveDamage*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_victimteam(value);
        break;
      }
      // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_attackteam(value);
        break;
      }
      // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_weaponid(value);
        break;
      }
      // string damageType = 5 [(.Analytics.track_event) = true];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameRecieveDamage.damageType");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_damagetype();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // float damageAmount = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 53) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_damageamount(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameRecieveDamage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameRecieveDamage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &victimteam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attackteam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weaponid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string damageType = 5 [(.Analytics.track_event) = true];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_damagetype()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->damagetype().data(), static_cast<int>(this->damagetype().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameRecieveDamage.damageType"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float damageAmount = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (53 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damageamount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameRecieveDamage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameRecieveDamage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameRecieveDamage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameRecieveDamage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::position(this), output);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->victimteam(), output);
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->attackteam(), output);
  }

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  if (this->weaponid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->weaponid(), output);
  }

  // string damageType = 5 [(.Analytics.track_event) = true];
  if (this->damagetype().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->damagetype().data(), static_cast<int>(this->damagetype().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameRecieveDamage.damageType");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->damagetype(), output);
  }

  // float damageAmount = 6;
  if (this->damageamount() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->damageamount(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameRecieveDamage)
}

::google::protobuf::uint8* GameRecieveDamage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameRecieveDamage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::position(this), deterministic, target);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->victimteam(), target);
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->attackteam(), target);
  }

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  if (this->weaponid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->weaponid(), target);
  }

  // string damageType = 5 [(.Analytics.track_event) = true];
  if (this->damagetype().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->damagetype().data(), static_cast<int>(this->damagetype().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameRecieveDamage.damageType");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->damagetype(), target);
  }

  // float damageAmount = 6;
  if (this->damageamount() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->damageamount(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameRecieveDamage)
  return target;
}

size_t GameRecieveDamage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameRecieveDamage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string damageType = 5 [(.Analytics.track_event) = true];
  if (this->damagetype().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->damagetype());
  }

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->victimteam());
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attackteam());
  }

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  if (this->weaponid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->weaponid());
  }

  // float damageAmount = 6;
  if (this->damageamount() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameRecieveDamage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameRecieveDamage)
  GOOGLE_DCHECK_NE(&from, this);
  const GameRecieveDamage* source =
      ::google::protobuf::DynamicCastToGenerated<GameRecieveDamage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameRecieveDamage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameRecieveDamage)
    MergeFrom(*source);
  }
}

void GameRecieveDamage::MergeFrom(const GameRecieveDamage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameRecieveDamage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.damagetype().size() > 0) {

    damagetype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.damagetype_);
  }
  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.victimteam() != 0) {
    set_victimteam(from.victimteam());
  }
  if (from.attackteam() != 0) {
    set_attackteam(from.attackteam());
  }
  if (from.weaponid() != 0) {
    set_weaponid(from.weaponid());
  }
  if (from.damageamount() != 0) {
    set_damageamount(from.damageamount());
  }
}

void GameRecieveDamage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameRecieveDamage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameRecieveDamage::CopyFrom(const GameRecieveDamage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameRecieveDamage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameRecieveDamage::IsInitialized() const {
  return true;
}

void GameRecieveDamage::Swap(GameRecieveDamage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameRecieveDamage::InternalSwap(GameRecieveDamage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  damagetype_.Swap(&other->damagetype_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(position_, other->position_);
  swap(victimteam_, other->victimteam_);
  swap(attackteam_, other->attackteam_);
  swap(weaponid_, other->weaponid_);
  swap(damageamount_, other->damageamount_);
}

::google::protobuf::Metadata GameRecieveDamage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameInflictDamage::InitAsDefaultInstance() {
  ::Analytics::_GameInflictDamage_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameInflictDamage::HasBitSetters {
 public:
  static const ::Analytics::Vec3& position(const GameInflictDamage* msg);
};

const ::Analytics::Vec3&
GameInflictDamage::HasBitSetters::position(const GameInflictDamage* msg) {
  return *msg->position_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameInflictDamage::kPositionFieldNumber;
const int GameInflictDamage::kVictimTeamFieldNumber;
const int GameInflictDamage::kAttackTeamFieldNumber;
const int GameInflictDamage::kWeaponIdFieldNumber;
const int GameInflictDamage::kDamageTypeFieldNumber;
const int GameInflictDamage::kDamageAmountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameInflictDamage::GameInflictDamage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameInflictDamage)
}
GameInflictDamage::GameInflictDamage(const GameInflictDamage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  damagetype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.damagetype().size() > 0) {
    damagetype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.damagetype_);
  }
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  ::memcpy(&victimteam_, &from.victimteam_,
    static_cast<size_t>(reinterpret_cast<char*>(&damageamount_) -
    reinterpret_cast<char*>(&victimteam_)) + sizeof(damageamount_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameInflictDamage)
}

void GameInflictDamage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameInflictDamage_analytics_2eproto.base);
  damagetype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&damageamount_) -
      reinterpret_cast<char*>(&position_)) + sizeof(damageamount_));
}

GameInflictDamage::~GameInflictDamage() {
  // @@protoc_insertion_point(destructor:Analytics.GameInflictDamage)
  SharedDtor();
}

void GameInflictDamage::SharedDtor() {
  damagetype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete position_;
}

void GameInflictDamage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameInflictDamage& GameInflictDamage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameInflictDamage_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameInflictDamage::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameInflictDamage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  damagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  ::memset(&victimteam_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&damageamount_) -
      reinterpret_cast<char*>(&victimteam_)) + sizeof(damageamount_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameInflictDamage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameInflictDamage*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_victimteam(value);
        break;
      }
      // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 24) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_attackteam(value);
        break;
      }
      // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 32) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_weaponid(value);
        break;
      }
      // string damageType = 5 [(.Analytics.track_event) = true];
      case 5: {
        if (static_cast<::google::protobuf::uint8>(tag) != 42) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameInflictDamage.damageType");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_damagetype();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // float damageAmount = 6;
      case 6: {
        if (static_cast<::google::protobuf::uint8>(tag) != 53) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_damageamount(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameInflictDamage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameInflictDamage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &victimteam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (24 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &attackteam_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (32 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &weaponid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string damageType = 5 [(.Analytics.track_event) = true];
      case 5: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (42 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_damagetype()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->damagetype().data(), static_cast<int>(this->damagetype().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameInflictDamage.damageType"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float damageAmount = 6;
      case 6: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (53 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damageamount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameInflictDamage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameInflictDamage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameInflictDamage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameInflictDamage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::position(this), output);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->victimteam(), output);
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->attackteam(), output);
  }

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  if (this->weaponid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->weaponid(), output);
  }

  // string damageType = 5 [(.Analytics.track_event) = true];
  if (this->damagetype().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->damagetype().data(), static_cast<int>(this->damagetype().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameInflictDamage.damageType");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->damagetype(), output);
  }

  // float damageAmount = 6;
  if (this->damageamount() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->damageamount(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameInflictDamage)
}

::google::protobuf::uint8* GameInflictDamage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameInflictDamage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::position(this), deterministic, target);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->victimteam(), target);
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->attackteam(), target);
  }

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  if (this->weaponid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->weaponid(), target);
  }

  // string damageType = 5 [(.Analytics.track_event) = true];
  if (this->damagetype().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->damagetype().data(), static_cast<int>(this->damagetype().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameInflictDamage.damageType");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->damagetype(), target);
  }

  // float damageAmount = 6;
  if (this->damageamount() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->damageamount(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameInflictDamage)
  return target;
}

size_t GameInflictDamage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameInflictDamage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string damageType = 5 [(.Analytics.track_event) = true];
  if (this->damagetype().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->damagetype());
  }

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->victimteam() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->victimteam());
  }

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  if (this->attackteam() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->attackteam());
  }

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  if (this->weaponid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->weaponid());
  }

  // float damageAmount = 6;
  if (this->damageamount() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameInflictDamage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameInflictDamage)
  GOOGLE_DCHECK_NE(&from, this);
  const GameInflictDamage* source =
      ::google::protobuf::DynamicCastToGenerated<GameInflictDamage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameInflictDamage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameInflictDamage)
    MergeFrom(*source);
  }
}

void GameInflictDamage::MergeFrom(const GameInflictDamage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameInflictDamage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.damagetype().size() > 0) {

    damagetype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.damagetype_);
  }
  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.victimteam() != 0) {
    set_victimteam(from.victimteam());
  }
  if (from.attackteam() != 0) {
    set_attackteam(from.attackteam());
  }
  if (from.weaponid() != 0) {
    set_weaponid(from.weaponid());
  }
  if (from.damageamount() != 0) {
    set_damageamount(from.damageamount());
  }
}

void GameInflictDamage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameInflictDamage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameInflictDamage::CopyFrom(const GameInflictDamage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameInflictDamage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameInflictDamage::IsInitialized() const {
  return true;
}

void GameInflictDamage::Swap(GameInflictDamage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameInflictDamage::InternalSwap(GameInflictDamage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  damagetype_.Swap(&other->damagetype_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(position_, other->position_);
  swap(victimteam_, other->victimteam_);
  swap(attackteam_, other->attackteam_);
  swap(weaponid_, other->weaponid_);
  swap(damageamount_, other->damageamount_);
}

::google::protobuf::Metadata GameInflictDamage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameRadiusDamage::InitAsDefaultInstance() {
  ::Analytics::_GameRadiusDamage_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameRadiusDamage::HasBitSetters {
 public:
  static const ::Analytics::Vec3& position(const GameRadiusDamage* msg);
};

const ::Analytics::Vec3&
GameRadiusDamage::HasBitSetters::position(const GameRadiusDamage* msg) {
  return *msg->position_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameRadiusDamage::kPositionFieldNumber;
const int GameRadiusDamage::kDamageTypeFieldNumber;
const int GameRadiusDamage::kDamageAmountFieldNumber;
const int GameRadiusDamage::kDamageRadiusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameRadiusDamage::GameRadiusDamage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameRadiusDamage)
}
GameRadiusDamage::GameRadiusDamage(const GameRadiusDamage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  damagetype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.damagetype().size() > 0) {
    damagetype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.damagetype_);
  }
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  ::memcpy(&damageamount_, &from.damageamount_,
    static_cast<size_t>(reinterpret_cast<char*>(&damageradius_) -
    reinterpret_cast<char*>(&damageamount_)) + sizeof(damageradius_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameRadiusDamage)
}

void GameRadiusDamage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameRadiusDamage_analytics_2eproto.base);
  damagetype_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&damageradius_) -
      reinterpret_cast<char*>(&position_)) + sizeof(damageradius_));
}

GameRadiusDamage::~GameRadiusDamage() {
  // @@protoc_insertion_point(destructor:Analytics.GameRadiusDamage)
  SharedDtor();
}

void GameRadiusDamage::SharedDtor() {
  damagetype_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete position_;
}

void GameRadiusDamage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameRadiusDamage& GameRadiusDamage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameRadiusDamage_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameRadiusDamage::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameRadiusDamage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  damagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  ::memset(&damageamount_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&damageradius_) -
      reinterpret_cast<char*>(&damageamount_)) + sizeof(damageradius_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameRadiusDamage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameRadiusDamage*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 10) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      // string damageType = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameRadiusDamage.damageType");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_damagetype();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // float damageAmount = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 29) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_damageamount(val);
        break;
      }
      // float damageRadius = 4;
      case 4: {
        if (static_cast<::google::protobuf::uint8>(tag) != 37) goto handle_unusual;
        float val;
        std::memcpy(&val, ptr, 4);
        ptr += 4;
        msg->set_damageradius(val);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameRadiusDamage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameRadiusDamage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (10 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string damageType = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_damagetype()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->damagetype().data(), static_cast<int>(this->damagetype().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameRadiusDamage.damageType"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float damageAmount = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (29 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damageamount_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // float damageRadius = 4;
      case 4: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (37 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &damageradius_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameRadiusDamage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameRadiusDamage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameRadiusDamage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameRadiusDamage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, HasBitSetters::position(this), output);
  }

  // string damageType = 2;
  if (this->damagetype().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->damagetype().data(), static_cast<int>(this->damagetype().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameRadiusDamage.damageType");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->damagetype(), output);
  }

  // float damageAmount = 3;
  if (this->damageamount() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->damageamount(), output);
  }

  // float damageRadius = 4;
  if (this->damageradius() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->damageradius(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameRadiusDamage)
}

::google::protobuf::uint8* GameRadiusDamage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameRadiusDamage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, HasBitSetters::position(this), deterministic, target);
  }

  // string damageType = 2;
  if (this->damagetype().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->damagetype().data(), static_cast<int>(this->damagetype().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameRadiusDamage.damageType");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->damagetype(), target);
  }

  // float damageAmount = 3;
  if (this->damageamount() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->damageamount(), target);
  }

  // float damageRadius = 4;
  if (this->damageradius() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->damageradius(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameRadiusDamage)
  return target;
}

size_t GameRadiusDamage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameRadiusDamage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string damageType = 2;
  if (this->damagetype().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->damagetype());
  }

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // float damageAmount = 3;
  if (this->damageamount() != 0) {
    total_size += 1 + 4;
  }

  // float damageRadius = 4;
  if (this->damageradius() != 0) {
    total_size += 1 + 4;
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameRadiusDamage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameRadiusDamage)
  GOOGLE_DCHECK_NE(&from, this);
  const GameRadiusDamage* source =
      ::google::protobuf::DynamicCastToGenerated<GameRadiusDamage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameRadiusDamage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameRadiusDamage)
    MergeFrom(*source);
  }
}

void GameRadiusDamage::MergeFrom(const GameRadiusDamage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameRadiusDamage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.damagetype().size() > 0) {

    damagetype_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.damagetype_);
  }
  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.damageamount() != 0) {
    set_damageamount(from.damageamount());
  }
  if (from.damageradius() != 0) {
    set_damageradius(from.damageradius());
  }
}

void GameRadiusDamage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameRadiusDamage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameRadiusDamage::CopyFrom(const GameRadiusDamage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameRadiusDamage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameRadiusDamage::IsInitialized() const {
  return true;
}

void GameRadiusDamage::Swap(GameRadiusDamage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameRadiusDamage::InternalSwap(GameRadiusDamage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  damagetype_.Swap(&other->damagetype_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(position_, other->position_);
  swap(damageamount_, other->damageamount_);
  swap(damageradius_, other->damageradius_);
}

::google::protobuf::Metadata GameRadiusDamage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameNavigationStuck::InitAsDefaultInstance() {
  ::Analytics::_GameNavigationStuck_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameNavigationStuck::HasBitSetters {
 public:
  static const ::Analytics::Vec3& position(const GameNavigationStuck* msg);
};

const ::Analytics::Vec3&
GameNavigationStuck::HasBitSetters::position(const GameNavigationStuck* msg) {
  return *msg->position_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameNavigationStuck::kEntityIdFieldNumber;
const int GameNavigationStuck::kPositionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameNavigationStuck::GameNavigationStuck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameNavigationStuck)
}
GameNavigationStuck::GameNavigationStuck(const GameNavigationStuck& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  entityid_ = from.entityid_;
  // @@protoc_insertion_point(copy_constructor:Analytics.GameNavigationStuck)
}

void GameNavigationStuck::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameNavigationStuck_analytics_2eproto.base);
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&entityid_) -
      reinterpret_cast<char*>(&position_)) + sizeof(entityid_));
}

GameNavigationStuck::~GameNavigationStuck() {
  // @@protoc_insertion_point(destructor:Analytics.GameNavigationStuck)
  SharedDtor();
}

void GameNavigationStuck::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
}

void GameNavigationStuck::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameNavigationStuck& GameNavigationStuck::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameNavigationStuck_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameNavigationStuck::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameNavigationStuck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  entityid_ = 0;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameNavigationStuck::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameNavigationStuck*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int32 entityId = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_entityid(value);
        break;
      }
      // .Analytics.Vec3 position = 2 [(.Analytics.point_event) = {
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameNavigationStuck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameNavigationStuck)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 entityId = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &entityid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 position = 2 [(.Analytics.point_event) = {
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameNavigationStuck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameNavigationStuck)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameNavigationStuck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameNavigationStuck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 entityId = 1;
  if (this->entityid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->entityid(), output);
  }

  // .Analytics.Vec3 position = 2 [(.Analytics.point_event) = {
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, HasBitSetters::position(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameNavigationStuck)
}

::google::protobuf::uint8* GameNavigationStuck::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameNavigationStuck)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 entityId = 1;
  if (this->entityid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->entityid(), target);
  }

  // .Analytics.Vec3 position = 2 [(.Analytics.point_event) = {
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, HasBitSetters::position(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameNavigationStuck)
  return target;
}

size_t GameNavigationStuck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameNavigationStuck)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 2 [(.Analytics.point_event) = {
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // int32 entityId = 1;
  if (this->entityid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->entityid());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameNavigationStuck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameNavigationStuck)
  GOOGLE_DCHECK_NE(&from, this);
  const GameNavigationStuck* source =
      ::google::protobuf::DynamicCastToGenerated<GameNavigationStuck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameNavigationStuck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameNavigationStuck)
    MergeFrom(*source);
  }
}

void GameNavigationStuck::MergeFrom(const GameNavigationStuck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameNavigationStuck)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.entityid() != 0) {
    set_entityid(from.entityid());
  }
}

void GameNavigationStuck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameNavigationStuck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameNavigationStuck::CopyFrom(const GameNavigationStuck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameNavigationStuck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameNavigationStuck::IsInitialized() const {
  return true;
}

void GameNavigationStuck::Swap(GameNavigationStuck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameNavigationStuck::InternalSwap(GameNavigationStuck* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(position_, other->position_);
  swap(entityid_, other->entityid_);
}

::google::protobuf::Metadata GameNavigationStuck::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameVoiceMacro::InitAsDefaultInstance() {
  ::Analytics::_GameVoiceMacro_default_instance_._instance.get_mutable()->position_ = const_cast< ::Analytics::Vec3*>(
      ::Analytics::Vec3::internal_default_instance());
}
class GameVoiceMacro::HasBitSetters {
 public:
  static const ::Analytics::Vec3& position(const GameVoiceMacro* msg);
};

const ::Analytics::Vec3&
GameVoiceMacro::HasBitSetters::position(const GameVoiceMacro* msg) {
  return *msg->position_;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameVoiceMacro::kEntityIdFieldNumber;
const int GameVoiceMacro::kVoiceMacroFieldNumber;
const int GameVoiceMacro::kPositionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameVoiceMacro::GameVoiceMacro()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameVoiceMacro)
}
GameVoiceMacro::GameVoiceMacro(const GameVoiceMacro& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_position()) {
    position_ = new ::Analytics::Vec3(*from.position_);
  } else {
    position_ = NULL;
  }
  ::memcpy(&entityid_, &from.entityid_,
    static_cast<size_t>(reinterpret_cast<char*>(&voicemacro_) -
    reinterpret_cast<char*>(&entityid_)) + sizeof(voicemacro_));
  // @@protoc_insertion_point(copy_constructor:Analytics.GameVoiceMacro)
}

void GameVoiceMacro::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameVoiceMacro_analytics_2eproto.base);
  ::memset(&position_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&voicemacro_) -
      reinterpret_cast<char*>(&position_)) + sizeof(voicemacro_));
}

GameVoiceMacro::~GameVoiceMacro() {
  // @@protoc_insertion_point(destructor:Analytics.GameVoiceMacro)
  SharedDtor();
}

void GameVoiceMacro::SharedDtor() {
  if (this != internal_default_instance()) delete position_;
}

void GameVoiceMacro::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameVoiceMacro& GameVoiceMacro::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameVoiceMacro_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameVoiceMacro::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameVoiceMacro)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
  ::memset(&entityid_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&voicemacro_) -
      reinterpret_cast<char*>(&entityid_)) + sizeof(voicemacro_));
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameVoiceMacro::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameVoiceMacro*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // int32 entityId = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_entityid(value);
        break;
      }
      // int32 voiceMacro = 2 [(.Analytics.enumkey) = "VOICE_MACRO", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 16) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::google::protobuf::int32 value = val;
        msg->set_voicemacro(value);
        break;
      }
      // .Analytics.Vec3 position = 3 [(.Analytics.point_event) = {
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        parser_till_end = ::Analytics::Vec3::_InternalParse;
        object = msg->mutable_position();
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        bool ok = ctx->ParseExactRange({parser_till_end, object},
                                       ptr, newend);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
        ptr = newend;
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameVoiceMacro::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameVoiceMacro)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // int32 entityId = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &entityid_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // int32 voiceMacro = 2 [(.Analytics.enumkey) = "VOICE_MACRO", (.Analytics.track_event) = true];
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (16 & 0xFF)) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &voicemacro_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // .Analytics.Vec3 position = 3 [(.Analytics.point_event) = {
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessage(
               input, mutable_position()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameVoiceMacro)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameVoiceMacro)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameVoiceMacro::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameVoiceMacro)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 entityId = 1;
  if (this->entityid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->entityid(), output);
  }

  // int32 voiceMacro = 2 [(.Analytics.enumkey) = "VOICE_MACRO", (.Analytics.track_event) = true];
  if (this->voicemacro() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->voicemacro(), output);
  }

  // .Analytics.Vec3 position = 3 [(.Analytics.point_event) = {
  if (this->has_position()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, HasBitSetters::position(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameVoiceMacro)
}

::google::protobuf::uint8* GameVoiceMacro::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameVoiceMacro)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 entityId = 1;
  if (this->entityid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->entityid(), target);
  }

  // int32 voiceMacro = 2 [(.Analytics.enumkey) = "VOICE_MACRO", (.Analytics.track_event) = true];
  if (this->voicemacro() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->voicemacro(), target);
  }

  // .Analytics.Vec3 position = 3 [(.Analytics.point_event) = {
  if (this->has_position()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, HasBitSetters::position(this), deterministic, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameVoiceMacro)
  return target;
}

size_t GameVoiceMacro::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameVoiceMacro)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Analytics.Vec3 position = 3 [(.Analytics.point_event) = {
  if (this->has_position()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSize(
        *position_);
  }

  // int32 entityId = 1;
  if (this->entityid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->entityid());
  }

  // int32 voiceMacro = 2 [(.Analytics.enumkey) = "VOICE_MACRO", (.Analytics.track_event) = true];
  if (this->voicemacro() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->voicemacro());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameVoiceMacro::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameVoiceMacro)
  GOOGLE_DCHECK_NE(&from, this);
  const GameVoiceMacro* source =
      ::google::protobuf::DynamicCastToGenerated<GameVoiceMacro>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameVoiceMacro)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameVoiceMacro)
    MergeFrom(*source);
  }
}

void GameVoiceMacro::MergeFrom(const GameVoiceMacro& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameVoiceMacro)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_position()) {
    mutable_position()->::Analytics::Vec3::MergeFrom(from.position());
  }
  if (from.entityid() != 0) {
    set_entityid(from.entityid());
  }
  if (from.voicemacro() != 0) {
    set_voicemacro(from.voicemacro());
  }
}

void GameVoiceMacro::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameVoiceMacro)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameVoiceMacro::CopyFrom(const GameVoiceMacro& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameVoiceMacro)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameVoiceMacro::IsInitialized() const {
  return true;
}

void GameVoiceMacro::Swap(GameVoiceMacro* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameVoiceMacro::InternalSwap(GameVoiceMacro* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(position_, other->position_);
  swap(entityid_, other->entityid_);
  swap(voicemacro_, other->voicemacro_);
}

::google::protobuf::Metadata GameVoiceMacro::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}


// ===================================================================

void GameLogMessage::InitAsDefaultInstance() {
}
class GameLogMessage::HasBitSetters {
 public:
};

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int GameLogMessage::kLogTypeFieldNumber;
const int GameLogMessage::kLogMessageFieldNumber;
const int GameLogMessage::kLogExtraInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

GameLogMessage::GameLogMessage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:Analytics.GameLogMessage)
}
GameLogMessage::GameLogMessage(const GameLogMessage& from)
  : ::google::protobuf::Message(),
      _internal_metadata_(NULL) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  logmessage_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.logmessage().size() > 0) {
    logmessage_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.logmessage_);
  }
  logextrainfo_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (from.logextrainfo().size() > 0) {
    logextrainfo_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.logextrainfo_);
  }
  logtype_ = from.logtype_;
  // @@protoc_insertion_point(copy_constructor:Analytics.GameLogMessage)
}

void GameLogMessage::SharedCtor() {
  ::google::protobuf::internal::InitSCC(
      &scc_info_GameLogMessage_analytics_2eproto.base);
  logmessage_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  logextrainfo_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  logtype_ = 0;
}

GameLogMessage::~GameLogMessage() {
  // @@protoc_insertion_point(destructor:Analytics.GameLogMessage)
  SharedDtor();
}

void GameLogMessage::SharedDtor() {
  logmessage_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  logextrainfo_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void GameLogMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GameLogMessage& GameLogMessage::default_instance() {
  ::google::protobuf::internal::InitSCC(&::scc_info_GameLogMessage_analytics_2eproto.base);
  return *internal_default_instance();
}


void GameLogMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:Analytics.GameLogMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  logmessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  logextrainfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  logtype_ = 0;
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GameLogMessage::_InternalParse(const char* begin, const char* end, void* object,
                  ::google::protobuf::internal::ParseContext* ctx) {
  auto msg = static_cast<GameLogMessage*>(object);
  ::google::protobuf::uint32 size; (void)size;
  int depth; (void)depth;
  ::google::protobuf::internal::ParseFunc parser_till_end; (void)parser_till_end;
  auto ptr = begin;
  while (ptr < end) {
    ::google::protobuf::uint32 tag;
    ptr = Varint::Parse32Inline(ptr, &tag);
    GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
    switch (tag >> 3) {
      // .Analytics.LogType logType = 1;
      case 1: {
        if (static_cast<::google::protobuf::uint8>(tag) != 8) goto handle_unusual;
        ::google::protobuf::uint64 val;
        ptr = Varint::Parse64(ptr, &val);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ::Analytics::LogType value = static_cast<::Analytics::LogType>(val);
        msg->set_logtype(value);
        break;
      }
      // string logMessage = 2;
      case 2: {
        if (static_cast<::google::protobuf::uint8>(tag) != 18) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameLogMessage.logMessage");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_logmessage();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      // string logExtraInfo = 3;
      case 3: {
        if (static_cast<::google::protobuf::uint8>(tag) != 26) goto handle_unusual;
        ptr = Varint::Parse32Inline(ptr, &size);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr);
        ctx->extra_parse_data().SetFieldName("Analytics.GameLogMessage.logExtraInfo");
        parser_till_end = ::google::protobuf::internal::StringParserUTF8;
        ::std::string* str = msg->mutable_logextrainfo();
        str->clear();
        object = str;
        if (size > end - ptr) goto len_delim_till_end;
        auto newend = ptr + size;
        if (size) ptr = parser_till_end(ptr, newend, object, ctx);
        GOOGLE_PROTOBUF_PARSER_ASSERT(ptr == newend);
        break;
      }
      default: {
      handle_unusual: (void)&&handle_unusual;
        if ((tag & 7) == 4 || tag == 0) {
          bool ok = ctx->ValidEndGroup(tag);
          GOOGLE_PROTOBUF_PARSER_ASSERT(ok);
          return ptr;
        }
        auto res = UnknownFieldParse(tag, {_InternalParse, msg},
          ptr, end, msg->_internal_metadata_.mutable_unknown_fields(), ctx);
        ptr = res.first;
        if (res.second) return ptr;
      }
    }  // switch
  }  // while
  return ptr;
len_delim_till_end: (void)&&len_delim_till_end;
  return ctx->StoreAndTailCall(ptr, end, {_InternalParse, msg},
                                 {parser_till_end, object}, size);
group_continues: (void)&&group_continues;
  GOOGLE_DCHECK(ptr >= end);
  ctx->StoreGroup({_InternalParse, msg}, {parser_till_end, object}, depth);
  return ptr;
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GameLogMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:Analytics.GameLogMessage)
  for (;;) {
    ::std::pair<::google::protobuf::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // .Analytics.LogType logType = 1;
      case 1: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_logtype(static_cast< ::Analytics::LogType >(value));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string logMessage = 2;
      case 2: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (18 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_logmessage()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->logmessage().data(), static_cast<int>(this->logmessage().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameLogMessage.logMessage"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // string logExtraInfo = 3;
      case 3: {
        if (static_cast< ::google::protobuf::uint8>(tag) == (26 & 0xFF)) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_logextrainfo()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->logextrainfo().data(), static_cast<int>(this->logextrainfo().length()),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "Analytics.GameLogMessage.logExtraInfo"));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:Analytics.GameLogMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:Analytics.GameLogMessage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GameLogMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:Analytics.GameLogMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.LogType logType = 1;
  if (this->logtype() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->logtype(), output);
  }

  // string logMessage = 2;
  if (this->logmessage().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->logmessage().data(), static_cast<int>(this->logmessage().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameLogMessage.logMessage");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->logmessage(), output);
  }

  // string logExtraInfo = 3;
  if (this->logextrainfo().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->logextrainfo().data(), static_cast<int>(this->logextrainfo().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameLogMessage.logExtraInfo");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->logextrainfo(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:Analytics.GameLogMessage)
}

::google::protobuf::uint8* GameLogMessage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:Analytics.GameLogMessage)
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .Analytics.LogType logType = 1;
  if (this->logtype() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->logtype(), target);
  }

  // string logMessage = 2;
  if (this->logmessage().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->logmessage().data(), static_cast<int>(this->logmessage().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameLogMessage.logMessage");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->logmessage(), target);
  }

  // string logExtraInfo = 3;
  if (this->logextrainfo().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->logextrainfo().data(), static_cast<int>(this->logextrainfo().length()),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "Analytics.GameLogMessage.logExtraInfo");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->logextrainfo(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Analytics.GameLogMessage)
  return target;
}

size_t GameLogMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Analytics.GameLogMessage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::google::protobuf::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string logMessage = 2;
  if (this->logmessage().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->logmessage());
  }

  // string logExtraInfo = 3;
  if (this->logextrainfo().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->logextrainfo());
  }

  // .Analytics.LogType logType = 1;
  if (this->logtype() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->logtype());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GameLogMessage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Analytics.GameLogMessage)
  GOOGLE_DCHECK_NE(&from, this);
  const GameLogMessage* source =
      ::google::protobuf::DynamicCastToGenerated<GameLogMessage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Analytics.GameLogMessage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Analytics.GameLogMessage)
    MergeFrom(*source);
  }
}

void GameLogMessage::MergeFrom(const GameLogMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Analytics.GameLogMessage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::google::protobuf::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.logmessage().size() > 0) {

    logmessage_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.logmessage_);
  }
  if (from.logextrainfo().size() > 0) {

    logextrainfo_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.logextrainfo_);
  }
  if (from.logtype() != 0) {
    set_logtype(from.logtype());
  }
}

void GameLogMessage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Analytics.GameLogMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GameLogMessage::CopyFrom(const GameLogMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Analytics.GameLogMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameLogMessage::IsInitialized() const {
  return true;
}

void GameLogMessage::Swap(GameLogMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void GameLogMessage::InternalSwap(GameLogMessage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  logmessage_.Swap(&other->logmessage_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  logextrainfo_.Swap(&other->logextrainfo_, &::google::protobuf::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(logtype_, other->logtype_);
}

::google::protobuf::Metadata GameLogMessage::GetMetadata() const {
  ::google::protobuf::internal::AssignDescriptors(&::assign_descriptors_table_analytics_2eproto);
  return ::file_level_metadata_analytics_2eproto[kIndexInFileMessages];
}

::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::EnumTypeTraits< ::Analytics::RedisKeyType, ::Analytics::RedisKeyType_IsValid>, 14, false >
  rediskeytype(kRediskeytypeFieldNumber, static_cast< ::Analytics::RedisKeyType >(0));
const ::std::string redishmsetkey_default("");
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  redishmsetkey(kRedishmsetkeyFieldNumber, redishmsetkey_default);
const ::std::string rediskeysuffix_default("");
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  rediskeysuffix(kRediskeysuffixFieldNumber, rediskeysuffix_default);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  useJsonEncoding(kUseJsonEncodingFieldNumber, false);
const ::std::string objectname_default("");
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  objectname(kObjectnameFieldNumber, objectname_default);
const ::std::string enumkey_default("");
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  enumkey(kEnumkeyFieldNumber, enumkey_default);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  editable(kEditableFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >
  expires(kExpiresFieldNumber, 0);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  enumflags(kEnumflagsFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  tooltip(kTooltipFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  hidden(kHiddenFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  enumflagsindexed(kEnumflagsindexedFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  editable_key(kEditableKeyFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  track_event(kTrackEventFieldNumber, false);
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::Analytics::PointEvent >, 11, false >
  point_event(kPointEventFieldNumber, *::Analytics::PointEvent::internal_default_instance());
::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::Analytics::LineEvent >, 11, false >
  line_event(kLineEventFieldNumber, *::Analytics::LineEvent::internal_default_instance());

// @@protoc_insertion_point(namespace_scope)
}  // namespace Analytics
namespace google {
namespace protobuf {
template<> PROTOBUF_NOINLINE ::Analytics::PointEvent* Arena::CreateMaybeMessage< ::Analytics::PointEvent >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::PointEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::LineEvent* Arena::CreateMaybeMessage< ::Analytics::LineEvent >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::LineEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::EditorChangeValue* Arena::CreateMaybeMessage< ::Analytics::EditorChangeValue >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::EditorChangeValue >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::EditorChanges* Arena::CreateMaybeMessage< ::Analytics::EditorChanges >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::EditorChanges >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::RangeF* Arena::CreateMaybeMessage< ::Analytics::RangeF >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::RangeF >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::RangeI* Arena::CreateMaybeMessage< ::Analytics::RangeI >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::RangeI >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::Vec3* Arena::CreateMaybeMessage< ::Analytics::Vec3 >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::Vec3 >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::Vec3Color* Arena::CreateMaybeMessage< ::Analytics::Vec3Color >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::Vec3Color >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::Vec4* Arena::CreateMaybeMessage< ::Analytics::Vec4 >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::Vec4 >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::Line* Arena::CreateMaybeMessage< ::Analytics::Line >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::Line >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::Euler* Arena::CreateMaybeMessage< ::Analytics::Euler >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::Euler >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::Material* Arena::CreateMaybeMessage< ::Analytics::Material >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::Material >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::PrimitiveOptions* Arena::CreateMaybeMessage< ::Analytics::PrimitiveOptions >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::PrimitiveOptions >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::Primitive* Arena::CreateMaybeMessage< ::Analytics::Primitive >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::Primitive >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::Mesh* Arena::CreateMaybeMessage< ::Analytics::Mesh >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::Mesh >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::UTCTime* Arena::CreateMaybeMessage< ::Analytics::UTCTime >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::UTCTime >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameInfo* Arena::CreateMaybeMessage< ::Analytics::GameInfo >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameEnum_EnumPair* Arena::CreateMaybeMessage< ::Analytics::GameEnum_EnumPair >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameEnum_EnumPair >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameEnum* Arena::CreateMaybeMessage< ::Analytics::GameEnum >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameEnum >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameNavNotFound* Arena::CreateMaybeMessage< ::Analytics::GameNavNotFound >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameNavNotFound >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameNavAutoDownloaded* Arena::CreateMaybeMessage< ::Analytics::GameNavAutoDownloaded >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameNavAutoDownloaded >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameAssert* Arena::CreateMaybeMessage< ::Analytics::GameAssert >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameAssert >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameCrash* Arena::CreateMaybeMessage< ::Analytics::GameCrash >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameCrash >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameMeshData* Arena::CreateMaybeMessage< ::Analytics::GameMeshData >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameMeshData >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameEntityInfo_Ammo* Arena::CreateMaybeMessage< ::Analytics::GameEntityInfo_Ammo >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameEntityInfo_Ammo >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameEntityInfo* Arena::CreateMaybeMessage< ::Analytics::GameEntityInfo >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameEntityInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameEntityPosition* Arena::CreateMaybeMessage< ::Analytics::GameEntityPosition >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameEntityPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameNode* Arena::CreateMaybeMessage< ::Analytics::GameNode >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameNode >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameWeaponFired* Arena::CreateMaybeMessage< ::Analytics::GameWeaponFired >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameWeaponFired >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameDeath* Arena::CreateMaybeMessage< ::Analytics::GameDeath >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameDeath >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameKilledSomeone* Arena::CreateMaybeMessage< ::Analytics::GameKilledSomeone >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameKilledSomeone >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameRecieveDamage* Arena::CreateMaybeMessage< ::Analytics::GameRecieveDamage >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameRecieveDamage >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameInflictDamage* Arena::CreateMaybeMessage< ::Analytics::GameInflictDamage >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameInflictDamage >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameRadiusDamage* Arena::CreateMaybeMessage< ::Analytics::GameRadiusDamage >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameRadiusDamage >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameNavigationStuck* Arena::CreateMaybeMessage< ::Analytics::GameNavigationStuck >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameNavigationStuck >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameVoiceMacro* Arena::CreateMaybeMessage< ::Analytics::GameVoiceMacro >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameVoiceMacro >(arena);
}
template<> PROTOBUF_NOINLINE ::Analytics::GameLogMessage* Arena::CreateMaybeMessage< ::Analytics::GameLogMessage >(Arena* arena) {
  return Arena::CreateInternal< ::Analytics::GameLogMessage >(arena);
}
}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
