// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modeldata.proto

#ifndef PROTOBUF_modeldata_2eproto__INCLUDED
#define PROTOBUF_modeldata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace modeldata {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_modeldata_2eproto();
void protobuf_AssignDesc_modeldata_2eproto();
void protobuf_ShutdownFile_modeldata_2eproto();

class Vec3;
class Vec4;
class Euler;
class Matrix4;
class Node;
class Material;
class Mesh;
class Scene;

// ===================================================================

class Vec3 : public ::google::protobuf::Message {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();

  void Swap(Vec3* other);

  // implements Message ----------------------------------------------

  Vec3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:modeldata.Vec3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Vec3* default_instance_;
};
// -------------------------------------------------------------------

class Vec4 : public ::google::protobuf::Message {
 public:
  Vec4();
  virtual ~Vec4();

  Vec4(const Vec4& from);

  inline Vec4& operator=(const Vec4& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec4& default_instance();

  void Swap(Vec4* other);

  // implements Message ----------------------------------------------

  Vec4* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec4& from);
  void MergeFrom(const Vec4& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // optional float w = 4 [default = 0];
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline float w() const;
  inline void set_w(float value);

  // @@protoc_insertion_point(class_scope:modeldata.Vec4)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Vec4* default_instance_;
};
// -------------------------------------------------------------------

class Euler : public ::google::protobuf::Message {
 public:
  Euler();
  virtual ~Euler();

  Euler(const Euler& from);

  inline Euler& operator=(const Euler& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Euler& default_instance();

  void Swap(Euler* other);

  // implements Message ----------------------------------------------

  Euler* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Euler& from);
  void MergeFrom(const Euler& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float heading = 1 [default = 0];
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 1;
  inline float heading() const;
  inline void set_heading(float value);

  // optional float pitch = 2 [default = 0];
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 2;
  inline float pitch() const;
  inline void set_pitch(float value);

  // optional float roll = 3 [default = 0];
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 3;
  inline float roll() const;
  inline void set_roll(float value);

  // @@protoc_insertion_point(class_scope:modeldata.Euler)
 private:
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float heading_;
  float pitch_;
  float roll_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Euler* default_instance_;
};
// -------------------------------------------------------------------

class Matrix4 : public ::google::protobuf::Message {
 public:
  Matrix4();
  virtual ~Matrix4();

  Matrix4(const Matrix4& from);

  inline Matrix4& operator=(const Matrix4& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Matrix4& default_instance();

  void Swap(Matrix4* other);

  // implements Message ----------------------------------------------

  Matrix4* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Matrix4& from);
  void MergeFrom(const Matrix4& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .modeldata.Vec4 axisX = 1;
  inline bool has_axisx() const;
  inline void clear_axisx();
  static const int kAxisXFieldNumber = 1;
  inline const ::modeldata::Vec4& axisx() const;
  inline ::modeldata::Vec4* mutable_axisx();
  inline ::modeldata::Vec4* release_axisx();
  inline void set_allocated_axisx(::modeldata::Vec4* axisx);

  // required .modeldata.Vec4 axisY = 2;
  inline bool has_axisy() const;
  inline void clear_axisy();
  static const int kAxisYFieldNumber = 2;
  inline const ::modeldata::Vec4& axisy() const;
  inline ::modeldata::Vec4* mutable_axisy();
  inline ::modeldata::Vec4* release_axisy();
  inline void set_allocated_axisy(::modeldata::Vec4* axisy);

  // required .modeldata.Vec4 axisZ = 3;
  inline bool has_axisz() const;
  inline void clear_axisz();
  static const int kAxisZFieldNumber = 3;
  inline const ::modeldata::Vec4& axisz() const;
  inline ::modeldata::Vec4* mutable_axisz();
  inline ::modeldata::Vec4* release_axisz();
  inline void set_allocated_axisz(::modeldata::Vec4* axisz);

  // required .modeldata.Vec4 translation = 4;
  inline bool has_translation() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 4;
  inline const ::modeldata::Vec4& translation() const;
  inline ::modeldata::Vec4* mutable_translation();
  inline ::modeldata::Vec4* release_translation();
  inline void set_allocated_translation(::modeldata::Vec4* translation);

  // @@protoc_insertion_point(class_scope:modeldata.Matrix4)
 private:
  inline void set_has_axisx();
  inline void clear_has_axisx();
  inline void set_has_axisy();
  inline void clear_has_axisy();
  inline void set_has_axisz();
  inline void clear_has_axisz();
  inline void set_has_translation();
  inline void clear_has_translation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::modeldata::Vec4* axisx_;
  ::modeldata::Vec4* axisy_;
  ::modeldata::Vec4* axisz_;
  ::modeldata::Vec4* translation_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Matrix4* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .modeldata.Vec3 eulerRotation = 1;
  inline bool has_eulerrotation() const;
  inline void clear_eulerrotation();
  static const int kEulerRotationFieldNumber = 1;
  inline const ::modeldata::Vec3& eulerrotation() const;
  inline ::modeldata::Vec3* mutable_eulerrotation();
  inline ::modeldata::Vec3* release_eulerrotation();
  inline void set_allocated_eulerrotation(::modeldata::Vec3* eulerrotation);

  // optional .modeldata.Vec3 translation = 2;
  inline bool has_translation() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 2;
  inline const ::modeldata::Vec3& translation() const;
  inline ::modeldata::Vec3* mutable_translation();
  inline ::modeldata::Vec3* release_translation();
  inline void set_allocated_translation(::modeldata::Vec3* translation);

  // optional string meshName = 3;
  inline bool has_meshname() const;
  inline void clear_meshname();
  static const int kMeshNameFieldNumber = 3;
  inline const ::std::string& meshname() const;
  inline void set_meshname(const ::std::string& value);
  inline void set_meshname(const char* value);
  inline void set_meshname(const char* value, size_t size);
  inline ::std::string* mutable_meshname();
  inline ::std::string* release_meshname();
  inline void set_allocated_meshname(::std::string* meshname);

  // repeated .modeldata.Node children = 4;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 4;
  inline const ::modeldata::Node& children(int index) const;
  inline ::modeldata::Node* mutable_children(int index);
  inline ::modeldata::Node* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Node >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeldata::Node >*
      mutable_children();

  // @@protoc_insertion_point(class_scope:modeldata.Node)
 private:
  inline void set_has_eulerrotation();
  inline void clear_has_eulerrotation();
  inline void set_has_translation();
  inline void clear_has_translation();
  inline void set_has_meshname();
  inline void clear_has_meshname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::modeldata::Vec3* eulerrotation_;
  ::modeldata::Vec3* translation_;
  ::std::string* meshname_;
  ::google::protobuf::RepeatedPtrField< ::modeldata::Node > children_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Material : public ::google::protobuf::Message {
 public:
  Material();
  virtual ~Material();

  Material(const Material& from);

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Material& default_instance();

  void Swap(Material* other);

  // implements Message ----------------------------------------------

  Material* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 contents = 2;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 2;
  inline ::google::protobuf::uint32 contents() const;
  inline void set_contents(::google::protobuf::uint32 value);

  // optional uint32 surfaceFlags = 3;
  inline bool has_surfaceflags() const;
  inline void clear_surfaceflags();
  static const int kSurfaceFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 surfaceflags() const;
  inline void set_surfaceflags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:modeldata.Material)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_contents();
  inline void clear_has_contents();
  inline void set_has_surfaceflags();
  inline void clear_has_surfaceflags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 contents_;
  ::google::protobuf::uint32 surfaceflags_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Material* default_instance_;
};
// -------------------------------------------------------------------

class Mesh : public ::google::protobuf::Message {
 public:
  Mesh();
  virtual ~Mesh();

  Mesh(const Mesh& from);

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mesh& default_instance();

  void Swap(Mesh* other);

  // implements Message ----------------------------------------------

  Mesh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes vertices = 2;
  inline bool has_vertices() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 2;
  inline const ::std::string& vertices() const;
  inline void set_vertices(const ::std::string& value);
  inline void set_vertices(const char* value);
  inline void set_vertices(const void* value, size_t size);
  inline ::std::string* mutable_vertices();
  inline ::std::string* release_vertices();
  inline void set_allocated_vertices(::std::string* vertices);

  // optional bytes faces = 3;
  inline bool has_faces() const;
  inline void clear_faces();
  static const int kFacesFieldNumber = 3;
  inline const ::std::string& faces() const;
  inline void set_faces(const ::std::string& value);
  inline void set_faces(const char* value);
  inline void set_faces(const void* value, size_t size);
  inline ::std::string* mutable_faces();
  inline ::std::string* release_faces();
  inline void set_allocated_faces(::std::string* faces);

  // optional bytes materialIndices = 4;
  inline bool has_materialindices() const;
  inline void clear_materialindices();
  static const int kMaterialIndicesFieldNumber = 4;
  inline const ::std::string& materialindices() const;
  inline void set_materialindices(const ::std::string& value);
  inline void set_materialindices(const char* value);
  inline void set_materialindices(const void* value, size_t size);
  inline ::std::string* mutable_materialindices();
  inline ::std::string* release_materialindices();
  inline void set_allocated_materialindices(::std::string* materialindices);

  // repeated .modeldata.Material materials = 5;
  inline int materials_size() const;
  inline void clear_materials();
  static const int kMaterialsFieldNumber = 5;
  inline const ::modeldata::Material& materials(int index) const;
  inline ::modeldata::Material* mutable_materials(int index);
  inline ::modeldata::Material* add_materials();
  inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Material >&
      materials() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeldata::Material >*
      mutable_materials();

  // @@protoc_insertion_point(class_scope:modeldata.Mesh)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_vertices();
  inline void clear_has_vertices();
  inline void set_has_faces();
  inline void clear_has_faces();
  inline void set_has_materialindices();
  inline void clear_has_materialindices();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* vertices_;
  ::std::string* faces_;
  ::std::string* materialindices_;
  ::google::protobuf::RepeatedPtrField< ::modeldata::Material > materials_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Mesh* default_instance_;
};
// -------------------------------------------------------------------

class Scene : public ::google::protobuf::Message {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scene& default_instance();

  void Swap(Scene* other);

  // implements Message ----------------------------------------------

  Scene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .modeldata.Node rootNode = 1;
  inline bool has_rootnode() const;
  inline void clear_rootnode();
  static const int kRootNodeFieldNumber = 1;
  inline const ::modeldata::Node& rootnode() const;
  inline ::modeldata::Node* mutable_rootnode();
  inline ::modeldata::Node* release_rootnode();
  inline void set_allocated_rootnode(::modeldata::Node* rootnode);

  // repeated .modeldata.Mesh meshes = 2;
  inline int meshes_size() const;
  inline void clear_meshes();
  static const int kMeshesFieldNumber = 2;
  inline const ::modeldata::Mesh& meshes(int index) const;
  inline ::modeldata::Mesh* mutable_meshes(int index);
  inline ::modeldata::Mesh* add_meshes();
  inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh >&
      meshes() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh >*
      mutable_meshes();

  // @@protoc_insertion_point(class_scope:modeldata.Scene)
 private:
  inline void set_has_rootnode();
  inline void clear_has_rootnode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::modeldata::Node* rootnode_;
  ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh > meshes_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Scene* default_instance_;
};
// ===================================================================


// ===================================================================

// Vec3

// optional float x = 1 [default = 0];
inline bool Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec3.x)
  return x_;
}
inline void Vec3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec3.x)
}

// optional float y = 2 [default = 0];
inline bool Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec3.y)
  return y_;
}
inline void Vec3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec3.y)
}

// optional float z = 3 [default = 0];
inline bool Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec3.z)
  return z_;
}
inline void Vec3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec3.z)
}

// -------------------------------------------------------------------

// Vec4

// optional float x = 1 [default = 0];
inline bool Vec4::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec4::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec4::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec4::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec4::x() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec4.x)
  return x_;
}
inline void Vec4::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec4.x)
}

// optional float y = 2 [default = 0];
inline bool Vec4::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec4::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec4::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec4::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec4::y() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec4.y)
  return y_;
}
inline void Vec4::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec4.y)
}

// optional float z = 3 [default = 0];
inline bool Vec4::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec4::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec4::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec4::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vec4::z() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec4.z)
  return z_;
}
inline void Vec4::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec4.z)
}

// optional float w = 4 [default = 0];
inline bool Vec4::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vec4::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vec4::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vec4::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Vec4::w() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec4.w)
  return w_;
}
inline void Vec4::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec4.w)
}

// -------------------------------------------------------------------

// Euler

// optional float heading = 1 [default = 0];
inline bool Euler::has_heading() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Euler::set_has_heading() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Euler::clear_has_heading() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Euler::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float Euler::heading() const {
  // @@protoc_insertion_point(field_get:modeldata.Euler.heading)
  return heading_;
}
inline void Euler::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Euler.heading)
}

// optional float pitch = 2 [default = 0];
inline bool Euler::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Euler::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Euler::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Euler::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float Euler::pitch() const {
  // @@protoc_insertion_point(field_get:modeldata.Euler.pitch)
  return pitch_;
}
inline void Euler::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Euler.pitch)
}

// optional float roll = 3 [default = 0];
inline bool Euler::has_roll() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Euler::set_has_roll() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Euler::clear_has_roll() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Euler::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float Euler::roll() const {
  // @@protoc_insertion_point(field_get:modeldata.Euler.roll)
  return roll_;
}
inline void Euler::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Euler.roll)
}

// -------------------------------------------------------------------

// Matrix4

// required .modeldata.Vec4 axisX = 1;
inline bool Matrix4::has_axisx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Matrix4::set_has_axisx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Matrix4::clear_has_axisx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Matrix4::clear_axisx() {
  if (axisx_ != NULL) axisx_->::modeldata::Vec4::Clear();
  clear_has_axisx();
}
inline const ::modeldata::Vec4& Matrix4::axisx() const {
  // @@protoc_insertion_point(field_get:modeldata.Matrix4.axisX)
  return axisx_ != NULL ? *axisx_ : *default_instance_->axisx_;
}
inline ::modeldata::Vec4* Matrix4::mutable_axisx() {
  set_has_axisx();
  if (axisx_ == NULL) axisx_ = new ::modeldata::Vec4;
  // @@protoc_insertion_point(field_mutable:modeldata.Matrix4.axisX)
  return axisx_;
}
inline ::modeldata::Vec4* Matrix4::release_axisx() {
  clear_has_axisx();
  ::modeldata::Vec4* temp = axisx_;
  axisx_ = NULL;
  return temp;
}
inline void Matrix4::set_allocated_axisx(::modeldata::Vec4* axisx) {
  delete axisx_;
  axisx_ = axisx;
  if (axisx) {
    set_has_axisx();
  } else {
    clear_has_axisx();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Matrix4.axisX)
}

// required .modeldata.Vec4 axisY = 2;
inline bool Matrix4::has_axisy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Matrix4::set_has_axisy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Matrix4::clear_has_axisy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Matrix4::clear_axisy() {
  if (axisy_ != NULL) axisy_->::modeldata::Vec4::Clear();
  clear_has_axisy();
}
inline const ::modeldata::Vec4& Matrix4::axisy() const {
  // @@protoc_insertion_point(field_get:modeldata.Matrix4.axisY)
  return axisy_ != NULL ? *axisy_ : *default_instance_->axisy_;
}
inline ::modeldata::Vec4* Matrix4::mutable_axisy() {
  set_has_axisy();
  if (axisy_ == NULL) axisy_ = new ::modeldata::Vec4;
  // @@protoc_insertion_point(field_mutable:modeldata.Matrix4.axisY)
  return axisy_;
}
inline ::modeldata::Vec4* Matrix4::release_axisy() {
  clear_has_axisy();
  ::modeldata::Vec4* temp = axisy_;
  axisy_ = NULL;
  return temp;
}
inline void Matrix4::set_allocated_axisy(::modeldata::Vec4* axisy) {
  delete axisy_;
  axisy_ = axisy;
  if (axisy) {
    set_has_axisy();
  } else {
    clear_has_axisy();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Matrix4.axisY)
}

// required .modeldata.Vec4 axisZ = 3;
inline bool Matrix4::has_axisz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Matrix4::set_has_axisz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Matrix4::clear_has_axisz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Matrix4::clear_axisz() {
  if (axisz_ != NULL) axisz_->::modeldata::Vec4::Clear();
  clear_has_axisz();
}
inline const ::modeldata::Vec4& Matrix4::axisz() const {
  // @@protoc_insertion_point(field_get:modeldata.Matrix4.axisZ)
  return axisz_ != NULL ? *axisz_ : *default_instance_->axisz_;
}
inline ::modeldata::Vec4* Matrix4::mutable_axisz() {
  set_has_axisz();
  if (axisz_ == NULL) axisz_ = new ::modeldata::Vec4;
  // @@protoc_insertion_point(field_mutable:modeldata.Matrix4.axisZ)
  return axisz_;
}
inline ::modeldata::Vec4* Matrix4::release_axisz() {
  clear_has_axisz();
  ::modeldata::Vec4* temp = axisz_;
  axisz_ = NULL;
  return temp;
}
inline void Matrix4::set_allocated_axisz(::modeldata::Vec4* axisz) {
  delete axisz_;
  axisz_ = axisz;
  if (axisz) {
    set_has_axisz();
  } else {
    clear_has_axisz();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Matrix4.axisZ)
}

// required .modeldata.Vec4 translation = 4;
inline bool Matrix4::has_translation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Matrix4::set_has_translation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Matrix4::clear_has_translation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Matrix4::clear_translation() {
  if (translation_ != NULL) translation_->::modeldata::Vec4::Clear();
  clear_has_translation();
}
inline const ::modeldata::Vec4& Matrix4::translation() const {
  // @@protoc_insertion_point(field_get:modeldata.Matrix4.translation)
  return translation_ != NULL ? *translation_ : *default_instance_->translation_;
}
inline ::modeldata::Vec4* Matrix4::mutable_translation() {
  set_has_translation();
  if (translation_ == NULL) translation_ = new ::modeldata::Vec4;
  // @@protoc_insertion_point(field_mutable:modeldata.Matrix4.translation)
  return translation_;
}
inline ::modeldata::Vec4* Matrix4::release_translation() {
  clear_has_translation();
  ::modeldata::Vec4* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline void Matrix4::set_allocated_translation(::modeldata::Vec4* translation) {
  delete translation_;
  translation_ = translation;
  if (translation) {
    set_has_translation();
  } else {
    clear_has_translation();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Matrix4.translation)
}

// -------------------------------------------------------------------

// Node

// optional .modeldata.Vec3 eulerRotation = 1;
inline bool Node::has_eulerrotation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_eulerrotation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_eulerrotation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_eulerrotation() {
  if (eulerrotation_ != NULL) eulerrotation_->::modeldata::Vec3::Clear();
  clear_has_eulerrotation();
}
inline const ::modeldata::Vec3& Node::eulerrotation() const {
  // @@protoc_insertion_point(field_get:modeldata.Node.eulerRotation)
  return eulerrotation_ != NULL ? *eulerrotation_ : *default_instance_->eulerrotation_;
}
inline ::modeldata::Vec3* Node::mutable_eulerrotation() {
  set_has_eulerrotation();
  if (eulerrotation_ == NULL) eulerrotation_ = new ::modeldata::Vec3;
  // @@protoc_insertion_point(field_mutable:modeldata.Node.eulerRotation)
  return eulerrotation_;
}
inline ::modeldata::Vec3* Node::release_eulerrotation() {
  clear_has_eulerrotation();
  ::modeldata::Vec3* temp = eulerrotation_;
  eulerrotation_ = NULL;
  return temp;
}
inline void Node::set_allocated_eulerrotation(::modeldata::Vec3* eulerrotation) {
  delete eulerrotation_;
  eulerrotation_ = eulerrotation;
  if (eulerrotation) {
    set_has_eulerrotation();
  } else {
    clear_has_eulerrotation();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Node.eulerRotation)
}

// optional .modeldata.Vec3 translation = 2;
inline bool Node::has_translation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_translation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_translation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_translation() {
  if (translation_ != NULL) translation_->::modeldata::Vec3::Clear();
  clear_has_translation();
}
inline const ::modeldata::Vec3& Node::translation() const {
  // @@protoc_insertion_point(field_get:modeldata.Node.translation)
  return translation_ != NULL ? *translation_ : *default_instance_->translation_;
}
inline ::modeldata::Vec3* Node::mutable_translation() {
  set_has_translation();
  if (translation_ == NULL) translation_ = new ::modeldata::Vec3;
  // @@protoc_insertion_point(field_mutable:modeldata.Node.translation)
  return translation_;
}
inline ::modeldata::Vec3* Node::release_translation() {
  clear_has_translation();
  ::modeldata::Vec3* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline void Node::set_allocated_translation(::modeldata::Vec3* translation) {
  delete translation_;
  translation_ = translation;
  if (translation) {
    set_has_translation();
  } else {
    clear_has_translation();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Node.translation)
}

// optional string meshName = 3;
inline bool Node::has_meshname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_meshname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_meshname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_meshname() {
  if (meshname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meshname_->clear();
  }
  clear_has_meshname();
}
inline const ::std::string& Node::meshname() const {
  // @@protoc_insertion_point(field_get:modeldata.Node.meshName)
  return *meshname_;
}
inline void Node::set_meshname(const ::std::string& value) {
  set_has_meshname();
  if (meshname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meshname_ = new ::std::string;
  }
  meshname_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Node.meshName)
}
inline void Node::set_meshname(const char* value) {
  set_has_meshname();
  if (meshname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meshname_ = new ::std::string;
  }
  meshname_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Node.meshName)
}
inline void Node::set_meshname(const char* value, size_t size) {
  set_has_meshname();
  if (meshname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meshname_ = new ::std::string;
  }
  meshname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Node.meshName)
}
inline ::std::string* Node::mutable_meshname() {
  set_has_meshname();
  if (meshname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    meshname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Node.meshName)
  return meshname_;
}
inline ::std::string* Node::release_meshname() {
  clear_has_meshname();
  if (meshname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = meshname_;
    meshname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Node::set_allocated_meshname(::std::string* meshname) {
  if (meshname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete meshname_;
  }
  if (meshname) {
    set_has_meshname();
    meshname_ = meshname;
  } else {
    clear_has_meshname();
    meshname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Node.meshName)
}

// repeated .modeldata.Node children = 4;
inline int Node::children_size() const {
  return children_.size();
}
inline void Node::clear_children() {
  children_.Clear();
}
inline const ::modeldata::Node& Node::children(int index) const {
  // @@protoc_insertion_point(field_get:modeldata.Node.children)
  return children_.Get(index);
}
inline ::modeldata::Node* Node::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:modeldata.Node.children)
  return children_.Mutable(index);
}
inline ::modeldata::Node* Node::add_children() {
  // @@protoc_insertion_point(field_add:modeldata.Node.children)
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Node >&
Node::children() const {
  // @@protoc_insertion_point(field_list:modeldata.Node.children)
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeldata::Node >*
Node::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:modeldata.Node.children)
  return &children_;
}

// -------------------------------------------------------------------

// Material

// required string name = 1;
inline bool Material::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Material::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Material::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Material::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Material::name() const {
  // @@protoc_insertion_point(field_get:modeldata.Material.name)
  return *name_;
}
inline void Material::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Material.name)
}
inline void Material::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Material.name)
}
inline void Material::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Material.name)
}
inline ::std::string* Material::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Material.name)
  return name_;
}
inline ::std::string* Material::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Material::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Material.name)
}

// optional uint32 contents = 2;
inline bool Material::has_contents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Material::set_has_contents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Material::clear_has_contents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Material::clear_contents() {
  contents_ = 0u;
  clear_has_contents();
}
inline ::google::protobuf::uint32 Material::contents() const {
  // @@protoc_insertion_point(field_get:modeldata.Material.contents)
  return contents_;
}
inline void Material::set_contents(::google::protobuf::uint32 value) {
  set_has_contents();
  contents_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Material.contents)
}

// optional uint32 surfaceFlags = 3;
inline bool Material::has_surfaceflags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Material::set_has_surfaceflags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Material::clear_has_surfaceflags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Material::clear_surfaceflags() {
  surfaceflags_ = 0u;
  clear_has_surfaceflags();
}
inline ::google::protobuf::uint32 Material::surfaceflags() const {
  // @@protoc_insertion_point(field_get:modeldata.Material.surfaceFlags)
  return surfaceflags_;
}
inline void Material::set_surfaceflags(::google::protobuf::uint32 value) {
  set_has_surfaceflags();
  surfaceflags_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Material.surfaceFlags)
}

// -------------------------------------------------------------------

// Mesh

// optional string name = 1;
inline bool Mesh::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mesh::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mesh::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mesh::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Mesh::name() const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.name)
  return *name_;
}
inline void Mesh::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Mesh.name)
}
inline void Mesh::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Mesh.name)
}
inline void Mesh::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Mesh.name)
}
inline ::std::string* Mesh::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Mesh.name)
  return name_;
}
inline ::std::string* Mesh::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mesh::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Mesh.name)
}

// optional bytes vertices = 2;
inline bool Mesh::has_vertices() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mesh::set_has_vertices() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mesh::clear_has_vertices() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mesh::clear_vertices() {
  if (vertices_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_->clear();
  }
  clear_has_vertices();
}
inline const ::std::string& Mesh::vertices() const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.vertices)
  return *vertices_;
}
inline void Mesh::set_vertices(const ::std::string& value) {
  set_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_ = new ::std::string;
  }
  vertices_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Mesh.vertices)
}
inline void Mesh::set_vertices(const char* value) {
  set_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_ = new ::std::string;
  }
  vertices_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Mesh.vertices)
}
inline void Mesh::set_vertices(const void* value, size_t size) {
  set_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_ = new ::std::string;
  }
  vertices_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Mesh.vertices)
}
inline ::std::string* Mesh::mutable_vertices() {
  set_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Mesh.vertices)
  return vertices_;
}
inline ::std::string* Mesh::release_vertices() {
  clear_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vertices_;
    vertices_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mesh::set_allocated_vertices(::std::string* vertices) {
  if (vertices_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vertices_;
  }
  if (vertices) {
    set_has_vertices();
    vertices_ = vertices;
  } else {
    clear_has_vertices();
    vertices_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Mesh.vertices)
}

// optional bytes faces = 3;
inline bool Mesh::has_faces() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mesh::set_has_faces() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mesh::clear_has_faces() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mesh::clear_faces() {
  if (faces_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_->clear();
  }
  clear_has_faces();
}
inline const ::std::string& Mesh::faces() const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.faces)
  return *faces_;
}
inline void Mesh::set_faces(const ::std::string& value) {
  set_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_ = new ::std::string;
  }
  faces_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Mesh.faces)
}
inline void Mesh::set_faces(const char* value) {
  set_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_ = new ::std::string;
  }
  faces_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Mesh.faces)
}
inline void Mesh::set_faces(const void* value, size_t size) {
  set_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_ = new ::std::string;
  }
  faces_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Mesh.faces)
}
inline ::std::string* Mesh::mutable_faces() {
  set_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Mesh.faces)
  return faces_;
}
inline ::std::string* Mesh::release_faces() {
  clear_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = faces_;
    faces_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mesh::set_allocated_faces(::std::string* faces) {
  if (faces_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete faces_;
  }
  if (faces) {
    set_has_faces();
    faces_ = faces;
  } else {
    clear_has_faces();
    faces_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Mesh.faces)
}

// optional bytes materialIndices = 4;
inline bool Mesh::has_materialindices() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mesh::set_has_materialindices() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mesh::clear_has_materialindices() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mesh::clear_materialindices() {
  if (materialindices_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    materialindices_->clear();
  }
  clear_has_materialindices();
}
inline const ::std::string& Mesh::materialindices() const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.materialIndices)
  return *materialindices_;
}
inline void Mesh::set_materialindices(const ::std::string& value) {
  set_has_materialindices();
  if (materialindices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    materialindices_ = new ::std::string;
  }
  materialindices_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Mesh.materialIndices)
}
inline void Mesh::set_materialindices(const char* value) {
  set_has_materialindices();
  if (materialindices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    materialindices_ = new ::std::string;
  }
  materialindices_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Mesh.materialIndices)
}
inline void Mesh::set_materialindices(const void* value, size_t size) {
  set_has_materialindices();
  if (materialindices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    materialindices_ = new ::std::string;
  }
  materialindices_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Mesh.materialIndices)
}
inline ::std::string* Mesh::mutable_materialindices() {
  set_has_materialindices();
  if (materialindices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    materialindices_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Mesh.materialIndices)
  return materialindices_;
}
inline ::std::string* Mesh::release_materialindices() {
  clear_has_materialindices();
  if (materialindices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = materialindices_;
    materialindices_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mesh::set_allocated_materialindices(::std::string* materialindices) {
  if (materialindices_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete materialindices_;
  }
  if (materialindices) {
    set_has_materialindices();
    materialindices_ = materialindices;
  } else {
    clear_has_materialindices();
    materialindices_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Mesh.materialIndices)
}

// repeated .modeldata.Material materials = 5;
inline int Mesh::materials_size() const {
  return materials_.size();
}
inline void Mesh::clear_materials() {
  materials_.Clear();
}
inline const ::modeldata::Material& Mesh::materials(int index) const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.materials)
  return materials_.Get(index);
}
inline ::modeldata::Material* Mesh::mutable_materials(int index) {
  // @@protoc_insertion_point(field_mutable:modeldata.Mesh.materials)
  return materials_.Mutable(index);
}
inline ::modeldata::Material* Mesh::add_materials() {
  // @@protoc_insertion_point(field_add:modeldata.Mesh.materials)
  return materials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Material >&
Mesh::materials() const {
  // @@protoc_insertion_point(field_list:modeldata.Mesh.materials)
  return materials_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeldata::Material >*
Mesh::mutable_materials() {
  // @@protoc_insertion_point(field_mutable_list:modeldata.Mesh.materials)
  return &materials_;
}

// -------------------------------------------------------------------

// Scene

// required .modeldata.Node rootNode = 1;
inline bool Scene::has_rootnode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scene::set_has_rootnode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scene::clear_has_rootnode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scene::clear_rootnode() {
  if (rootnode_ != NULL) rootnode_->::modeldata::Node::Clear();
  clear_has_rootnode();
}
inline const ::modeldata::Node& Scene::rootnode() const {
  // @@protoc_insertion_point(field_get:modeldata.Scene.rootNode)
  return rootnode_ != NULL ? *rootnode_ : *default_instance_->rootnode_;
}
inline ::modeldata::Node* Scene::mutable_rootnode() {
  set_has_rootnode();
  if (rootnode_ == NULL) rootnode_ = new ::modeldata::Node;
  // @@protoc_insertion_point(field_mutable:modeldata.Scene.rootNode)
  return rootnode_;
}
inline ::modeldata::Node* Scene::release_rootnode() {
  clear_has_rootnode();
  ::modeldata::Node* temp = rootnode_;
  rootnode_ = NULL;
  return temp;
}
inline void Scene::set_allocated_rootnode(::modeldata::Node* rootnode) {
  delete rootnode_;
  rootnode_ = rootnode;
  if (rootnode) {
    set_has_rootnode();
  } else {
    clear_has_rootnode();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Scene.rootNode)
}

// repeated .modeldata.Mesh meshes = 2;
inline int Scene::meshes_size() const {
  return meshes_.size();
}
inline void Scene::clear_meshes() {
  meshes_.Clear();
}
inline const ::modeldata::Mesh& Scene::meshes(int index) const {
  // @@protoc_insertion_point(field_get:modeldata.Scene.meshes)
  return meshes_.Get(index);
}
inline ::modeldata::Mesh* Scene::mutable_meshes(int index) {
  // @@protoc_insertion_point(field_mutable:modeldata.Scene.meshes)
  return meshes_.Mutable(index);
}
inline ::modeldata::Mesh* Scene::add_meshes() {
  // @@protoc_insertion_point(field_add:modeldata.Scene.meshes)
  return meshes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh >&
Scene::meshes() const {
  // @@protoc_insertion_point(field_list:modeldata.Scene.meshes)
  return meshes_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh >*
Scene::mutable_meshes() {
  // @@protoc_insertion_point(field_mutable_list:modeldata.Scene.meshes)
  return &meshes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace modeldata

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modeldata_2eproto__INCLUDED
