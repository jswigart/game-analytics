// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modeldata.proto

#ifndef PROTOBUF_modeldata_2eproto__INCLUDED
#define PROTOBUF_modeldata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace modeldata {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_modeldata_2eproto();
void protobuf_AssignDesc_modeldata_2eproto();
void protobuf_ShutdownFile_modeldata_2eproto();

class Vec3;
class Vec4;
class Euler;
class Matrix4;
class Node;
class Mesh;
class Material;
class Scene;

// ===================================================================

class Vec3 : public ::google::protobuf::Message {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();

  void Swap(Vec3* other);

  // implements Message ----------------------------------------------

  Vec3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:modeldata.Vec3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Vec3* default_instance_;
};
// -------------------------------------------------------------------

class Vec4 : public ::google::protobuf::Message {
 public:
  Vec4();
  virtual ~Vec4();

  Vec4(const Vec4& from);

  inline Vec4& operator=(const Vec4& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec4& default_instance();

  void Swap(Vec4* other);

  // implements Message ----------------------------------------------

  Vec4* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec4& from);
  void MergeFrom(const Vec4& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // optional float w = 4 [default = 0];
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline float w() const;
  inline void set_w(float value);

  // @@protoc_insertion_point(class_scope:modeldata.Vec4)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Vec4* default_instance_;
};
// -------------------------------------------------------------------

class Euler : public ::google::protobuf::Message {
 public:
  Euler();
  virtual ~Euler();

  Euler(const Euler& from);

  inline Euler& operator=(const Euler& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Euler& default_instance();

  void Swap(Euler* other);

  // implements Message ----------------------------------------------

  Euler* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Euler& from);
  void MergeFrom(const Euler& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float heading = 1 [default = 0];
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 1;
  inline float heading() const;
  inline void set_heading(float value);

  // optional float pitch = 2 [default = 0];
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 2;
  inline float pitch() const;
  inline void set_pitch(float value);

  // optional float roll = 3 [default = 0];
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 3;
  inline float roll() const;
  inline void set_roll(float value);

  // @@protoc_insertion_point(class_scope:modeldata.Euler)
 private:
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float heading_;
  float pitch_;
  float roll_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Euler* default_instance_;
};
// -------------------------------------------------------------------

class Matrix4 : public ::google::protobuf::Message {
 public:
  Matrix4();
  virtual ~Matrix4();

  Matrix4(const Matrix4& from);

  inline Matrix4& operator=(const Matrix4& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Matrix4& default_instance();

  void Swap(Matrix4* other);

  // implements Message ----------------------------------------------

  Matrix4* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Matrix4& from);
  void MergeFrom(const Matrix4& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .modeldata.Vec4 row0 = 1;
  inline bool has_row0() const;
  inline void clear_row0();
  static const int kRow0FieldNumber = 1;
  inline const ::modeldata::Vec4& row0() const;
  inline ::modeldata::Vec4* mutable_row0();
  inline ::modeldata::Vec4* release_row0();
  inline void set_allocated_row0(::modeldata::Vec4* row0);

  // required .modeldata.Vec4 row1 = 2;
  inline bool has_row1() const;
  inline void clear_row1();
  static const int kRow1FieldNumber = 2;
  inline const ::modeldata::Vec4& row1() const;
  inline ::modeldata::Vec4* mutable_row1();
  inline ::modeldata::Vec4* release_row1();
  inline void set_allocated_row1(::modeldata::Vec4* row1);

  // required .modeldata.Vec4 row2 = 3;
  inline bool has_row2() const;
  inline void clear_row2();
  static const int kRow2FieldNumber = 3;
  inline const ::modeldata::Vec4& row2() const;
  inline ::modeldata::Vec4* mutable_row2();
  inline ::modeldata::Vec4* release_row2();
  inline void set_allocated_row2(::modeldata::Vec4* row2);

  // required .modeldata.Vec4 row3 = 4;
  inline bool has_row3() const;
  inline void clear_row3();
  static const int kRow3FieldNumber = 4;
  inline const ::modeldata::Vec4& row3() const;
  inline ::modeldata::Vec4* mutable_row3();
  inline ::modeldata::Vec4* release_row3();
  inline void set_allocated_row3(::modeldata::Vec4* row3);

  // @@protoc_insertion_point(class_scope:modeldata.Matrix4)
 private:
  inline void set_has_row0();
  inline void clear_has_row0();
  inline void set_has_row1();
  inline void clear_has_row1();
  inline void set_has_row2();
  inline void clear_has_row2();
  inline void set_has_row3();
  inline void clear_has_row3();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::modeldata::Vec4* row0_;
  ::modeldata::Vec4* row1_;
  ::modeldata::Vec4* row2_;
  ::modeldata::Vec4* row3_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Matrix4* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .modeldata.Matrix4 transformation = 2;
  inline bool has_transformation() const;
  inline void clear_transformation();
  static const int kTransformationFieldNumber = 2;
  inline const ::modeldata::Matrix4& transformation() const;
  inline ::modeldata::Matrix4* mutable_transformation();
  inline ::modeldata::Matrix4* release_transformation();
  inline void set_allocated_transformation(::modeldata::Matrix4* transformation);

  // optional uint32 subModel = 3;
  inline bool has_submodel() const;
  inline void clear_submodel();
  static const int kSubModelFieldNumber = 3;
  inline ::google::protobuf::uint32 submodel() const;
  inline void set_submodel(::google::protobuf::uint32 value);

  // repeated .modeldata.Node children = 4;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 4;
  inline const ::modeldata::Node& children(int index) const;
  inline ::modeldata::Node* mutable_children(int index);
  inline ::modeldata::Node* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Node >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeldata::Node >*
      mutable_children();

  // repeated uint32 meshIndex = 5;
  inline int meshindex_size() const;
  inline void clear_meshindex();
  static const int kMeshIndexFieldNumber = 5;
  inline ::google::protobuf::uint32 meshindex(int index) const;
  inline void set_meshindex(int index, ::google::protobuf::uint32 value);
  inline void add_meshindex(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      meshindex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_meshindex();

  // @@protoc_insertion_point(class_scope:modeldata.Node)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_transformation();
  inline void clear_has_transformation();
  inline void set_has_submodel();
  inline void clear_has_submodel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::modeldata::Matrix4* transformation_;
  ::google::protobuf::RepeatedPtrField< ::modeldata::Node > children_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > meshindex_;
  ::google::protobuf::uint32 submodel_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class Mesh : public ::google::protobuf::Message {
 public:
  Mesh();
  virtual ~Mesh();

  Mesh(const Mesh& from);

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Mesh& default_instance();

  void Swap(Mesh* other);

  // implements Message ----------------------------------------------

  Mesh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 materialIndex = 2;
  inline bool has_materialindex() const;
  inline void clear_materialindex();
  static const int kMaterialIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 materialindex() const;
  inline void set_materialindex(::google::protobuf::uint32 value);

  // optional bytes vertices = 3;
  inline bool has_vertices() const;
  inline void clear_vertices();
  static const int kVerticesFieldNumber = 3;
  inline const ::std::string& vertices() const;
  inline void set_vertices(const ::std::string& value);
  inline void set_vertices(const char* value);
  inline void set_vertices(const void* value, size_t size);
  inline ::std::string* mutable_vertices();
  inline ::std::string* release_vertices();
  inline void set_allocated_vertices(::std::string* vertices);

  // optional bytes faces = 4;
  inline bool has_faces() const;
  inline void clear_faces();
  static const int kFacesFieldNumber = 4;
  inline const ::std::string& faces() const;
  inline void set_faces(const ::std::string& value);
  inline void set_faces(const char* value);
  inline void set_faces(const void* value, size_t size);
  inline ::std::string* mutable_faces();
  inline ::std::string* release_faces();
  inline void set_allocated_faces(::std::string* faces);

  // optional bool externalRef = 5;
  inline bool has_externalref() const;
  inline void clear_externalref();
  static const int kExternalRefFieldNumber = 5;
  inline bool externalref() const;
  inline void set_externalref(bool value);

  // @@protoc_insertion_point(class_scope:modeldata.Mesh)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_materialindex();
  inline void clear_has_materialindex();
  inline void set_has_vertices();
  inline void clear_has_vertices();
  inline void set_has_faces();
  inline void clear_has_faces();
  inline void set_has_externalref();
  inline void clear_has_externalref();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* vertices_;
  ::google::protobuf::uint32 materialindex_;
  bool externalref_;
  ::std::string* faces_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Mesh* default_instance_;
};
// -------------------------------------------------------------------

class Material : public ::google::protobuf::Message {
 public:
  Material();
  virtual ~Material();

  Material(const Material& from);

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Material& default_instance();

  void Swap(Material* other);

  // implements Message ----------------------------------------------

  Material* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 contents = 2;
  inline bool has_contents() const;
  inline void clear_contents();
  static const int kContentsFieldNumber = 2;
  inline ::google::protobuf::uint32 contents() const;
  inline void set_contents(::google::protobuf::uint32 value);

  // optional uint32 surfaceFlags = 3;
  inline bool has_surfaceflags() const;
  inline void clear_surfaceflags();
  static const int kSurfaceFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 surfaceflags() const;
  inline void set_surfaceflags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:modeldata.Material)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_contents();
  inline void clear_has_contents();
  inline void set_has_surfaceflags();
  inline void clear_has_surfaceflags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::uint32 contents_;
  ::google::protobuf::uint32 surfaceflags_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Material* default_instance_;
};
// -------------------------------------------------------------------

class Scene : public ::google::protobuf::Message {
 public:
  Scene();
  virtual ~Scene();

  Scene(const Scene& from);

  inline Scene& operator=(const Scene& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scene& default_instance();

  void Swap(Scene* other);

  // implements Message ----------------------------------------------

  Scene* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Scene& from);
  void MergeFrom(const Scene& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .modeldata.Node rootNode = 1;
  inline bool has_rootnode() const;
  inline void clear_rootnode();
  static const int kRootNodeFieldNumber = 1;
  inline const ::modeldata::Node& rootnode() const;
  inline ::modeldata::Node* mutable_rootnode();
  inline ::modeldata::Node* release_rootnode();
  inline void set_allocated_rootnode(::modeldata::Node* rootnode);

  // repeated .modeldata.Mesh meshes = 2;
  inline int meshes_size() const;
  inline void clear_meshes();
  static const int kMeshesFieldNumber = 2;
  inline const ::modeldata::Mesh& meshes(int index) const;
  inline ::modeldata::Mesh* mutable_meshes(int index);
  inline ::modeldata::Mesh* add_meshes();
  inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh >&
      meshes() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh >*
      mutable_meshes();

  // repeated .modeldata.Material materials = 3;
  inline int materials_size() const;
  inline void clear_materials();
  static const int kMaterialsFieldNumber = 3;
  inline const ::modeldata::Material& materials(int index) const;
  inline ::modeldata::Material* mutable_materials(int index);
  inline ::modeldata::Material* add_materials();
  inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Material >&
      materials() const;
  inline ::google::protobuf::RepeatedPtrField< ::modeldata::Material >*
      mutable_materials();

  // @@protoc_insertion_point(class_scope:modeldata.Scene)
 private:
  inline void set_has_rootnode();
  inline void clear_has_rootnode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::modeldata::Node* rootnode_;
  ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh > meshes_;
  ::google::protobuf::RepeatedPtrField< ::modeldata::Material > materials_;
  friend void  protobuf_AddDesc_modeldata_2eproto();
  friend void protobuf_AssignDesc_modeldata_2eproto();
  friend void protobuf_ShutdownFile_modeldata_2eproto();

  void InitAsDefaultInstance();
  static Scene* default_instance_;
};
// ===================================================================


// ===================================================================

// Vec3

// optional float x = 1 [default = 0];
inline bool Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec3.x)
  return x_;
}
inline void Vec3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec3.x)
}

// optional float y = 2 [default = 0];
inline bool Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec3.y)
  return y_;
}
inline void Vec3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec3.y)
}

// optional float z = 3 [default = 0];
inline bool Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec3.z)
  return z_;
}
inline void Vec3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec3.z)
}

// -------------------------------------------------------------------

// Vec4

// optional float x = 1 [default = 0];
inline bool Vec4::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec4::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec4::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec4::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec4::x() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec4.x)
  return x_;
}
inline void Vec4::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec4.x)
}

// optional float y = 2 [default = 0];
inline bool Vec4::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec4::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec4::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec4::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec4::y() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec4.y)
  return y_;
}
inline void Vec4::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec4.y)
}

// optional float z = 3 [default = 0];
inline bool Vec4::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec4::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec4::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec4::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vec4::z() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec4.z)
  return z_;
}
inline void Vec4::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec4.z)
}

// optional float w = 4 [default = 0];
inline bool Vec4::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Vec4::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Vec4::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Vec4::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float Vec4::w() const {
  // @@protoc_insertion_point(field_get:modeldata.Vec4.w)
  return w_;
}
inline void Vec4::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Vec4.w)
}

// -------------------------------------------------------------------

// Euler

// optional float heading = 1 [default = 0];
inline bool Euler::has_heading() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Euler::set_has_heading() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Euler::clear_has_heading() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Euler::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float Euler::heading() const {
  // @@protoc_insertion_point(field_get:modeldata.Euler.heading)
  return heading_;
}
inline void Euler::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Euler.heading)
}

// optional float pitch = 2 [default = 0];
inline bool Euler::has_pitch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Euler::set_has_pitch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Euler::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Euler::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float Euler::pitch() const {
  // @@protoc_insertion_point(field_get:modeldata.Euler.pitch)
  return pitch_;
}
inline void Euler::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Euler.pitch)
}

// optional float roll = 3 [default = 0];
inline bool Euler::has_roll() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Euler::set_has_roll() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Euler::clear_has_roll() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Euler::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float Euler::roll() const {
  // @@protoc_insertion_point(field_get:modeldata.Euler.roll)
  return roll_;
}
inline void Euler::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Euler.roll)
}

// -------------------------------------------------------------------

// Matrix4

// required .modeldata.Vec4 row0 = 1;
inline bool Matrix4::has_row0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Matrix4::set_has_row0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Matrix4::clear_has_row0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Matrix4::clear_row0() {
  if (row0_ != NULL) row0_->::modeldata::Vec4::Clear();
  clear_has_row0();
}
inline const ::modeldata::Vec4& Matrix4::row0() const {
  // @@protoc_insertion_point(field_get:modeldata.Matrix4.row0)
  return row0_ != NULL ? *row0_ : *default_instance_->row0_;
}
inline ::modeldata::Vec4* Matrix4::mutable_row0() {
  set_has_row0();
  if (row0_ == NULL) row0_ = new ::modeldata::Vec4;
  // @@protoc_insertion_point(field_mutable:modeldata.Matrix4.row0)
  return row0_;
}
inline ::modeldata::Vec4* Matrix4::release_row0() {
  clear_has_row0();
  ::modeldata::Vec4* temp = row0_;
  row0_ = NULL;
  return temp;
}
inline void Matrix4::set_allocated_row0(::modeldata::Vec4* row0) {
  delete row0_;
  row0_ = row0;
  if (row0) {
    set_has_row0();
  } else {
    clear_has_row0();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Matrix4.row0)
}

// required .modeldata.Vec4 row1 = 2;
inline bool Matrix4::has_row1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Matrix4::set_has_row1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Matrix4::clear_has_row1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Matrix4::clear_row1() {
  if (row1_ != NULL) row1_->::modeldata::Vec4::Clear();
  clear_has_row1();
}
inline const ::modeldata::Vec4& Matrix4::row1() const {
  // @@protoc_insertion_point(field_get:modeldata.Matrix4.row1)
  return row1_ != NULL ? *row1_ : *default_instance_->row1_;
}
inline ::modeldata::Vec4* Matrix4::mutable_row1() {
  set_has_row1();
  if (row1_ == NULL) row1_ = new ::modeldata::Vec4;
  // @@protoc_insertion_point(field_mutable:modeldata.Matrix4.row1)
  return row1_;
}
inline ::modeldata::Vec4* Matrix4::release_row1() {
  clear_has_row1();
  ::modeldata::Vec4* temp = row1_;
  row1_ = NULL;
  return temp;
}
inline void Matrix4::set_allocated_row1(::modeldata::Vec4* row1) {
  delete row1_;
  row1_ = row1;
  if (row1) {
    set_has_row1();
  } else {
    clear_has_row1();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Matrix4.row1)
}

// required .modeldata.Vec4 row2 = 3;
inline bool Matrix4::has_row2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Matrix4::set_has_row2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Matrix4::clear_has_row2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Matrix4::clear_row2() {
  if (row2_ != NULL) row2_->::modeldata::Vec4::Clear();
  clear_has_row2();
}
inline const ::modeldata::Vec4& Matrix4::row2() const {
  // @@protoc_insertion_point(field_get:modeldata.Matrix4.row2)
  return row2_ != NULL ? *row2_ : *default_instance_->row2_;
}
inline ::modeldata::Vec4* Matrix4::mutable_row2() {
  set_has_row2();
  if (row2_ == NULL) row2_ = new ::modeldata::Vec4;
  // @@protoc_insertion_point(field_mutable:modeldata.Matrix4.row2)
  return row2_;
}
inline ::modeldata::Vec4* Matrix4::release_row2() {
  clear_has_row2();
  ::modeldata::Vec4* temp = row2_;
  row2_ = NULL;
  return temp;
}
inline void Matrix4::set_allocated_row2(::modeldata::Vec4* row2) {
  delete row2_;
  row2_ = row2;
  if (row2) {
    set_has_row2();
  } else {
    clear_has_row2();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Matrix4.row2)
}

// required .modeldata.Vec4 row3 = 4;
inline bool Matrix4::has_row3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Matrix4::set_has_row3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Matrix4::clear_has_row3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Matrix4::clear_row3() {
  if (row3_ != NULL) row3_->::modeldata::Vec4::Clear();
  clear_has_row3();
}
inline const ::modeldata::Vec4& Matrix4::row3() const {
  // @@protoc_insertion_point(field_get:modeldata.Matrix4.row3)
  return row3_ != NULL ? *row3_ : *default_instance_->row3_;
}
inline ::modeldata::Vec4* Matrix4::mutable_row3() {
  set_has_row3();
  if (row3_ == NULL) row3_ = new ::modeldata::Vec4;
  // @@protoc_insertion_point(field_mutable:modeldata.Matrix4.row3)
  return row3_;
}
inline ::modeldata::Vec4* Matrix4::release_row3() {
  clear_has_row3();
  ::modeldata::Vec4* temp = row3_;
  row3_ = NULL;
  return temp;
}
inline void Matrix4::set_allocated_row3(::modeldata::Vec4* row3) {
  delete row3_;
  row3_ = row3;
  if (row3) {
    set_has_row3();
  } else {
    clear_has_row3();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Matrix4.row3)
}

// -------------------------------------------------------------------

// Node

// optional string name = 1;
inline bool Node::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Node::name() const {
  // @@protoc_insertion_point(field_get:modeldata.Node.name)
  return *name_;
}
inline void Node::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Node.name)
}
inline void Node::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Node.name)
}
inline void Node::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Node.name)
}
inline ::std::string* Node::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Node.name)
  return name_;
}
inline ::std::string* Node::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Node::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Node.name)
}

// optional .modeldata.Matrix4 transformation = 2;
inline bool Node::has_transformation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_transformation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_transformation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_transformation() {
  if (transformation_ != NULL) transformation_->::modeldata::Matrix4::Clear();
  clear_has_transformation();
}
inline const ::modeldata::Matrix4& Node::transformation() const {
  // @@protoc_insertion_point(field_get:modeldata.Node.transformation)
  return transformation_ != NULL ? *transformation_ : *default_instance_->transformation_;
}
inline ::modeldata::Matrix4* Node::mutable_transformation() {
  set_has_transformation();
  if (transformation_ == NULL) transformation_ = new ::modeldata::Matrix4;
  // @@protoc_insertion_point(field_mutable:modeldata.Node.transformation)
  return transformation_;
}
inline ::modeldata::Matrix4* Node::release_transformation() {
  clear_has_transformation();
  ::modeldata::Matrix4* temp = transformation_;
  transformation_ = NULL;
  return temp;
}
inline void Node::set_allocated_transformation(::modeldata::Matrix4* transformation) {
  delete transformation_;
  transformation_ = transformation;
  if (transformation) {
    set_has_transformation();
  } else {
    clear_has_transformation();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Node.transformation)
}

// optional uint32 subModel = 3;
inline bool Node::has_submodel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_submodel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_submodel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_submodel() {
  submodel_ = 0u;
  clear_has_submodel();
}
inline ::google::protobuf::uint32 Node::submodel() const {
  // @@protoc_insertion_point(field_get:modeldata.Node.subModel)
  return submodel_;
}
inline void Node::set_submodel(::google::protobuf::uint32 value) {
  set_has_submodel();
  submodel_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Node.subModel)
}

// repeated .modeldata.Node children = 4;
inline int Node::children_size() const {
  return children_.size();
}
inline void Node::clear_children() {
  children_.Clear();
}
inline const ::modeldata::Node& Node::children(int index) const {
  // @@protoc_insertion_point(field_get:modeldata.Node.children)
  return children_.Get(index);
}
inline ::modeldata::Node* Node::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:modeldata.Node.children)
  return children_.Mutable(index);
}
inline ::modeldata::Node* Node::add_children() {
  // @@protoc_insertion_point(field_add:modeldata.Node.children)
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Node >&
Node::children() const {
  // @@protoc_insertion_point(field_list:modeldata.Node.children)
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeldata::Node >*
Node::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:modeldata.Node.children)
  return &children_;
}

// repeated uint32 meshIndex = 5;
inline int Node::meshindex_size() const {
  return meshindex_.size();
}
inline void Node::clear_meshindex() {
  meshindex_.Clear();
}
inline ::google::protobuf::uint32 Node::meshindex(int index) const {
  // @@protoc_insertion_point(field_get:modeldata.Node.meshIndex)
  return meshindex_.Get(index);
}
inline void Node::set_meshindex(int index, ::google::protobuf::uint32 value) {
  meshindex_.Set(index, value);
  // @@protoc_insertion_point(field_set:modeldata.Node.meshIndex)
}
inline void Node::add_meshindex(::google::protobuf::uint32 value) {
  meshindex_.Add(value);
  // @@protoc_insertion_point(field_add:modeldata.Node.meshIndex)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Node::meshindex() const {
  // @@protoc_insertion_point(field_list:modeldata.Node.meshIndex)
  return meshindex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Node::mutable_meshindex() {
  // @@protoc_insertion_point(field_mutable_list:modeldata.Node.meshIndex)
  return &meshindex_;
}

// -------------------------------------------------------------------

// Mesh

// optional string name = 1;
inline bool Mesh::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Mesh::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Mesh::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Mesh::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Mesh::name() const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.name)
  return *name_;
}
inline void Mesh::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Mesh.name)
}
inline void Mesh::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Mesh.name)
}
inline void Mesh::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Mesh.name)
}
inline ::std::string* Mesh::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Mesh.name)
  return name_;
}
inline ::std::string* Mesh::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mesh::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Mesh.name)
}

// required uint32 materialIndex = 2;
inline bool Mesh::has_materialindex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Mesh::set_has_materialindex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Mesh::clear_has_materialindex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Mesh::clear_materialindex() {
  materialindex_ = 0u;
  clear_has_materialindex();
}
inline ::google::protobuf::uint32 Mesh::materialindex() const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.materialIndex)
  return materialindex_;
}
inline void Mesh::set_materialindex(::google::protobuf::uint32 value) {
  set_has_materialindex();
  materialindex_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Mesh.materialIndex)
}

// optional bytes vertices = 3;
inline bool Mesh::has_vertices() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Mesh::set_has_vertices() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Mesh::clear_has_vertices() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Mesh::clear_vertices() {
  if (vertices_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_->clear();
  }
  clear_has_vertices();
}
inline const ::std::string& Mesh::vertices() const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.vertices)
  return *vertices_;
}
inline void Mesh::set_vertices(const ::std::string& value) {
  set_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_ = new ::std::string;
  }
  vertices_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Mesh.vertices)
}
inline void Mesh::set_vertices(const char* value) {
  set_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_ = new ::std::string;
  }
  vertices_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Mesh.vertices)
}
inline void Mesh::set_vertices(const void* value, size_t size) {
  set_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_ = new ::std::string;
  }
  vertices_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Mesh.vertices)
}
inline ::std::string* Mesh::mutable_vertices() {
  set_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    vertices_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Mesh.vertices)
  return vertices_;
}
inline ::std::string* Mesh::release_vertices() {
  clear_has_vertices();
  if (vertices_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = vertices_;
    vertices_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mesh::set_allocated_vertices(::std::string* vertices) {
  if (vertices_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete vertices_;
  }
  if (vertices) {
    set_has_vertices();
    vertices_ = vertices;
  } else {
    clear_has_vertices();
    vertices_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Mesh.vertices)
}

// optional bytes faces = 4;
inline bool Mesh::has_faces() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Mesh::set_has_faces() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Mesh::clear_has_faces() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Mesh::clear_faces() {
  if (faces_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_->clear();
  }
  clear_has_faces();
}
inline const ::std::string& Mesh::faces() const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.faces)
  return *faces_;
}
inline void Mesh::set_faces(const ::std::string& value) {
  set_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_ = new ::std::string;
  }
  faces_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Mesh.faces)
}
inline void Mesh::set_faces(const char* value) {
  set_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_ = new ::std::string;
  }
  faces_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Mesh.faces)
}
inline void Mesh::set_faces(const void* value, size_t size) {
  set_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_ = new ::std::string;
  }
  faces_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Mesh.faces)
}
inline ::std::string* Mesh::mutable_faces() {
  set_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    faces_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Mesh.faces)
  return faces_;
}
inline ::std::string* Mesh::release_faces() {
  clear_has_faces();
  if (faces_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = faces_;
    faces_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Mesh::set_allocated_faces(::std::string* faces) {
  if (faces_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete faces_;
  }
  if (faces) {
    set_has_faces();
    faces_ = faces;
  } else {
    clear_has_faces();
    faces_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Mesh.faces)
}

// optional bool externalRef = 5;
inline bool Mesh::has_externalref() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Mesh::set_has_externalref() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Mesh::clear_has_externalref() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Mesh::clear_externalref() {
  externalref_ = false;
  clear_has_externalref();
}
inline bool Mesh::externalref() const {
  // @@protoc_insertion_point(field_get:modeldata.Mesh.externalRef)
  return externalref_;
}
inline void Mesh::set_externalref(bool value) {
  set_has_externalref();
  externalref_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Mesh.externalRef)
}

// -------------------------------------------------------------------

// Material

// required string name = 1;
inline bool Material::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Material::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Material::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Material::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Material::name() const {
  // @@protoc_insertion_point(field_get:modeldata.Material.name)
  return *name_;
}
inline void Material::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:modeldata.Material.name)
}
inline void Material::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:modeldata.Material.name)
}
inline void Material::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:modeldata.Material.name)
}
inline ::std::string* Material::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:modeldata.Material.name)
  return name_;
}
inline ::std::string* Material::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Material::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Material.name)
}

// optional uint32 contents = 2;
inline bool Material::has_contents() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Material::set_has_contents() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Material::clear_has_contents() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Material::clear_contents() {
  contents_ = 0u;
  clear_has_contents();
}
inline ::google::protobuf::uint32 Material::contents() const {
  // @@protoc_insertion_point(field_get:modeldata.Material.contents)
  return contents_;
}
inline void Material::set_contents(::google::protobuf::uint32 value) {
  set_has_contents();
  contents_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Material.contents)
}

// optional uint32 surfaceFlags = 3;
inline bool Material::has_surfaceflags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Material::set_has_surfaceflags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Material::clear_has_surfaceflags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Material::clear_surfaceflags() {
  surfaceflags_ = 0u;
  clear_has_surfaceflags();
}
inline ::google::protobuf::uint32 Material::surfaceflags() const {
  // @@protoc_insertion_point(field_get:modeldata.Material.surfaceFlags)
  return surfaceflags_;
}
inline void Material::set_surfaceflags(::google::protobuf::uint32 value) {
  set_has_surfaceflags();
  surfaceflags_ = value;
  // @@protoc_insertion_point(field_set:modeldata.Material.surfaceFlags)
}

// -------------------------------------------------------------------

// Scene

// required .modeldata.Node rootNode = 1;
inline bool Scene::has_rootnode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scene::set_has_rootnode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scene::clear_has_rootnode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scene::clear_rootnode() {
  if (rootnode_ != NULL) rootnode_->::modeldata::Node::Clear();
  clear_has_rootnode();
}
inline const ::modeldata::Node& Scene::rootnode() const {
  // @@protoc_insertion_point(field_get:modeldata.Scene.rootNode)
  return rootnode_ != NULL ? *rootnode_ : *default_instance_->rootnode_;
}
inline ::modeldata::Node* Scene::mutable_rootnode() {
  set_has_rootnode();
  if (rootnode_ == NULL) rootnode_ = new ::modeldata::Node;
  // @@protoc_insertion_point(field_mutable:modeldata.Scene.rootNode)
  return rootnode_;
}
inline ::modeldata::Node* Scene::release_rootnode() {
  clear_has_rootnode();
  ::modeldata::Node* temp = rootnode_;
  rootnode_ = NULL;
  return temp;
}
inline void Scene::set_allocated_rootnode(::modeldata::Node* rootnode) {
  delete rootnode_;
  rootnode_ = rootnode;
  if (rootnode) {
    set_has_rootnode();
  } else {
    clear_has_rootnode();
  }
  // @@protoc_insertion_point(field_set_allocated:modeldata.Scene.rootNode)
}

// repeated .modeldata.Mesh meshes = 2;
inline int Scene::meshes_size() const {
  return meshes_.size();
}
inline void Scene::clear_meshes() {
  meshes_.Clear();
}
inline const ::modeldata::Mesh& Scene::meshes(int index) const {
  // @@protoc_insertion_point(field_get:modeldata.Scene.meshes)
  return meshes_.Get(index);
}
inline ::modeldata::Mesh* Scene::mutable_meshes(int index) {
  // @@protoc_insertion_point(field_mutable:modeldata.Scene.meshes)
  return meshes_.Mutable(index);
}
inline ::modeldata::Mesh* Scene::add_meshes() {
  // @@protoc_insertion_point(field_add:modeldata.Scene.meshes)
  return meshes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh >&
Scene::meshes() const {
  // @@protoc_insertion_point(field_list:modeldata.Scene.meshes)
  return meshes_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeldata::Mesh >*
Scene::mutable_meshes() {
  // @@protoc_insertion_point(field_mutable_list:modeldata.Scene.meshes)
  return &meshes_;
}

// repeated .modeldata.Material materials = 3;
inline int Scene::materials_size() const {
  return materials_.size();
}
inline void Scene::clear_materials() {
  materials_.Clear();
}
inline const ::modeldata::Material& Scene::materials(int index) const {
  // @@protoc_insertion_point(field_get:modeldata.Scene.materials)
  return materials_.Get(index);
}
inline ::modeldata::Material* Scene::mutable_materials(int index) {
  // @@protoc_insertion_point(field_mutable:modeldata.Scene.materials)
  return materials_.Mutable(index);
}
inline ::modeldata::Material* Scene::add_materials() {
  // @@protoc_insertion_point(field_add:modeldata.Scene.materials)
  return materials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::modeldata::Material >&
Scene::materials() const {
  // @@protoc_insertion_point(field_list:modeldata.Scene.materials)
  return materials_;
}
inline ::google::protobuf::RepeatedPtrField< ::modeldata::Material >*
Scene::mutable_materials() {
  // @@protoc_insertion_point(field_mutable_list:modeldata.Scene.materials)
  return &materials_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace modeldata

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modeldata_2eproto__INCLUDED
