// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: analytics.proto

#ifndef PROTOBUF_analytics_2eproto__INCLUDED
#define PROTOBUF_analytics_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "modeldata.pb.h"
// @@protoc_insertion_point(includes)

namespace Analytics {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_analytics_2eproto();
void protobuf_AssignDesc_analytics_2eproto();
void protobuf_ShutdownFile_analytics_2eproto();

class SystemClientInfo;
class SystemNavNotFound;
class SystemNavAutoDownloaded;
class SystemAssert;
class SystemCrash;
class SystemModelData;
class GameEntityInfo;
class GameEntityList;
class GameWeaponFired;
class GameDeath;
class GameTookDamage;
class GameNavigationStuck;
class MessageUnion;

enum Compression {
  Compression_None = 0,
  Compression_FastLZ = 1
};
bool Compression_IsValid(int value);
const Compression Compression_MIN = Compression_None;
const Compression Compression_MAX = Compression_FastLZ;
const int Compression_ARRAYSIZE = Compression_MAX + 1;

const ::google::protobuf::EnumDescriptor* Compression_descriptor();
inline const ::std::string& Compression_Name(Compression value) {
  return ::google::protobuf::internal::NameOfEnum(
    Compression_descriptor(), value);
}
inline bool Compression_Parse(
    const ::std::string& name, Compression* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Compression>(
    Compression_descriptor(), name, value);
}
// ===================================================================

class SystemClientInfo : public ::google::protobuf::Message {
 public:
  SystemClientInfo();
  virtual ~SystemClientInfo();

  SystemClientInfo(const SystemClientInfo& from);

  inline SystemClientInfo& operator=(const SystemClientInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemClientInfo& default_instance();

  void Swap(SystemClientInfo* other);

  // implements Message ----------------------------------------------

  SystemClientInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemClientInfo& from);
  void MergeFrom(const SystemClientInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline void set_userid(const char* value, size_t size);
  inline ::std::string* mutable_userid();
  inline ::std::string* release_userid();
  inline void set_allocated_userid(::std::string* userid);

  // required string mapId = 2;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapIdFieldNumber = 2;
  inline const ::std::string& mapid() const;
  inline void set_mapid(const ::std::string& value);
  inline void set_mapid(const char* value);
  inline void set_mapid(const char* value, size_t size);
  inline ::std::string* mutable_mapid();
  inline ::std::string* release_mapid();
  inline void set_allocated_mapid(::std::string* mapid);

  // required string enumClassId = 3;
  inline bool has_enumclassid() const;
  inline void clear_enumclassid();
  static const int kEnumClassIdFieldNumber = 3;
  inline const ::std::string& enumclassid() const;
  inline void set_enumclassid(const ::std::string& value);
  inline void set_enumclassid(const char* value);
  inline void set_enumclassid(const char* value, size_t size);
  inline ::std::string* mutable_enumclassid();
  inline ::std::string* release_enumclassid();
  inline void set_allocated_enumclassid(::std::string* enumclassid);

  // required string enumWeaponId = 4;
  inline bool has_enumweaponid() const;
  inline void clear_enumweaponid();
  static const int kEnumWeaponIdFieldNumber = 4;
  inline const ::std::string& enumweaponid() const;
  inline void set_enumweaponid(const ::std::string& value);
  inline void set_enumweaponid(const char* value);
  inline void set_enumweaponid(const char* value, size_t size);
  inline ::std::string* mutable_enumweaponid();
  inline ::std::string* release_enumweaponid();
  inline void set_allocated_enumweaponid(::std::string* enumweaponid);

  // @@protoc_insertion_point(class_scope:Analytics.SystemClientInfo)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_enumclassid();
  inline void clear_has_enumclassid();
  inline void set_has_enumweaponid();
  inline void clear_has_enumweaponid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* userid_;
  ::std::string* mapid_;
  ::std::string* enumclassid_;
  ::std::string* enumweaponid_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemClientInfo* default_instance_;
};
// -------------------------------------------------------------------

class SystemNavNotFound : public ::google::protobuf::Message {
 public:
  SystemNavNotFound();
  virtual ~SystemNavNotFound();

  SystemNavNotFound(const SystemNavNotFound& from);

  inline SystemNavNotFound& operator=(const SystemNavNotFound& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemNavNotFound& default_instance();

  void Swap(SystemNavNotFound* other);

  // implements Message ----------------------------------------------

  SystemNavNotFound* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemNavNotFound& from);
  void MergeFrom(const SystemNavNotFound& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mapName = 1;
  inline bool has_mapname() const;
  inline void clear_mapname();
  static const int kMapNameFieldNumber = 1;
  inline const ::std::string& mapname() const;
  inline void set_mapname(const ::std::string& value);
  inline void set_mapname(const char* value);
  inline void set_mapname(const char* value, size_t size);
  inline ::std::string* mutable_mapname();
  inline ::std::string* release_mapname();
  inline void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Analytics.SystemNavNotFound)
 private:
  inline void set_has_mapname();
  inline void clear_has_mapname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mapname_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemNavNotFound* default_instance_;
};
// -------------------------------------------------------------------

class SystemNavAutoDownloaded : public ::google::protobuf::Message {
 public:
  SystemNavAutoDownloaded();
  virtual ~SystemNavAutoDownloaded();

  SystemNavAutoDownloaded(const SystemNavAutoDownloaded& from);

  inline SystemNavAutoDownloaded& operator=(const SystemNavAutoDownloaded& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemNavAutoDownloaded& default_instance();

  void Swap(SystemNavAutoDownloaded* other);

  // implements Message ----------------------------------------------

  SystemNavAutoDownloaded* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemNavAutoDownloaded& from);
  void MergeFrom(const SystemNavAutoDownloaded& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mapName = 1;
  inline bool has_mapname() const;
  inline void clear_mapname();
  static const int kMapNameFieldNumber = 1;
  inline const ::std::string& mapname() const;
  inline void set_mapname(const ::std::string& value);
  inline void set_mapname(const char* value);
  inline void set_mapname(const char* value, size_t size);
  inline ::std::string* mutable_mapname();
  inline ::std::string* release_mapname();
  inline void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Analytics.SystemNavAutoDownloaded)
 private:
  inline void set_has_mapname();
  inline void clear_has_mapname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mapname_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemNavAutoDownloaded* default_instance_;
};
// -------------------------------------------------------------------

class SystemAssert : public ::google::protobuf::Message {
 public:
  SystemAssert();
  virtual ~SystemAssert();

  SystemAssert(const SystemAssert& from);

  inline SystemAssert& operator=(const SystemAssert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemAssert& default_instance();

  void Swap(SystemAssert* other);

  // implements Message ----------------------------------------------

  SystemAssert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemAssert& from);
  void MergeFrom(const SystemAssert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string condition = 1;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 1;
  inline const ::std::string& condition() const;
  inline void set_condition(const ::std::string& value);
  inline void set_condition(const char* value);
  inline void set_condition(const char* value, size_t size);
  inline ::std::string* mutable_condition();
  inline ::std::string* release_condition();
  inline void set_allocated_condition(::std::string* condition);

  // optional string file = 2;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 2;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const char* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  inline void set_allocated_file(::std::string* file);

  // optional int32 line = 3;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 3;
  inline ::google::protobuf::int32 line() const;
  inline void set_line(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.SystemAssert)
 private:
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_line();
  inline void clear_has_line();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* condition_;
  ::std::string* file_;
  ::google::protobuf::int32 line_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemAssert* default_instance_;
};
// -------------------------------------------------------------------

class SystemCrash : public ::google::protobuf::Message {
 public:
  SystemCrash();
  virtual ~SystemCrash();

  SystemCrash(const SystemCrash& from);

  inline SystemCrash& operator=(const SystemCrash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemCrash& default_instance();

  void Swap(SystemCrash* other);

  // implements Message ----------------------------------------------

  SystemCrash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemCrash& from);
  void MergeFrom(const SystemCrash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:Analytics.SystemCrash)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemCrash* default_instance_;
};
// -------------------------------------------------------------------

class SystemModelData : public ::google::protobuf::Message {
 public:
  SystemModelData();
  virtual ~SystemModelData();

  SystemModelData(const SystemModelData& from);

  inline SystemModelData& operator=(const SystemModelData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemModelData& default_instance();

  void Swap(SystemModelData* other);

  // implements Message ----------------------------------------------

  SystemModelData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemModelData& from);
  void MergeFrom(const SystemModelData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Analytics.Compression compressionType = 1 [default = Compression_None];
  inline bool has_compressiontype() const;
  inline void clear_compressiontype();
  static const int kCompressionTypeFieldNumber = 1;
  inline ::Analytics::Compression compressiontype() const;
  inline void set_compressiontype(::Analytics::Compression value);

  // required string modelName = 2;
  inline bool has_modelname() const;
  inline void clear_modelname();
  static const int kModelNameFieldNumber = 2;
  inline const ::std::string& modelname() const;
  inline void set_modelname(const ::std::string& value);
  inline void set_modelname(const char* value);
  inline void set_modelname(const char* value, size_t size);
  inline ::std::string* mutable_modelname();
  inline ::std::string* release_modelname();
  inline void set_allocated_modelname(::std::string* modelname);

  // required bytes modelBytes = 3;
  inline bool has_modelbytes() const;
  inline void clear_modelbytes();
  static const int kModelBytesFieldNumber = 3;
  inline const ::std::string& modelbytes() const;
  inline void set_modelbytes(const ::std::string& value);
  inline void set_modelbytes(const char* value);
  inline void set_modelbytes(const void* value, size_t size);
  inline ::std::string* mutable_modelbytes();
  inline ::std::string* release_modelbytes();
  inline void set_allocated_modelbytes(::std::string* modelbytes);

  // @@protoc_insertion_point(class_scope:Analytics.SystemModelData)
 private:
  inline void set_has_compressiontype();
  inline void clear_has_compressiontype();
  inline void set_has_modelname();
  inline void clear_has_modelname();
  inline void set_has_modelbytes();
  inline void clear_has_modelbytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* modelname_;
  ::std::string* modelbytes_;
  int compressiontype_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemModelData* default_instance_;
};
// -------------------------------------------------------------------

class GameEntityInfo : public ::google::protobuf::Message {
 public:
  GameEntityInfo();
  virtual ~GameEntityInfo();

  GameEntityInfo(const GameEntityInfo& from);

  inline GameEntityInfo& operator=(const GameEntityInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEntityInfo& default_instance();

  void Swap(GameEntityInfo* other);

  // implements Message ----------------------------------------------

  GameEntityInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEntityInfo& from);
  void MergeFrom(const GameEntityInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 entityId = 1;
  inline bool has_entityid() const;
  inline void clear_entityid();
  static const int kEntityIdFieldNumber = 1;
  inline ::google::protobuf::int32 entityid() const;
  inline void set_entityid(::google::protobuf::int32 value);

  // required int32 groupId = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // required int32 classId = 3;
  inline bool has_classid() const;
  inline void clear_classid();
  static const int kClassIdFieldNumber = 3;
  inline ::google::protobuf::int32 classid() const;
  inline void set_classid(::google::protobuf::int32 value);

  // required .modeldata.Vec3 position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline const ::modeldata::Vec3& position() const;
  inline ::modeldata::Vec3* mutable_position();
  inline ::modeldata::Vec3* release_position();
  inline void set_allocated_position(::modeldata::Vec3* position);

  // required .modeldata.Euler orient = 5;
  inline bool has_orient() const;
  inline void clear_orient();
  static const int kOrientFieldNumber = 5;
  inline const ::modeldata::Euler& orient() const;
  inline ::modeldata::Euler* mutable_orient();
  inline ::modeldata::Euler* release_orient();
  inline void set_allocated_orient(::modeldata::Euler* orient);

  // optional int32 quantity = 6;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 6;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);

  // optional int32 quantityMax = 7;
  inline bool has_quantitymax() const;
  inline void clear_quantitymax();
  static const int kQuantityMaxFieldNumber = 7;
  inline ::google::protobuf::int32 quantitymax() const;
  inline void set_quantitymax(::google::protobuf::int32 value);

  // optional int32 health = 8;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 8;
  inline ::google::protobuf::int32 health() const;
  inline void set_health(::google::protobuf::int32 value);

  // optional int32 healthMax = 9;
  inline bool has_healthmax() const;
  inline void clear_healthmax();
  static const int kHealthMaxFieldNumber = 9;
  inline ::google::protobuf::int32 healthmax() const;
  inline void set_healthmax(::google::protobuf::int32 value);

  // optional int32 armor = 10;
  inline bool has_armor() const;
  inline void clear_armor();
  static const int kArmorFieldNumber = 10;
  inline ::google::protobuf::int32 armor() const;
  inline void set_armor(::google::protobuf::int32 value);

  // optional int32 armoryMax = 11;
  inline bool has_armorymax() const;
  inline void clear_armorymax();
  static const int kArmoryMaxFieldNumber = 11;
  inline ::google::protobuf::int32 armorymax() const;
  inline void set_armorymax(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityInfo)
 private:
  inline void set_has_entityid();
  inline void clear_has_entityid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_classid();
  inline void clear_has_classid();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_orient();
  inline void clear_has_orient();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_quantitymax();
  inline void clear_has_quantitymax();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_healthmax();
  inline void clear_has_healthmax();
  inline void set_has_armor();
  inline void clear_has_armor();
  inline void set_has_armorymax();
  inline void clear_has_armorymax();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 entityid_;
  ::google::protobuf::int32 groupid_;
  ::modeldata::Vec3* position_;
  ::google::protobuf::int32 classid_;
  ::google::protobuf::int32 quantity_;
  ::modeldata::Euler* orient_;
  ::google::protobuf::int32 quantitymax_;
  ::google::protobuf::int32 health_;
  ::google::protobuf::int32 healthmax_;
  ::google::protobuf::int32 armor_;
  ::google::protobuf::int32 armorymax_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameEntityInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameEntityList : public ::google::protobuf::Message {
 public:
  GameEntityList();
  virtual ~GameEntityList();

  GameEntityList(const GameEntityList& from);

  inline GameEntityList& operator=(const GameEntityList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEntityList& default_instance();

  void Swap(GameEntityList* other);

  // implements Message ----------------------------------------------

  GameEntityList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEntityList& from);
  void MergeFrom(const GameEntityList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Analytics.GameEntityInfo entities = 1;
  inline int entities_size() const;
  inline void clear_entities();
  static const int kEntitiesFieldNumber = 1;
  inline const ::Analytics::GameEntityInfo& entities(int index) const;
  inline ::Analytics::GameEntityInfo* mutable_entities(int index);
  inline ::Analytics::GameEntityInfo* add_entities();
  inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >&
      entities() const;
  inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >*
      mutable_entities();

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo > entities_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameEntityList* default_instance_;
};
// -------------------------------------------------------------------

class GameWeaponFired : public ::google::protobuf::Message {
 public:
  GameWeaponFired();
  virtual ~GameWeaponFired();

  GameWeaponFired(const GameWeaponFired& from);

  inline GameWeaponFired& operator=(const GameWeaponFired& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameWeaponFired& default_instance();

  void Swap(GameWeaponFired* other);

  // implements Message ----------------------------------------------

  GameWeaponFired* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameWeaponFired& from);
  void MergeFrom(const GameWeaponFired& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 weaponId = 1;
  inline bool has_weaponid() const;
  inline void clear_weaponid();
  static const int kWeaponIdFieldNumber = 1;
  inline ::google::protobuf::int32 weaponid() const;
  inline void set_weaponid(::google::protobuf::int32 value);

  // required .modeldata.Vec3 position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::modeldata::Vec3& position() const;
  inline ::modeldata::Vec3* mutable_position();
  inline ::modeldata::Vec3* release_position();
  inline void set_allocated_position(::modeldata::Vec3* position);

  // @@protoc_insertion_point(class_scope:Analytics.GameWeaponFired)
 private:
  inline void set_has_weaponid();
  inline void clear_has_weaponid();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::modeldata::Vec3* position_;
  ::google::protobuf::int32 weaponid_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameWeaponFired* default_instance_;
};
// -------------------------------------------------------------------

class GameDeath : public ::google::protobuf::Message {
 public:
  GameDeath();
  virtual ~GameDeath();

  GameDeath(const GameDeath& from);

  inline GameDeath& operator=(const GameDeath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameDeath& default_instance();

  void Swap(GameDeath* other);

  // implements Message ----------------------------------------------

  GameDeath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameDeath& from);
  void MergeFrom(const GameDeath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 killedByClass = 1;
  inline bool has_killedbyclass() const;
  inline void clear_killedbyclass();
  static const int kKilledByClassFieldNumber = 1;
  inline ::google::protobuf::int32 killedbyclass() const;
  inline void set_killedbyclass(::google::protobuf::int32 value);

  // required int32 killedByWeapon = 2;
  inline bool has_killedbyweapon() const;
  inline void clear_killedbyweapon();
  static const int kKilledByWeaponFieldNumber = 2;
  inline ::google::protobuf::int32 killedbyweapon() const;
  inline void set_killedbyweapon(::google::protobuf::int32 value);

  // required int32 killedByHealth = 3;
  inline bool has_killedbyhealth() const;
  inline void clear_killedbyhealth();
  static const int kKilledByHealthFieldNumber = 3;
  inline ::google::protobuf::int32 killedbyhealth() const;
  inline void set_killedbyhealth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameDeath)
 private:
  inline void set_has_killedbyclass();
  inline void clear_has_killedbyclass();
  inline void set_has_killedbyweapon();
  inline void clear_has_killedbyweapon();
  inline void set_has_killedbyhealth();
  inline void clear_has_killedbyhealth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 killedbyclass_;
  ::google::protobuf::int32 killedbyweapon_;
  ::google::protobuf::int32 killedbyhealth_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameDeath* default_instance_;
};
// -------------------------------------------------------------------

class GameTookDamage : public ::google::protobuf::Message {
 public:
  GameTookDamage();
  virtual ~GameTookDamage();

  GameTookDamage(const GameTookDamage& from);

  inline GameTookDamage& operator=(const GameTookDamage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameTookDamage& default_instance();

  void Swap(GameTookDamage* other);

  // implements Message ----------------------------------------------

  GameTookDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameTookDamage& from);
  void MergeFrom(const GameTookDamage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 weaponId = 1;
  inline bool has_weaponid() const;
  inline void clear_weaponid();
  static const int kWeaponIdFieldNumber = 1;
  inline ::google::protobuf::int32 weaponid() const;
  inline void set_weaponid(::google::protobuf::int32 value);

  // required .modeldata.Vec3 position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::modeldata::Vec3& position() const;
  inline ::modeldata::Vec3* mutable_position();
  inline ::modeldata::Vec3* release_position();
  inline void set_allocated_position(::modeldata::Vec3* position);

  // @@protoc_insertion_point(class_scope:Analytics.GameTookDamage)
 private:
  inline void set_has_weaponid();
  inline void clear_has_weaponid();
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::modeldata::Vec3* position_;
  ::google::protobuf::int32 weaponid_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameTookDamage* default_instance_;
};
// -------------------------------------------------------------------

class GameNavigationStuck : public ::google::protobuf::Message {
 public:
  GameNavigationStuck();
  virtual ~GameNavigationStuck();

  GameNavigationStuck(const GameNavigationStuck& from);

  inline GameNavigationStuck& operator=(const GameNavigationStuck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameNavigationStuck& default_instance();

  void Swap(GameNavigationStuck* other);

  // implements Message ----------------------------------------------

  GameNavigationStuck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameNavigationStuck& from);
  void MergeFrom(const GameNavigationStuck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .modeldata.Vec3 position = 1;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 1;
  inline const ::modeldata::Vec3& position() const;
  inline ::modeldata::Vec3* mutable_position();
  inline ::modeldata::Vec3* release_position();
  inline void set_allocated_position(::modeldata::Vec3* position);

  // @@protoc_insertion_point(class_scope:Analytics.GameNavigationStuck)
 private:
  inline void set_has_position();
  inline void clear_has_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::modeldata::Vec3* position_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameNavigationStuck* default_instance_;
};
// -------------------------------------------------------------------

class MessageUnion : public ::google::protobuf::Message {
 public:
  MessageUnion();
  virtual ~MessageUnion();

  MessageUnion(const MessageUnion& from);

  inline MessageUnion& operator=(const MessageUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageUnion& default_instance();

  enum MsgCase {
    kSystemNavNotFound = 2,
    kSystemNavDownloaded = 3,
    kSystemAssert = 4,
    kSystemCrash = 5,
    kSystemModelData = 6,
    kGameEntityList = 100,
    kGameWeaponFired = 101,
    kGameDeath = 102,
    kGameTookDamage = 103,
    kGameNavigationStuck = 104,
    MSG_NOT_SET = 0,
  };

  void Swap(MessageUnion* other);

  // implements Message ----------------------------------------------

  MessageUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageUnion& from);
  void MergeFrom(const MessageUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional .Analytics.SystemNavNotFound systemNavNotFound = 2;
  inline bool has_systemnavnotfound() const;
  inline void clear_systemnavnotfound();
  static const int kSystemNavNotFoundFieldNumber = 2;
  inline const ::Analytics::SystemNavNotFound& systemnavnotfound() const;
  inline ::Analytics::SystemNavNotFound* mutable_systemnavnotfound();
  inline ::Analytics::SystemNavNotFound* release_systemnavnotfound();
  inline void set_allocated_systemnavnotfound(::Analytics::SystemNavNotFound* systemnavnotfound);

  // optional .Analytics.SystemNavAutoDownloaded systemNavDownloaded = 3;
  inline bool has_systemnavdownloaded() const;
  inline void clear_systemnavdownloaded();
  static const int kSystemNavDownloadedFieldNumber = 3;
  inline const ::Analytics::SystemNavAutoDownloaded& systemnavdownloaded() const;
  inline ::Analytics::SystemNavAutoDownloaded* mutable_systemnavdownloaded();
  inline ::Analytics::SystemNavAutoDownloaded* release_systemnavdownloaded();
  inline void set_allocated_systemnavdownloaded(::Analytics::SystemNavAutoDownloaded* systemnavdownloaded);

  // optional .Analytics.SystemAssert systemAssert = 4;
  inline bool has_systemassert() const;
  inline void clear_systemassert();
  static const int kSystemAssertFieldNumber = 4;
  inline const ::Analytics::SystemAssert& systemassert() const;
  inline ::Analytics::SystemAssert* mutable_systemassert();
  inline ::Analytics::SystemAssert* release_systemassert();
  inline void set_allocated_systemassert(::Analytics::SystemAssert* systemassert);

  // optional .Analytics.SystemCrash systemCrash = 5;
  inline bool has_systemcrash() const;
  inline void clear_systemcrash();
  static const int kSystemCrashFieldNumber = 5;
  inline const ::Analytics::SystemCrash& systemcrash() const;
  inline ::Analytics::SystemCrash* mutable_systemcrash();
  inline ::Analytics::SystemCrash* release_systemcrash();
  inline void set_allocated_systemcrash(::Analytics::SystemCrash* systemcrash);

  // optional .Analytics.SystemModelData systemModelData = 6;
  inline bool has_systemmodeldata() const;
  inline void clear_systemmodeldata();
  static const int kSystemModelDataFieldNumber = 6;
  inline const ::Analytics::SystemModelData& systemmodeldata() const;
  inline ::Analytics::SystemModelData* mutable_systemmodeldata();
  inline ::Analytics::SystemModelData* release_systemmodeldata();
  inline void set_allocated_systemmodeldata(::Analytics::SystemModelData* systemmodeldata);

  // optional .Analytics.GameEntityList gameEntityList = 100;
  inline bool has_gameentitylist() const;
  inline void clear_gameentitylist();
  static const int kGameEntityListFieldNumber = 100;
  inline const ::Analytics::GameEntityList& gameentitylist() const;
  inline ::Analytics::GameEntityList* mutable_gameentitylist();
  inline ::Analytics::GameEntityList* release_gameentitylist();
  inline void set_allocated_gameentitylist(::Analytics::GameEntityList* gameentitylist);

  // optional .Analytics.GameWeaponFired gameWeaponFired = 101;
  inline bool has_gameweaponfired() const;
  inline void clear_gameweaponfired();
  static const int kGameWeaponFiredFieldNumber = 101;
  inline const ::Analytics::GameWeaponFired& gameweaponfired() const;
  inline ::Analytics::GameWeaponFired* mutable_gameweaponfired();
  inline ::Analytics::GameWeaponFired* release_gameweaponfired();
  inline void set_allocated_gameweaponfired(::Analytics::GameWeaponFired* gameweaponfired);

  // optional .Analytics.GameDeath gameDeath = 102;
  inline bool has_gamedeath() const;
  inline void clear_gamedeath();
  static const int kGameDeathFieldNumber = 102;
  inline const ::Analytics::GameDeath& gamedeath() const;
  inline ::Analytics::GameDeath* mutable_gamedeath();
  inline ::Analytics::GameDeath* release_gamedeath();
  inline void set_allocated_gamedeath(::Analytics::GameDeath* gamedeath);

  // optional .Analytics.GameTookDamage gameTookDamage = 103;
  inline bool has_gametookdamage() const;
  inline void clear_gametookdamage();
  static const int kGameTookDamageFieldNumber = 103;
  inline const ::Analytics::GameTookDamage& gametookdamage() const;
  inline ::Analytics::GameTookDamage* mutable_gametookdamage();
  inline ::Analytics::GameTookDamage* release_gametookdamage();
  inline void set_allocated_gametookdamage(::Analytics::GameTookDamage* gametookdamage);

  // optional .Analytics.GameNavigationStuck gameNavigationStuck = 104;
  inline bool has_gamenavigationstuck() const;
  inline void clear_gamenavigationstuck();
  static const int kGameNavigationStuckFieldNumber = 104;
  inline const ::Analytics::GameNavigationStuck& gamenavigationstuck() const;
  inline ::Analytics::GameNavigationStuck* mutable_gamenavigationstuck();
  inline ::Analytics::GameNavigationStuck* release_gamenavigationstuck();
  inline void set_allocated_gamenavigationstuck(::Analytics::GameNavigationStuck* gamenavigationstuck);

  inline MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:Analytics.MessageUnion)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_systemnavnotfound();
  inline void set_has_systemnavdownloaded();
  inline void set_has_systemassert();
  inline void set_has_systemcrash();
  inline void set_has_systemmodeldata();
  inline void set_has_gameentitylist();
  inline void set_has_gameweaponfired();
  inline void set_has_gamedeath();
  inline void set_has_gametookdamage();
  inline void set_has_gamenavigationstuck();

  inline bool has_msg();
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamp_;
  union MsgUnion {
    ::Analytics::SystemNavNotFound* systemnavnotfound_;
    ::Analytics::SystemNavAutoDownloaded* systemnavdownloaded_;
    ::Analytics::SystemAssert* systemassert_;
    ::Analytics::SystemCrash* systemcrash_;
    ::Analytics::SystemModelData* systemmodeldata_;
    ::Analytics::GameEntityList* gameentitylist_;
    ::Analytics::GameWeaponFired* gameweaponfired_;
    ::Analytics::GameDeath* gamedeath_;
    ::Analytics::GameTookDamage* gametookdamage_;
    ::Analytics::GameNavigationStuck* gamenavigationstuck_;
  } msg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static MessageUnion* default_instance_;
};
// ===================================================================


// ===================================================================

// SystemClientInfo

// required string userId = 1;
inline bool SystemClientInfo::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemClientInfo::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemClientInfo::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemClientInfo::clear_userid() {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_->clear();
  }
  clear_has_userid();
}
inline const ::std::string& SystemClientInfo::userid() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemClientInfo.userId)
  return *userid_;
}
inline void SystemClientInfo::set_userid(const ::std::string& value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemClientInfo.userId)
}
inline void SystemClientInfo::set_userid(const char* value) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemClientInfo.userId)
}
inline void SystemClientInfo::set_userid(const char* value, size_t size) {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  userid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemClientInfo.userId)
}
inline ::std::string* SystemClientInfo::mutable_userid() {
  set_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    userid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemClientInfo.userId)
  return userid_;
}
inline ::std::string* SystemClientInfo::release_userid() {
  clear_has_userid();
  if (userid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = userid_;
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemClientInfo::set_allocated_userid(::std::string* userid) {
  if (userid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete userid_;
  }
  if (userid) {
    set_has_userid();
    userid_ = userid;
  } else {
    clear_has_userid();
    userid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemClientInfo.userId)
}

// required string mapId = 2;
inline bool SystemClientInfo::has_mapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemClientInfo::set_has_mapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemClientInfo::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemClientInfo::clear_mapid() {
  if (mapid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapid_->clear();
  }
  clear_has_mapid();
}
inline const ::std::string& SystemClientInfo::mapid() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemClientInfo.mapId)
  return *mapid_;
}
inline void SystemClientInfo::set_mapid(const ::std::string& value) {
  set_has_mapid();
  if (mapid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapid_ = new ::std::string;
  }
  mapid_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemClientInfo.mapId)
}
inline void SystemClientInfo::set_mapid(const char* value) {
  set_has_mapid();
  if (mapid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapid_ = new ::std::string;
  }
  mapid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemClientInfo.mapId)
}
inline void SystemClientInfo::set_mapid(const char* value, size_t size) {
  set_has_mapid();
  if (mapid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapid_ = new ::std::string;
  }
  mapid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemClientInfo.mapId)
}
inline ::std::string* SystemClientInfo::mutable_mapid() {
  set_has_mapid();
  if (mapid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemClientInfo.mapId)
  return mapid_;
}
inline ::std::string* SystemClientInfo::release_mapid() {
  clear_has_mapid();
  if (mapid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapid_;
    mapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemClientInfo::set_allocated_mapid(::std::string* mapid) {
  if (mapid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapid_;
  }
  if (mapid) {
    set_has_mapid();
    mapid_ = mapid;
  } else {
    clear_has_mapid();
    mapid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemClientInfo.mapId)
}

// required string enumClassId = 3;
inline bool SystemClientInfo::has_enumclassid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemClientInfo::set_has_enumclassid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemClientInfo::clear_has_enumclassid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemClientInfo::clear_enumclassid() {
  if (enumclassid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumclassid_->clear();
  }
  clear_has_enumclassid();
}
inline const ::std::string& SystemClientInfo::enumclassid() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemClientInfo.enumClassId)
  return *enumclassid_;
}
inline void SystemClientInfo::set_enumclassid(const ::std::string& value) {
  set_has_enumclassid();
  if (enumclassid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumclassid_ = new ::std::string;
  }
  enumclassid_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemClientInfo.enumClassId)
}
inline void SystemClientInfo::set_enumclassid(const char* value) {
  set_has_enumclassid();
  if (enumclassid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumclassid_ = new ::std::string;
  }
  enumclassid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemClientInfo.enumClassId)
}
inline void SystemClientInfo::set_enumclassid(const char* value, size_t size) {
  set_has_enumclassid();
  if (enumclassid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumclassid_ = new ::std::string;
  }
  enumclassid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemClientInfo.enumClassId)
}
inline ::std::string* SystemClientInfo::mutable_enumclassid() {
  set_has_enumclassid();
  if (enumclassid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumclassid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemClientInfo.enumClassId)
  return enumclassid_;
}
inline ::std::string* SystemClientInfo::release_enumclassid() {
  clear_has_enumclassid();
  if (enumclassid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enumclassid_;
    enumclassid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemClientInfo::set_allocated_enumclassid(::std::string* enumclassid) {
  if (enumclassid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enumclassid_;
  }
  if (enumclassid) {
    set_has_enumclassid();
    enumclassid_ = enumclassid;
  } else {
    clear_has_enumclassid();
    enumclassid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemClientInfo.enumClassId)
}

// required string enumWeaponId = 4;
inline bool SystemClientInfo::has_enumweaponid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SystemClientInfo::set_has_enumweaponid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SystemClientInfo::clear_has_enumweaponid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SystemClientInfo::clear_enumweaponid() {
  if (enumweaponid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumweaponid_->clear();
  }
  clear_has_enumweaponid();
}
inline const ::std::string& SystemClientInfo::enumweaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemClientInfo.enumWeaponId)
  return *enumweaponid_;
}
inline void SystemClientInfo::set_enumweaponid(const ::std::string& value) {
  set_has_enumweaponid();
  if (enumweaponid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumweaponid_ = new ::std::string;
  }
  enumweaponid_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemClientInfo.enumWeaponId)
}
inline void SystemClientInfo::set_enumweaponid(const char* value) {
  set_has_enumweaponid();
  if (enumweaponid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumweaponid_ = new ::std::string;
  }
  enumweaponid_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemClientInfo.enumWeaponId)
}
inline void SystemClientInfo::set_enumweaponid(const char* value, size_t size) {
  set_has_enumweaponid();
  if (enumweaponid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumweaponid_ = new ::std::string;
  }
  enumweaponid_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemClientInfo.enumWeaponId)
}
inline ::std::string* SystemClientInfo::mutable_enumweaponid() {
  set_has_enumweaponid();
  if (enumweaponid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    enumweaponid_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemClientInfo.enumWeaponId)
  return enumweaponid_;
}
inline ::std::string* SystemClientInfo::release_enumweaponid() {
  clear_has_enumweaponid();
  if (enumweaponid_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = enumweaponid_;
    enumweaponid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemClientInfo::set_allocated_enumweaponid(::std::string* enumweaponid) {
  if (enumweaponid_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete enumweaponid_;
  }
  if (enumweaponid) {
    set_has_enumweaponid();
    enumweaponid_ = enumweaponid;
  } else {
    clear_has_enumweaponid();
    enumweaponid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemClientInfo.enumWeaponId)
}

// -------------------------------------------------------------------

// SystemNavNotFound

// required string mapName = 1;
inline bool SystemNavNotFound::has_mapname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemNavNotFound::set_has_mapname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemNavNotFound::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemNavNotFound::clear_mapname() {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_->clear();
  }
  clear_has_mapname();
}
inline const ::std::string& SystemNavNotFound::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemNavNotFound.mapName)
  return *mapname_;
}
inline void SystemNavNotFound::set_mapname(const ::std::string& value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemNavNotFound.mapName)
}
inline void SystemNavNotFound::set_mapname(const char* value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemNavNotFound.mapName)
}
inline void SystemNavNotFound::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemNavNotFound.mapName)
}
inline ::std::string* SystemNavNotFound::mutable_mapname() {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemNavNotFound.mapName)
  return mapname_;
}
inline ::std::string* SystemNavNotFound::release_mapname() {
  clear_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapname_;
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemNavNotFound::set_allocated_mapname(::std::string* mapname) {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapname_;
  }
  if (mapname) {
    set_has_mapname();
    mapname_ = mapname;
  } else {
    clear_has_mapname();
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemNavNotFound.mapName)
}

// -------------------------------------------------------------------

// SystemNavAutoDownloaded

// required string mapName = 1;
inline bool SystemNavAutoDownloaded::has_mapname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemNavAutoDownloaded::set_has_mapname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemNavAutoDownloaded::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemNavAutoDownloaded::clear_mapname() {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_->clear();
  }
  clear_has_mapname();
}
inline const ::std::string& SystemNavAutoDownloaded::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemNavAutoDownloaded.mapName)
  return *mapname_;
}
inline void SystemNavAutoDownloaded::set_mapname(const ::std::string& value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemNavAutoDownloaded.mapName)
}
inline void SystemNavAutoDownloaded::set_mapname(const char* value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemNavAutoDownloaded.mapName)
}
inline void SystemNavAutoDownloaded::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemNavAutoDownloaded.mapName)
}
inline ::std::string* SystemNavAutoDownloaded::mutable_mapname() {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemNavAutoDownloaded.mapName)
  return mapname_;
}
inline ::std::string* SystemNavAutoDownloaded::release_mapname() {
  clear_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapname_;
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemNavAutoDownloaded::set_allocated_mapname(::std::string* mapname) {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapname_;
  }
  if (mapname) {
    set_has_mapname();
    mapname_ = mapname;
  } else {
    clear_has_mapname();
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemNavAutoDownloaded.mapName)
}

// -------------------------------------------------------------------

// SystemAssert

// required string condition = 1;
inline bool SystemAssert::has_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemAssert::set_has_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemAssert::clear_has_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemAssert::clear_condition() {
  if (condition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_->clear();
  }
  clear_has_condition();
}
inline const ::std::string& SystemAssert::condition() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemAssert.condition)
  return *condition_;
}
inline void SystemAssert::set_condition(const ::std::string& value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemAssert.condition)
}
inline void SystemAssert::set_condition(const char* value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemAssert.condition)
}
inline void SystemAssert::set_condition(const char* value, size_t size) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  condition_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemAssert.condition)
}
inline ::std::string* SystemAssert::mutable_condition() {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemAssert.condition)
  return condition_;
}
inline ::std::string* SystemAssert::release_condition() {
  clear_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = condition_;
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemAssert::set_allocated_condition(::std::string* condition) {
  if (condition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete condition_;
  }
  if (condition) {
    set_has_condition();
    condition_ = condition;
  } else {
    clear_has_condition();
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemAssert.condition)
}

// optional string file = 2;
inline bool SystemAssert::has_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemAssert::set_has_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemAssert::clear_has_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemAssert::clear_file() {
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& SystemAssert::file() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemAssert.file)
  return *file_;
}
inline void SystemAssert::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemAssert.file)
}
inline void SystemAssert::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemAssert.file)
}
inline void SystemAssert::set_file(const char* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemAssert.file)
}
inline ::std::string* SystemAssert::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemAssert.file)
  return file_;
}
inline ::std::string* SystemAssert::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemAssert::set_allocated_file(::std::string* file) {
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_;
  }
  if (file) {
    set_has_file();
    file_ = file;
  } else {
    clear_has_file();
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemAssert.file)
}

// optional int32 line = 3;
inline bool SystemAssert::has_line() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemAssert::set_has_line() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemAssert::clear_has_line() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemAssert::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 SystemAssert::line() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemAssert.line)
  return line_;
}
inline void SystemAssert::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
  // @@protoc_insertion_point(field_set:Analytics.SystemAssert.line)
}

// -------------------------------------------------------------------

// SystemCrash

// required string info = 1;
inline bool SystemCrash::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemCrash::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemCrash::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemCrash::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& SystemCrash::info() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemCrash.info)
  return *info_;
}
inline void SystemCrash::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemCrash.info)
}
inline void SystemCrash::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemCrash.info)
}
inline void SystemCrash::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemCrash.info)
}
inline ::std::string* SystemCrash::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemCrash.info)
  return info_;
}
inline ::std::string* SystemCrash::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemCrash::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemCrash.info)
}

// -------------------------------------------------------------------

// SystemModelData

// optional .Analytics.Compression compressionType = 1 [default = Compression_None];
inline bool SystemModelData::has_compressiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemModelData::set_has_compressiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemModelData::clear_has_compressiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemModelData::clear_compressiontype() {
  compressiontype_ = 0;
  clear_has_compressiontype();
}
inline ::Analytics::Compression SystemModelData::compressiontype() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemModelData.compressionType)
  return static_cast< ::Analytics::Compression >(compressiontype_);
}
inline void SystemModelData::set_compressiontype(::Analytics::Compression value) {
  assert(::Analytics::Compression_IsValid(value));
  set_has_compressiontype();
  compressiontype_ = value;
  // @@protoc_insertion_point(field_set:Analytics.SystemModelData.compressionType)
}

// required string modelName = 2;
inline bool SystemModelData::has_modelname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemModelData::set_has_modelname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemModelData::clear_has_modelname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemModelData::clear_modelname() {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_->clear();
  }
  clear_has_modelname();
}
inline const ::std::string& SystemModelData::modelname() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemModelData.modelName)
  return *modelname_;
}
inline void SystemModelData::set_modelname(const ::std::string& value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemModelData.modelName)
}
inline void SystemModelData::set_modelname(const char* value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemModelData.modelName)
}
inline void SystemModelData::set_modelname(const char* value, size_t size) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemModelData.modelName)
}
inline ::std::string* SystemModelData::mutable_modelname() {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemModelData.modelName)
  return modelname_;
}
inline ::std::string* SystemModelData::release_modelname() {
  clear_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelname_;
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemModelData::set_allocated_modelname(::std::string* modelname) {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelname_;
  }
  if (modelname) {
    set_has_modelname();
    modelname_ = modelname;
  } else {
    clear_has_modelname();
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemModelData.modelName)
}

// required bytes modelBytes = 3;
inline bool SystemModelData::has_modelbytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemModelData::set_has_modelbytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemModelData::clear_has_modelbytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemModelData::clear_modelbytes() {
  if (modelbytes_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_->clear();
  }
  clear_has_modelbytes();
}
inline const ::std::string& SystemModelData::modelbytes() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemModelData.modelBytes)
  return *modelbytes_;
}
inline void SystemModelData::set_modelbytes(const ::std::string& value) {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  modelbytes_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemModelData.modelBytes)
}
inline void SystemModelData::set_modelbytes(const char* value) {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  modelbytes_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemModelData.modelBytes)
}
inline void SystemModelData::set_modelbytes(const void* value, size_t size) {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  modelbytes_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemModelData.modelBytes)
}
inline ::std::string* SystemModelData::mutable_modelbytes() {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemModelData.modelBytes)
  return modelbytes_;
}
inline ::std::string* SystemModelData::release_modelbytes() {
  clear_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelbytes_;
    modelbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemModelData::set_allocated_modelbytes(::std::string* modelbytes) {
  if (modelbytes_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelbytes_;
  }
  if (modelbytes) {
    set_has_modelbytes();
    modelbytes_ = modelbytes;
  } else {
    clear_has_modelbytes();
    modelbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemModelData.modelBytes)
}

// -------------------------------------------------------------------

// GameEntityInfo

// required int32 entityId = 1;
inline bool GameEntityInfo::has_entityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameEntityInfo::set_has_entityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameEntityInfo::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameEntityInfo::clear_entityid() {
  entityid_ = 0;
  clear_has_entityid();
}
inline ::google::protobuf::int32 GameEntityInfo::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entityId)
  return entityid_;
}
inline void GameEntityInfo::set_entityid(::google::protobuf::int32 value) {
  set_has_entityid();
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entityId)
}

// required int32 groupId = 2;
inline bool GameEntityInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameEntityInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameEntityInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameEntityInfo::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 GameEntityInfo::groupid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.groupId)
  return groupid_;
}
inline void GameEntityInfo::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.groupId)
}

// required int32 classId = 3;
inline bool GameEntityInfo::has_classid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameEntityInfo::set_has_classid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameEntityInfo::clear_has_classid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameEntityInfo::clear_classid() {
  classid_ = 0;
  clear_has_classid();
}
inline ::google::protobuf::int32 GameEntityInfo::classid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.classId)
  return classid_;
}
inline void GameEntityInfo::set_classid(::google::protobuf::int32 value) {
  set_has_classid();
  classid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.classId)
}

// required .modeldata.Vec3 position = 4;
inline bool GameEntityInfo::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameEntityInfo::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameEntityInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameEntityInfo::clear_position() {
  if (position_ != NULL) position_->::modeldata::Vec3::Clear();
  clear_has_position();
}
inline const ::modeldata::Vec3& GameEntityInfo::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::modeldata::Vec3* GameEntityInfo::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::modeldata::Vec3;
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.position)
  return position_;
}
inline ::modeldata::Vec3* GameEntityInfo::release_position() {
  clear_has_position();
  ::modeldata::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void GameEntityInfo::set_allocated_position(::modeldata::Vec3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.position)
}

// required .modeldata.Euler orient = 5;
inline bool GameEntityInfo::has_orient() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameEntityInfo::set_has_orient() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameEntityInfo::clear_has_orient() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameEntityInfo::clear_orient() {
  if (orient_ != NULL) orient_->::modeldata::Euler::Clear();
  clear_has_orient();
}
inline const ::modeldata::Euler& GameEntityInfo::orient() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.orient)
  return orient_ != NULL ? *orient_ : *default_instance_->orient_;
}
inline ::modeldata::Euler* GameEntityInfo::mutable_orient() {
  set_has_orient();
  if (orient_ == NULL) orient_ = new ::modeldata::Euler;
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.orient)
  return orient_;
}
inline ::modeldata::Euler* GameEntityInfo::release_orient() {
  clear_has_orient();
  ::modeldata::Euler* temp = orient_;
  orient_ = NULL;
  return temp;
}
inline void GameEntityInfo::set_allocated_orient(::modeldata::Euler* orient) {
  delete orient_;
  orient_ = orient;
  if (orient) {
    set_has_orient();
  } else {
    clear_has_orient();
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.orient)
}

// optional int32 quantity = 6;
inline bool GameEntityInfo::has_quantity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameEntityInfo::set_has_quantity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameEntityInfo::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameEntityInfo::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 GameEntityInfo::quantity() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.quantity)
  return quantity_;
}
inline void GameEntityInfo::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.quantity)
}

// optional int32 quantityMax = 7;
inline bool GameEntityInfo::has_quantitymax() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameEntityInfo::set_has_quantitymax() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameEntityInfo::clear_has_quantitymax() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameEntityInfo::clear_quantitymax() {
  quantitymax_ = 0;
  clear_has_quantitymax();
}
inline ::google::protobuf::int32 GameEntityInfo::quantitymax() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.quantityMax)
  return quantitymax_;
}
inline void GameEntityInfo::set_quantitymax(::google::protobuf::int32 value) {
  set_has_quantitymax();
  quantitymax_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.quantityMax)
}

// optional int32 health = 8;
inline bool GameEntityInfo::has_health() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameEntityInfo::set_has_health() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameEntityInfo::clear_has_health() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameEntityInfo::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline ::google::protobuf::int32 GameEntityInfo::health() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.health)
  return health_;
}
inline void GameEntityInfo::set_health(::google::protobuf::int32 value) {
  set_has_health();
  health_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.health)
}

// optional int32 healthMax = 9;
inline bool GameEntityInfo::has_healthmax() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameEntityInfo::set_has_healthmax() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameEntityInfo::clear_has_healthmax() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameEntityInfo::clear_healthmax() {
  healthmax_ = 0;
  clear_has_healthmax();
}
inline ::google::protobuf::int32 GameEntityInfo::healthmax() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.healthMax)
  return healthmax_;
}
inline void GameEntityInfo::set_healthmax(::google::protobuf::int32 value) {
  set_has_healthmax();
  healthmax_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.healthMax)
}

// optional int32 armor = 10;
inline bool GameEntityInfo::has_armor() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameEntityInfo::set_has_armor() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameEntityInfo::clear_has_armor() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameEntityInfo::clear_armor() {
  armor_ = 0;
  clear_has_armor();
}
inline ::google::protobuf::int32 GameEntityInfo::armor() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.armor)
  return armor_;
}
inline void GameEntityInfo::set_armor(::google::protobuf::int32 value) {
  set_has_armor();
  armor_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.armor)
}

// optional int32 armoryMax = 11;
inline bool GameEntityInfo::has_armorymax() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameEntityInfo::set_has_armorymax() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameEntityInfo::clear_has_armorymax() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameEntityInfo::clear_armorymax() {
  armorymax_ = 0;
  clear_has_armorymax();
}
inline ::google::protobuf::int32 GameEntityInfo::armorymax() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.armoryMax)
  return armorymax_;
}
inline void GameEntityInfo::set_armorymax(::google::protobuf::int32 value) {
  set_has_armorymax();
  armorymax_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.armoryMax)
}

// -------------------------------------------------------------------

// GameEntityList

// repeated .Analytics.GameEntityInfo entities = 1;
inline int GameEntityList::entities_size() const {
  return entities_.size();
}
inline void GameEntityList::clear_entities() {
  entities_.Clear();
}
inline const ::Analytics::GameEntityInfo& GameEntityList::entities(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityList.entities)
  return entities_.Get(index);
}
inline ::Analytics::GameEntityInfo* GameEntityList::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityList.entities)
  return entities_.Mutable(index);
}
inline ::Analytics::GameEntityInfo* GameEntityList::add_entities() {
  // @@protoc_insertion_point(field_add:Analytics.GameEntityList.entities)
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >&
GameEntityList::entities() const {
  // @@protoc_insertion_point(field_list:Analytics.GameEntityList.entities)
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >*
GameEntityList::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.GameEntityList.entities)
  return &entities_;
}

// -------------------------------------------------------------------

// GameWeaponFired

// required int32 weaponId = 1;
inline bool GameWeaponFired::has_weaponid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameWeaponFired::set_has_weaponid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameWeaponFired::clear_has_weaponid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameWeaponFired::clear_weaponid() {
  weaponid_ = 0;
  clear_has_weaponid();
}
inline ::google::protobuf::int32 GameWeaponFired::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.weaponId)
  return weaponid_;
}
inline void GameWeaponFired::set_weaponid(::google::protobuf::int32 value) {
  set_has_weaponid();
  weaponid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.weaponId)
}

// required .modeldata.Vec3 position = 2;
inline bool GameWeaponFired::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameWeaponFired::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameWeaponFired::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameWeaponFired::clear_position() {
  if (position_ != NULL) position_->::modeldata::Vec3::Clear();
  clear_has_position();
}
inline const ::modeldata::Vec3& GameWeaponFired::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::modeldata::Vec3* GameWeaponFired::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::modeldata::Vec3;
  // @@protoc_insertion_point(field_mutable:Analytics.GameWeaponFired.position)
  return position_;
}
inline ::modeldata::Vec3* GameWeaponFired::release_position() {
  clear_has_position();
  ::modeldata::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void GameWeaponFired::set_allocated_position(::modeldata::Vec3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameWeaponFired.position)
}

// -------------------------------------------------------------------

// GameDeath

// required int32 killedByClass = 1;
inline bool GameDeath::has_killedbyclass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameDeath::set_has_killedbyclass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameDeath::clear_has_killedbyclass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameDeath::clear_killedbyclass() {
  killedbyclass_ = 0;
  clear_has_killedbyclass();
}
inline ::google::protobuf::int32 GameDeath::killedbyclass() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.killedByClass)
  return killedbyclass_;
}
inline void GameDeath::set_killedbyclass(::google::protobuf::int32 value) {
  set_has_killedbyclass();
  killedbyclass_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.killedByClass)
}

// required int32 killedByWeapon = 2;
inline bool GameDeath::has_killedbyweapon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameDeath::set_has_killedbyweapon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameDeath::clear_has_killedbyweapon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameDeath::clear_killedbyweapon() {
  killedbyweapon_ = 0;
  clear_has_killedbyweapon();
}
inline ::google::protobuf::int32 GameDeath::killedbyweapon() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.killedByWeapon)
  return killedbyweapon_;
}
inline void GameDeath::set_killedbyweapon(::google::protobuf::int32 value) {
  set_has_killedbyweapon();
  killedbyweapon_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.killedByWeapon)
}

// required int32 killedByHealth = 3;
inline bool GameDeath::has_killedbyhealth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameDeath::set_has_killedbyhealth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameDeath::clear_has_killedbyhealth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameDeath::clear_killedbyhealth() {
  killedbyhealth_ = 0;
  clear_has_killedbyhealth();
}
inline ::google::protobuf::int32 GameDeath::killedbyhealth() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.killedByHealth)
  return killedbyhealth_;
}
inline void GameDeath::set_killedbyhealth(::google::protobuf::int32 value) {
  set_has_killedbyhealth();
  killedbyhealth_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.killedByHealth)
}

// -------------------------------------------------------------------

// GameTookDamage

// required int32 weaponId = 1;
inline bool GameTookDamage::has_weaponid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameTookDamage::set_has_weaponid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameTookDamage::clear_has_weaponid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameTookDamage::clear_weaponid() {
  weaponid_ = 0;
  clear_has_weaponid();
}
inline ::google::protobuf::int32 GameTookDamage::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.weaponId)
  return weaponid_;
}
inline void GameTookDamage::set_weaponid(::google::protobuf::int32 value) {
  set_has_weaponid();
  weaponid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.weaponId)
}

// required .modeldata.Vec3 position = 2;
inline bool GameTookDamage::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameTookDamage::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameTookDamage::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameTookDamage::clear_position() {
  if (position_ != NULL) position_->::modeldata::Vec3::Clear();
  clear_has_position();
}
inline const ::modeldata::Vec3& GameTookDamage::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::modeldata::Vec3* GameTookDamage::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::modeldata::Vec3;
  // @@protoc_insertion_point(field_mutable:Analytics.GameTookDamage.position)
  return position_;
}
inline ::modeldata::Vec3* GameTookDamage::release_position() {
  clear_has_position();
  ::modeldata::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void GameTookDamage::set_allocated_position(::modeldata::Vec3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameTookDamage.position)
}

// -------------------------------------------------------------------

// GameNavigationStuck

// required .modeldata.Vec3 position = 1;
inline bool GameNavigationStuck::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameNavigationStuck::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameNavigationStuck::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameNavigationStuck::clear_position() {
  if (position_ != NULL) position_->::modeldata::Vec3::Clear();
  clear_has_position();
}
inline const ::modeldata::Vec3& GameNavigationStuck::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.position)
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::modeldata::Vec3* GameNavigationStuck::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::modeldata::Vec3;
  // @@protoc_insertion_point(field_mutable:Analytics.GameNavigationStuck.position)
  return position_;
}
inline ::modeldata::Vec3* GameNavigationStuck::release_position() {
  clear_has_position();
  ::modeldata::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline void GameNavigationStuck::set_allocated_position(::modeldata::Vec3* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNavigationStuck.position)
}

// -------------------------------------------------------------------

// MessageUnion

// required int64 timestamp = 1;
inline bool MessageUnion::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageUnion::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageUnion::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageUnion::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MessageUnion::timestamp() const {
  // @@protoc_insertion_point(field_get:Analytics.MessageUnion.timestamp)
  return timestamp_;
}
inline void MessageUnion::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Analytics.MessageUnion.timestamp)
}

// optional .Analytics.SystemNavNotFound systemNavNotFound = 2;
inline bool MessageUnion::has_systemnavnotfound() const {
  return msg_case() == kSystemNavNotFound;
}
inline void MessageUnion::set_has_systemnavnotfound() {
  _oneof_case_[0] = kSystemNavNotFound;
}
inline void MessageUnion::clear_systemnavnotfound() {
  if (has_systemnavnotfound()) {
    delete msg_.systemnavnotfound_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemNavNotFound& MessageUnion::systemnavnotfound() const {
  return has_systemnavnotfound() ? *msg_.systemnavnotfound_
                      : ::Analytics::SystemNavNotFound::default_instance();
}
inline ::Analytics::SystemNavNotFound* MessageUnion::mutable_systemnavnotfound() {
  if (!has_systemnavnotfound()) {
    clear_msg();
    set_has_systemnavnotfound();
    msg_.systemnavnotfound_ = new ::Analytics::SystemNavNotFound;
  }
  return msg_.systemnavnotfound_;
}
inline ::Analytics::SystemNavNotFound* MessageUnion::release_systemnavnotfound() {
  if (has_systemnavnotfound()) {
    clear_has_msg();
    ::Analytics::SystemNavNotFound* temp = msg_.systemnavnotfound_;
    msg_.systemnavnotfound_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemnavnotfound(::Analytics::SystemNavNotFound* systemnavnotfound) {
  clear_msg();
  if (systemnavnotfound) {
    set_has_systemnavnotfound();
    msg_.systemnavnotfound_ = systemnavnotfound;
  }
}

// optional .Analytics.SystemNavAutoDownloaded systemNavDownloaded = 3;
inline bool MessageUnion::has_systemnavdownloaded() const {
  return msg_case() == kSystemNavDownloaded;
}
inline void MessageUnion::set_has_systemnavdownloaded() {
  _oneof_case_[0] = kSystemNavDownloaded;
}
inline void MessageUnion::clear_systemnavdownloaded() {
  if (has_systemnavdownloaded()) {
    delete msg_.systemnavdownloaded_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemNavAutoDownloaded& MessageUnion::systemnavdownloaded() const {
  return has_systemnavdownloaded() ? *msg_.systemnavdownloaded_
                      : ::Analytics::SystemNavAutoDownloaded::default_instance();
}
inline ::Analytics::SystemNavAutoDownloaded* MessageUnion::mutable_systemnavdownloaded() {
  if (!has_systemnavdownloaded()) {
    clear_msg();
    set_has_systemnavdownloaded();
    msg_.systemnavdownloaded_ = new ::Analytics::SystemNavAutoDownloaded;
  }
  return msg_.systemnavdownloaded_;
}
inline ::Analytics::SystemNavAutoDownloaded* MessageUnion::release_systemnavdownloaded() {
  if (has_systemnavdownloaded()) {
    clear_has_msg();
    ::Analytics::SystemNavAutoDownloaded* temp = msg_.systemnavdownloaded_;
    msg_.systemnavdownloaded_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemnavdownloaded(::Analytics::SystemNavAutoDownloaded* systemnavdownloaded) {
  clear_msg();
  if (systemnavdownloaded) {
    set_has_systemnavdownloaded();
    msg_.systemnavdownloaded_ = systemnavdownloaded;
  }
}

// optional .Analytics.SystemAssert systemAssert = 4;
inline bool MessageUnion::has_systemassert() const {
  return msg_case() == kSystemAssert;
}
inline void MessageUnion::set_has_systemassert() {
  _oneof_case_[0] = kSystemAssert;
}
inline void MessageUnion::clear_systemassert() {
  if (has_systemassert()) {
    delete msg_.systemassert_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemAssert& MessageUnion::systemassert() const {
  return has_systemassert() ? *msg_.systemassert_
                      : ::Analytics::SystemAssert::default_instance();
}
inline ::Analytics::SystemAssert* MessageUnion::mutable_systemassert() {
  if (!has_systemassert()) {
    clear_msg();
    set_has_systemassert();
    msg_.systemassert_ = new ::Analytics::SystemAssert;
  }
  return msg_.systemassert_;
}
inline ::Analytics::SystemAssert* MessageUnion::release_systemassert() {
  if (has_systemassert()) {
    clear_has_msg();
    ::Analytics::SystemAssert* temp = msg_.systemassert_;
    msg_.systemassert_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemassert(::Analytics::SystemAssert* systemassert) {
  clear_msg();
  if (systemassert) {
    set_has_systemassert();
    msg_.systemassert_ = systemassert;
  }
}

// optional .Analytics.SystemCrash systemCrash = 5;
inline bool MessageUnion::has_systemcrash() const {
  return msg_case() == kSystemCrash;
}
inline void MessageUnion::set_has_systemcrash() {
  _oneof_case_[0] = kSystemCrash;
}
inline void MessageUnion::clear_systemcrash() {
  if (has_systemcrash()) {
    delete msg_.systemcrash_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemCrash& MessageUnion::systemcrash() const {
  return has_systemcrash() ? *msg_.systemcrash_
                      : ::Analytics::SystemCrash::default_instance();
}
inline ::Analytics::SystemCrash* MessageUnion::mutable_systemcrash() {
  if (!has_systemcrash()) {
    clear_msg();
    set_has_systemcrash();
    msg_.systemcrash_ = new ::Analytics::SystemCrash;
  }
  return msg_.systemcrash_;
}
inline ::Analytics::SystemCrash* MessageUnion::release_systemcrash() {
  if (has_systemcrash()) {
    clear_has_msg();
    ::Analytics::SystemCrash* temp = msg_.systemcrash_;
    msg_.systemcrash_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemcrash(::Analytics::SystemCrash* systemcrash) {
  clear_msg();
  if (systemcrash) {
    set_has_systemcrash();
    msg_.systemcrash_ = systemcrash;
  }
}

// optional .Analytics.SystemModelData systemModelData = 6;
inline bool MessageUnion::has_systemmodeldata() const {
  return msg_case() == kSystemModelData;
}
inline void MessageUnion::set_has_systemmodeldata() {
  _oneof_case_[0] = kSystemModelData;
}
inline void MessageUnion::clear_systemmodeldata() {
  if (has_systemmodeldata()) {
    delete msg_.systemmodeldata_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemModelData& MessageUnion::systemmodeldata() const {
  return has_systemmodeldata() ? *msg_.systemmodeldata_
                      : ::Analytics::SystemModelData::default_instance();
}
inline ::Analytics::SystemModelData* MessageUnion::mutable_systemmodeldata() {
  if (!has_systemmodeldata()) {
    clear_msg();
    set_has_systemmodeldata();
    msg_.systemmodeldata_ = new ::Analytics::SystemModelData;
  }
  return msg_.systemmodeldata_;
}
inline ::Analytics::SystemModelData* MessageUnion::release_systemmodeldata() {
  if (has_systemmodeldata()) {
    clear_has_msg();
    ::Analytics::SystemModelData* temp = msg_.systemmodeldata_;
    msg_.systemmodeldata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemmodeldata(::Analytics::SystemModelData* systemmodeldata) {
  clear_msg();
  if (systemmodeldata) {
    set_has_systemmodeldata();
    msg_.systemmodeldata_ = systemmodeldata;
  }
}

// optional .Analytics.GameEntityList gameEntityList = 100;
inline bool MessageUnion::has_gameentitylist() const {
  return msg_case() == kGameEntityList;
}
inline void MessageUnion::set_has_gameentitylist() {
  _oneof_case_[0] = kGameEntityList;
}
inline void MessageUnion::clear_gameentitylist() {
  if (has_gameentitylist()) {
    delete msg_.gameentitylist_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameEntityList& MessageUnion::gameentitylist() const {
  return has_gameentitylist() ? *msg_.gameentitylist_
                      : ::Analytics::GameEntityList::default_instance();
}
inline ::Analytics::GameEntityList* MessageUnion::mutable_gameentitylist() {
  if (!has_gameentitylist()) {
    clear_msg();
    set_has_gameentitylist();
    msg_.gameentitylist_ = new ::Analytics::GameEntityList;
  }
  return msg_.gameentitylist_;
}
inline ::Analytics::GameEntityList* MessageUnion::release_gameentitylist() {
  if (has_gameentitylist()) {
    clear_has_msg();
    ::Analytics::GameEntityList* temp = msg_.gameentitylist_;
    msg_.gameentitylist_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gameentitylist(::Analytics::GameEntityList* gameentitylist) {
  clear_msg();
  if (gameentitylist) {
    set_has_gameentitylist();
    msg_.gameentitylist_ = gameentitylist;
  }
}

// optional .Analytics.GameWeaponFired gameWeaponFired = 101;
inline bool MessageUnion::has_gameweaponfired() const {
  return msg_case() == kGameWeaponFired;
}
inline void MessageUnion::set_has_gameweaponfired() {
  _oneof_case_[0] = kGameWeaponFired;
}
inline void MessageUnion::clear_gameweaponfired() {
  if (has_gameweaponfired()) {
    delete msg_.gameweaponfired_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameWeaponFired& MessageUnion::gameweaponfired() const {
  return has_gameweaponfired() ? *msg_.gameweaponfired_
                      : ::Analytics::GameWeaponFired::default_instance();
}
inline ::Analytics::GameWeaponFired* MessageUnion::mutable_gameweaponfired() {
  if (!has_gameweaponfired()) {
    clear_msg();
    set_has_gameweaponfired();
    msg_.gameweaponfired_ = new ::Analytics::GameWeaponFired;
  }
  return msg_.gameweaponfired_;
}
inline ::Analytics::GameWeaponFired* MessageUnion::release_gameweaponfired() {
  if (has_gameweaponfired()) {
    clear_has_msg();
    ::Analytics::GameWeaponFired* temp = msg_.gameweaponfired_;
    msg_.gameweaponfired_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gameweaponfired(::Analytics::GameWeaponFired* gameweaponfired) {
  clear_msg();
  if (gameweaponfired) {
    set_has_gameweaponfired();
    msg_.gameweaponfired_ = gameweaponfired;
  }
}

// optional .Analytics.GameDeath gameDeath = 102;
inline bool MessageUnion::has_gamedeath() const {
  return msg_case() == kGameDeath;
}
inline void MessageUnion::set_has_gamedeath() {
  _oneof_case_[0] = kGameDeath;
}
inline void MessageUnion::clear_gamedeath() {
  if (has_gamedeath()) {
    delete msg_.gamedeath_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameDeath& MessageUnion::gamedeath() const {
  return has_gamedeath() ? *msg_.gamedeath_
                      : ::Analytics::GameDeath::default_instance();
}
inline ::Analytics::GameDeath* MessageUnion::mutable_gamedeath() {
  if (!has_gamedeath()) {
    clear_msg();
    set_has_gamedeath();
    msg_.gamedeath_ = new ::Analytics::GameDeath;
  }
  return msg_.gamedeath_;
}
inline ::Analytics::GameDeath* MessageUnion::release_gamedeath() {
  if (has_gamedeath()) {
    clear_has_msg();
    ::Analytics::GameDeath* temp = msg_.gamedeath_;
    msg_.gamedeath_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gamedeath(::Analytics::GameDeath* gamedeath) {
  clear_msg();
  if (gamedeath) {
    set_has_gamedeath();
    msg_.gamedeath_ = gamedeath;
  }
}

// optional .Analytics.GameTookDamage gameTookDamage = 103;
inline bool MessageUnion::has_gametookdamage() const {
  return msg_case() == kGameTookDamage;
}
inline void MessageUnion::set_has_gametookdamage() {
  _oneof_case_[0] = kGameTookDamage;
}
inline void MessageUnion::clear_gametookdamage() {
  if (has_gametookdamage()) {
    delete msg_.gametookdamage_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameTookDamage& MessageUnion::gametookdamage() const {
  return has_gametookdamage() ? *msg_.gametookdamage_
                      : ::Analytics::GameTookDamage::default_instance();
}
inline ::Analytics::GameTookDamage* MessageUnion::mutable_gametookdamage() {
  if (!has_gametookdamage()) {
    clear_msg();
    set_has_gametookdamage();
    msg_.gametookdamage_ = new ::Analytics::GameTookDamage;
  }
  return msg_.gametookdamage_;
}
inline ::Analytics::GameTookDamage* MessageUnion::release_gametookdamage() {
  if (has_gametookdamage()) {
    clear_has_msg();
    ::Analytics::GameTookDamage* temp = msg_.gametookdamage_;
    msg_.gametookdamage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gametookdamage(::Analytics::GameTookDamage* gametookdamage) {
  clear_msg();
  if (gametookdamage) {
    set_has_gametookdamage();
    msg_.gametookdamage_ = gametookdamage;
  }
}

// optional .Analytics.GameNavigationStuck gameNavigationStuck = 104;
inline bool MessageUnion::has_gamenavigationstuck() const {
  return msg_case() == kGameNavigationStuck;
}
inline void MessageUnion::set_has_gamenavigationstuck() {
  _oneof_case_[0] = kGameNavigationStuck;
}
inline void MessageUnion::clear_gamenavigationstuck() {
  if (has_gamenavigationstuck()) {
    delete msg_.gamenavigationstuck_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameNavigationStuck& MessageUnion::gamenavigationstuck() const {
  return has_gamenavigationstuck() ? *msg_.gamenavigationstuck_
                      : ::Analytics::GameNavigationStuck::default_instance();
}
inline ::Analytics::GameNavigationStuck* MessageUnion::mutable_gamenavigationstuck() {
  if (!has_gamenavigationstuck()) {
    clear_msg();
    set_has_gamenavigationstuck();
    msg_.gamenavigationstuck_ = new ::Analytics::GameNavigationStuck;
  }
  return msg_.gamenavigationstuck_;
}
inline ::Analytics::GameNavigationStuck* MessageUnion::release_gamenavigationstuck() {
  if (has_gamenavigationstuck()) {
    clear_has_msg();
    ::Analytics::GameNavigationStuck* temp = msg_.gamenavigationstuck_;
    msg_.gamenavigationstuck_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gamenavigationstuck(::Analytics::GameNavigationStuck* gamenavigationstuck) {
  clear_msg();
  if (gamenavigationstuck) {
    set_has_gamenavigationstuck();
    msg_.gamenavigationstuck_ = gamenavigationstuck;
  }
}

inline bool MessageUnion::has_msg() {
  return msg_case() != MSG_NOT_SET;
}
inline void MessageUnion::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline MessageUnion::MsgCase MessageUnion::msg_case() const {
  return MessageUnion::MsgCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace Analytics

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Analytics::Compression> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::Compression>() {
  return ::Analytics::Compression_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_analytics_2eproto__INCLUDED
