// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: analytics.proto

#ifndef PROTOBUF_analytics_2eproto__INCLUDED
#define PROTOBUF_analytics_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/protobuf/descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace Analytics {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_analytics_2eproto();
void protobuf_AssignDesc_analytics_2eproto();
void protobuf_ShutdownFile_analytics_2eproto();

class TopicSubscribe;
class TopicUnsubscribe;
class GameInfo;
class GameNavNotFound;
class GameNavAutoDownloaded;
class GameAssert;
class GameCrash;
class GameModelData;
class GameEntityInfo;
class GameEntityInfo_Ammo;
class GameEntityList;
class GameWeaponFired;
class GameDeath;
class GameTookDamage;
class GameNavigationStuck;
class MessageUnion;

enum Compression {
  Compression_None = 0,
  Compression_FastLZ = 1
};
bool Compression_IsValid(int value);
const Compression Compression_MIN = Compression_None;
const Compression Compression_MAX = Compression_FastLZ;
const int Compression_ARRAYSIZE = Compression_MAX + 1;

const ::google::protobuf::EnumDescriptor* Compression_descriptor();
inline const ::std::string& Compression_Name(Compression value) {
  return ::google::protobuf::internal::NameOfEnum(
    Compression_descriptor(), value);
}
inline bool Compression_Parse(
    const ::std::string& name, Compression* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Compression>(
    Compression_descriptor(), name, value);
}
// ===================================================================

class TopicSubscribe : public ::google::protobuf::Message {
 public:
  TopicSubscribe();
  virtual ~TopicSubscribe();

  TopicSubscribe(const TopicSubscribe& from);

  inline TopicSubscribe& operator=(const TopicSubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicSubscribe& default_instance();

  void Swap(TopicSubscribe* other);

  // implements Message ----------------------------------------------

  TopicSubscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicSubscribe& from);
  void MergeFrom(const TopicSubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:Analytics.TopicSubscribe)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* topic_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static TopicSubscribe* default_instance_;
};
// -------------------------------------------------------------------

class TopicUnsubscribe : public ::google::protobuf::Message {
 public:
  TopicUnsubscribe();
  virtual ~TopicUnsubscribe();

  TopicUnsubscribe(const TopicUnsubscribe& from);

  inline TopicUnsubscribe& operator=(const TopicUnsubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicUnsubscribe& default_instance();

  void Swap(TopicUnsubscribe* other);

  // implements Message ----------------------------------------------

  TopicUnsubscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicUnsubscribe& from);
  void MergeFrom(const TopicUnsubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:Analytics.TopicUnsubscribe)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* topic_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static TopicUnsubscribe* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  void Swap(GameInfo* other);

  // implements Message ----------------------------------------------

  GameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mapName = 1;
  inline bool has_mapname() const;
  inline void clear_mapname();
  static const int kMapNameFieldNumber = 1;
  inline const ::std::string& mapname() const;
  inline void set_mapname(const ::std::string& value);
  inline void set_mapname(const char* value);
  inline void set_mapname(const char* value, size_t size);
  inline ::std::string* mutable_mapname();
  inline ::std::string* release_mapname();
  inline void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Analytics.GameInfo)
 private:
  inline void set_has_mapname();
  inline void clear_has_mapname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mapname_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameNavNotFound : public ::google::protobuf::Message {
 public:
  GameNavNotFound();
  virtual ~GameNavNotFound();

  GameNavNotFound(const GameNavNotFound& from);

  inline GameNavNotFound& operator=(const GameNavNotFound& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameNavNotFound& default_instance();

  void Swap(GameNavNotFound* other);

  // implements Message ----------------------------------------------

  GameNavNotFound* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameNavNotFound& from);
  void MergeFrom(const GameNavNotFound& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mapName = 1;
  inline bool has_mapname() const;
  inline void clear_mapname();
  static const int kMapNameFieldNumber = 1;
  inline const ::std::string& mapname() const;
  inline void set_mapname(const ::std::string& value);
  inline void set_mapname(const char* value);
  inline void set_mapname(const char* value, size_t size);
  inline ::std::string* mutable_mapname();
  inline ::std::string* release_mapname();
  inline void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Analytics.GameNavNotFound)
 private:
  inline void set_has_mapname();
  inline void clear_has_mapname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mapname_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameNavNotFound* default_instance_;
};
// -------------------------------------------------------------------

class GameNavAutoDownloaded : public ::google::protobuf::Message {
 public:
  GameNavAutoDownloaded();
  virtual ~GameNavAutoDownloaded();

  GameNavAutoDownloaded(const GameNavAutoDownloaded& from);

  inline GameNavAutoDownloaded& operator=(const GameNavAutoDownloaded& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameNavAutoDownloaded& default_instance();

  void Swap(GameNavAutoDownloaded* other);

  // implements Message ----------------------------------------------

  GameNavAutoDownloaded* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameNavAutoDownloaded& from);
  void MergeFrom(const GameNavAutoDownloaded& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mapName = 1;
  inline bool has_mapname() const;
  inline void clear_mapname();
  static const int kMapNameFieldNumber = 1;
  inline const ::std::string& mapname() const;
  inline void set_mapname(const ::std::string& value);
  inline void set_mapname(const char* value);
  inline void set_mapname(const char* value, size_t size);
  inline ::std::string* mutable_mapname();
  inline ::std::string* release_mapname();
  inline void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Analytics.GameNavAutoDownloaded)
 private:
  inline void set_has_mapname();
  inline void clear_has_mapname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mapname_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameNavAutoDownloaded* default_instance_;
};
// -------------------------------------------------------------------

class GameAssert : public ::google::protobuf::Message {
 public:
  GameAssert();
  virtual ~GameAssert();

  GameAssert(const GameAssert& from);

  inline GameAssert& operator=(const GameAssert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameAssert& default_instance();

  void Swap(GameAssert* other);

  // implements Message ----------------------------------------------

  GameAssert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameAssert& from);
  void MergeFrom(const GameAssert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string condition = 1;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 1;
  inline const ::std::string& condition() const;
  inline void set_condition(const ::std::string& value);
  inline void set_condition(const char* value);
  inline void set_condition(const char* value, size_t size);
  inline ::std::string* mutable_condition();
  inline ::std::string* release_condition();
  inline void set_allocated_condition(::std::string* condition);

  // optional string file = 2;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 2;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const char* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  inline void set_allocated_file(::std::string* file);

  // optional int32 line = 3;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 3;
  inline ::google::protobuf::int32 line() const;
  inline void set_line(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameAssert)
 private:
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_line();
  inline void clear_has_line();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* condition_;
  ::std::string* file_;
  ::google::protobuf::int32 line_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameAssert* default_instance_;
};
// -------------------------------------------------------------------

class GameCrash : public ::google::protobuf::Message {
 public:
  GameCrash();
  virtual ~GameCrash();

  GameCrash(const GameCrash& from);

  inline GameCrash& operator=(const GameCrash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameCrash& default_instance();

  void Swap(GameCrash* other);

  // implements Message ----------------------------------------------

  GameCrash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameCrash& from);
  void MergeFrom(const GameCrash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:Analytics.GameCrash)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameCrash* default_instance_;
};
// -------------------------------------------------------------------

class GameModelData : public ::google::protobuf::Message {
 public:
  GameModelData();
  virtual ~GameModelData();

  GameModelData(const GameModelData& from);

  inline GameModelData& operator=(const GameModelData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameModelData& default_instance();

  void Swap(GameModelData* other);

  // implements Message ----------------------------------------------

  GameModelData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameModelData& from);
  void MergeFrom(const GameModelData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Analytics.Compression compressionType = 1 [default = Compression_None];
  inline bool has_compressiontype() const;
  inline void clear_compressiontype();
  static const int kCompressionTypeFieldNumber = 1;
  inline ::Analytics::Compression compressiontype() const;
  inline void set_compressiontype(::Analytics::Compression value);

  // required string modelName = 2;
  inline bool has_modelname() const;
  inline void clear_modelname();
  static const int kModelNameFieldNumber = 2;
  inline const ::std::string& modelname() const;
  inline void set_modelname(const ::std::string& value);
  inline void set_modelname(const char* value);
  inline void set_modelname(const char* value, size_t size);
  inline ::std::string* mutable_modelname();
  inline ::std::string* release_modelname();
  inline void set_allocated_modelname(::std::string* modelname);

  // required bytes modelBytes = 3;
  inline bool has_modelbytes() const;
  inline void clear_modelbytes();
  static const int kModelBytesFieldNumber = 3;
  inline const ::std::string& modelbytes() const;
  inline void set_modelbytes(const ::std::string& value);
  inline void set_modelbytes(const char* value);
  inline void set_modelbytes(const void* value, size_t size);
  inline ::std::string* mutable_modelbytes();
  inline ::std::string* release_modelbytes();
  inline void set_allocated_modelbytes(::std::string* modelbytes);

  // optional uint32 modelBytesUncompressed = 4;
  inline bool has_modelbytesuncompressed() const;
  inline void clear_modelbytesuncompressed();
  static const int kModelBytesUncompressedFieldNumber = 4;
  inline ::google::protobuf::uint32 modelbytesuncompressed() const;
  inline void set_modelbytesuncompressed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameModelData)
 private:
  inline void set_has_compressiontype();
  inline void clear_has_compressiontype();
  inline void set_has_modelname();
  inline void clear_has_modelname();
  inline void set_has_modelbytes();
  inline void clear_has_modelbytes();
  inline void set_has_modelbytesuncompressed();
  inline void clear_has_modelbytesuncompressed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* modelname_;
  int compressiontype_;
  ::google::protobuf::uint32 modelbytesuncompressed_;
  ::std::string* modelbytes_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameModelData* default_instance_;
};
// -------------------------------------------------------------------

class GameEntityInfo_Ammo : public ::google::protobuf::Message {
 public:
  GameEntityInfo_Ammo();
  virtual ~GameEntityInfo_Ammo();

  GameEntityInfo_Ammo(const GameEntityInfo_Ammo& from);

  inline GameEntityInfo_Ammo& operator=(const GameEntityInfo_Ammo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEntityInfo_Ammo& default_instance();

  void Swap(GameEntityInfo_Ammo* other);

  // implements Message ----------------------------------------------

  GameEntityInfo_Ammo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEntityInfo_Ammo& from);
  void MergeFrom(const GameEntityInfo_Ammo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ammoType = 1;
  inline bool has_ammotype() const;
  inline void clear_ammotype();
  static const int kAmmoTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 ammotype() const;
  inline void set_ammotype(::google::protobuf::uint32 value);

  // optional uint32 ammoCount = 2;
  inline bool has_ammocount() const;
  inline void clear_ammocount();
  static const int kAmmoCountFieldNumber = 2;
  inline ::google::protobuf::uint32 ammocount() const;
  inline void set_ammocount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityInfo.Ammo)
 private:
  inline void set_has_ammotype();
  inline void clear_has_ammotype();
  inline void set_has_ammocount();
  inline void clear_has_ammocount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 ammotype_;
  ::google::protobuf::uint32 ammocount_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameEntityInfo_Ammo* default_instance_;
};
// -------------------------------------------------------------------

class GameEntityInfo : public ::google::protobuf::Message {
 public:
  GameEntityInfo();
  virtual ~GameEntityInfo();

  GameEntityInfo(const GameEntityInfo& from);

  inline GameEntityInfo& operator=(const GameEntityInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEntityInfo& default_instance();

  void Swap(GameEntityInfo* other);

  // implements Message ----------------------------------------------

  GameEntityInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEntityInfo& from);
  void MergeFrom(const GameEntityInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameEntityInfo_Ammo Ammo;

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 entityId = 2;
  inline bool has_entityid() const;
  inline void clear_entityid();
  static const int kEntityIdFieldNumber = 2;
  inline ::google::protobuf::int32 entityid() const;
  inline void set_entityid(::google::protobuf::int32 value);

  // optional int32 groupId = 3;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 3;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // optional int32 classId = 4;
  inline bool has_classid() const;
  inline void clear_classid();
  static const int kClassIdFieldNumber = 4;
  inline ::google::protobuf::int32 classid() const;
  inline void set_classid(::google::protobuf::int32 value);

  // optional float positionX = 5;
  inline bool has_positionx() const;
  inline void clear_positionx();
  static const int kPositionXFieldNumber = 5;
  inline float positionx() const;
  inline void set_positionx(float value);

  // optional float positionY = 6;
  inline bool has_positiony() const;
  inline void clear_positiony();
  static const int kPositionYFieldNumber = 6;
  inline float positiony() const;
  inline void set_positiony(float value);

  // optional float positionZ = 7;
  inline bool has_positionz() const;
  inline void clear_positionz();
  static const int kPositionZFieldNumber = 7;
  inline float positionz() const;
  inline void set_positionz(float value);

  // optional float heading = 8;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 8;
  inline float heading() const;
  inline void set_heading(float value);

  // optional float pitch = 9;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 9;
  inline float pitch() const;
  inline void set_pitch(float value);

  // optional float roll = 10;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 10;
  inline float roll() const;
  inline void set_roll(float value);

  // optional uint32 health = 12;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 12;
  inline ::google::protobuf::uint32 health() const;
  inline void set_health(::google::protobuf::uint32 value);

  // optional uint32 healthMax = 13;
  inline bool has_healthmax() const;
  inline void clear_healthmax();
  static const int kHealthMaxFieldNumber = 13;
  inline ::google::protobuf::uint32 healthmax() const;
  inline void set_healthmax(::google::protobuf::uint32 value);

  // optional uint32 armor = 14;
  inline bool has_armor() const;
  inline void clear_armor();
  static const int kArmorFieldNumber = 14;
  inline ::google::protobuf::uint32 armor() const;
  inline void set_armor(::google::protobuf::uint32 value);

  // optional uint32 armorMax = 15;
  inline bool has_armormax() const;
  inline void clear_armormax();
  static const int kArmorMaxFieldNumber = 15;
  inline ::google::protobuf::uint32 armormax() const;
  inline void set_armormax(::google::protobuf::uint32 value);

  // optional uint32 team = 16;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 16;
  inline ::google::protobuf::uint32 team() const;
  inline void set_team(::google::protobuf::uint32 value);

  // repeated .Analytics.GameEntityInfo.Ammo ammo = 20;
  inline int ammo_size() const;
  inline void clear_ammo();
  static const int kAmmoFieldNumber = 20;
  inline const ::Analytics::GameEntityInfo_Ammo& ammo(int index) const;
  inline ::Analytics::GameEntityInfo_Ammo* mutable_ammo(int index);
  inline ::Analytics::GameEntityInfo_Ammo* add_ammo();
  inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >&
      ammo() const;
  inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >*
      mutable_ammo();

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_entityid();
  inline void clear_has_entityid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_classid();
  inline void clear_has_classid();
  inline void set_has_positionx();
  inline void clear_has_positionx();
  inline void set_has_positiony();
  inline void clear_has_positiony();
  inline void set_has_positionz();
  inline void clear_has_positionz();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_healthmax();
  inline void clear_has_healthmax();
  inline void set_has_armor();
  inline void clear_has_armor();
  inline void set_has_armormax();
  inline void clear_has_armormax();
  inline void set_has_team();
  inline void clear_has_team();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 entityid_;
  ::google::protobuf::int32 groupid_;
  ::google::protobuf::int32 classid_;
  float positionx_;
  float positiony_;
  float positionz_;
  float heading_;
  float pitch_;
  float roll_;
  ::google::protobuf::uint32 health_;
  ::google::protobuf::uint32 healthmax_;
  ::google::protobuf::uint32 armor_;
  ::google::protobuf::uint32 armormax_;
  ::google::protobuf::uint32 team_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo > ammo_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameEntityInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameEntityList : public ::google::protobuf::Message {
 public:
  GameEntityList();
  virtual ~GameEntityList();

  GameEntityList(const GameEntityList& from);

  inline GameEntityList& operator=(const GameEntityList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEntityList& default_instance();

  void Swap(GameEntityList* other);

  // implements Message ----------------------------------------------

  GameEntityList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEntityList& from);
  void MergeFrom(const GameEntityList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Analytics.GameEntityInfo entities = 1;
  inline int entities_size() const;
  inline void clear_entities();
  static const int kEntitiesFieldNumber = 1;
  inline const ::Analytics::GameEntityInfo& entities(int index) const;
  inline ::Analytics::GameEntityInfo* mutable_entities(int index);
  inline ::Analytics::GameEntityInfo* add_entities();
  inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >&
      entities() const;
  inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >*
      mutable_entities();

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo > entities_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameEntityList* default_instance_;
};
// -------------------------------------------------------------------

class GameWeaponFired : public ::google::protobuf::Message {
 public:
  GameWeaponFired();
  virtual ~GameWeaponFired();

  GameWeaponFired(const GameWeaponFired& from);

  inline GameWeaponFired& operator=(const GameWeaponFired& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameWeaponFired& default_instance();

  void Swap(GameWeaponFired* other);

  // implements Message ----------------------------------------------

  GameWeaponFired* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameWeaponFired& from);
  void MergeFrom(const GameWeaponFired& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 weaponId = 1;
  inline bool has_weaponid() const;
  inline void clear_weaponid();
  static const int kWeaponIdFieldNumber = 1;
  inline ::google::protobuf::int32 weaponid() const;
  inline void set_weaponid(::google::protobuf::int32 value);

  // optional float positionX = 2;
  inline bool has_positionx() const;
  inline void clear_positionx();
  static const int kPositionXFieldNumber = 2;
  inline float positionx() const;
  inline void set_positionx(float value);

  // optional float positionY = 3;
  inline bool has_positiony() const;
  inline void clear_positiony();
  static const int kPositionYFieldNumber = 3;
  inline float positiony() const;
  inline void set_positiony(float value);

  // optional float positionZ = 4;
  inline bool has_positionz() const;
  inline void clear_positionz();
  static const int kPositionZFieldNumber = 4;
  inline float positionz() const;
  inline void set_positionz(float value);

  // optional uint32 fireMode = 5;
  inline bool has_firemode() const;
  inline void clear_firemode();
  static const int kFireModeFieldNumber = 5;
  inline ::google::protobuf::uint32 firemode() const;
  inline void set_firemode(::google::protobuf::uint32 value);

  // optional int32 team = 6;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 6;
  inline ::google::protobuf::int32 team() const;
  inline void set_team(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameWeaponFired)
 private:
  inline void set_has_weaponid();
  inline void clear_has_weaponid();
  inline void set_has_positionx();
  inline void clear_has_positionx();
  inline void set_has_positiony();
  inline void clear_has_positiony();
  inline void set_has_positionz();
  inline void clear_has_positionz();
  inline void set_has_firemode();
  inline void clear_has_firemode();
  inline void set_has_team();
  inline void clear_has_team();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 weaponid_;
  float positionx_;
  float positiony_;
  float positionz_;
  ::google::protobuf::uint32 firemode_;
  ::google::protobuf::int32 team_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameWeaponFired* default_instance_;
};
// -------------------------------------------------------------------

class GameDeath : public ::google::protobuf::Message {
 public:
  GameDeath();
  virtual ~GameDeath();

  GameDeath(const GameDeath& from);

  inline GameDeath& operator=(const GameDeath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameDeath& default_instance();

  void Swap(GameDeath* other);

  // implements Message ----------------------------------------------

  GameDeath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameDeath& from);
  void MergeFrom(const GameDeath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 killedByClass = 1;
  inline bool has_killedbyclass() const;
  inline void clear_killedbyclass();
  static const int kKilledByClassFieldNumber = 1;
  inline ::google::protobuf::int32 killedbyclass() const;
  inline void set_killedbyclass(::google::protobuf::int32 value);

  // required int32 killedByWeapon = 2;
  inline bool has_killedbyweapon() const;
  inline void clear_killedbyweapon();
  static const int kKilledByWeaponFieldNumber = 2;
  inline ::google::protobuf::int32 killedbyweapon() const;
  inline void set_killedbyweapon(::google::protobuf::int32 value);

  // required int32 killedByHealth = 3;
  inline bool has_killedbyhealth() const;
  inline void clear_killedbyhealth();
  static const int kKilledByHealthFieldNumber = 3;
  inline ::google::protobuf::int32 killedbyhealth() const;
  inline void set_killedbyhealth(::google::protobuf::int32 value);

  // optional uint32 team = 4;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 4;
  inline ::google::protobuf::uint32 team() const;
  inline void set_team(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameDeath)
 private:
  inline void set_has_killedbyclass();
  inline void clear_has_killedbyclass();
  inline void set_has_killedbyweapon();
  inline void clear_has_killedbyweapon();
  inline void set_has_killedbyhealth();
  inline void clear_has_killedbyhealth();
  inline void set_has_team();
  inline void clear_has_team();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 killedbyclass_;
  ::google::protobuf::int32 killedbyweapon_;
  ::google::protobuf::int32 killedbyhealth_;
  ::google::protobuf::uint32 team_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameDeath* default_instance_;
};
// -------------------------------------------------------------------

class GameTookDamage : public ::google::protobuf::Message {
 public:
  GameTookDamage();
  virtual ~GameTookDamage();

  GameTookDamage(const GameTookDamage& from);

  inline GameTookDamage& operator=(const GameTookDamage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameTookDamage& default_instance();

  void Swap(GameTookDamage* other);

  // implements Message ----------------------------------------------

  GameTookDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameTookDamage& from);
  void MergeFrom(const GameTookDamage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 weaponId = 1;
  inline bool has_weaponid() const;
  inline void clear_weaponid();
  static const int kWeaponIdFieldNumber = 1;
  inline ::google::protobuf::int32 weaponid() const;
  inline void set_weaponid(::google::protobuf::int32 value);

  // required float positionX = 2;
  inline bool has_positionx() const;
  inline void clear_positionx();
  static const int kPositionXFieldNumber = 2;
  inline float positionx() const;
  inline void set_positionx(float value);

  // required float positionY = 3;
  inline bool has_positiony() const;
  inline void clear_positiony();
  static const int kPositionYFieldNumber = 3;
  inline float positiony() const;
  inline void set_positiony(float value);

  // required float positionZ = 4;
  inline bool has_positionz() const;
  inline void clear_positionz();
  static const int kPositionZFieldNumber = 4;
  inline float positionz() const;
  inline void set_positionz(float value);

  // optional uint32 team = 5;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 5;
  inline ::google::protobuf::uint32 team() const;
  inline void set_team(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameTookDamage)
 private:
  inline void set_has_weaponid();
  inline void clear_has_weaponid();
  inline void set_has_positionx();
  inline void clear_has_positionx();
  inline void set_has_positiony();
  inline void clear_has_positiony();
  inline void set_has_positionz();
  inline void clear_has_positionz();
  inline void set_has_team();
  inline void clear_has_team();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 weaponid_;
  float positionx_;
  float positiony_;
  float positionz_;
  ::google::protobuf::uint32 team_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameTookDamage* default_instance_;
};
// -------------------------------------------------------------------

class GameNavigationStuck : public ::google::protobuf::Message {
 public:
  GameNavigationStuck();
  virtual ~GameNavigationStuck();

  GameNavigationStuck(const GameNavigationStuck& from);

  inline GameNavigationStuck& operator=(const GameNavigationStuck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameNavigationStuck& default_instance();

  void Swap(GameNavigationStuck* other);

  // implements Message ----------------------------------------------

  GameNavigationStuck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameNavigationStuck& from);
  void MergeFrom(const GameNavigationStuck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 entityId = 1;
  inline bool has_entityid() const;
  inline void clear_entityid();
  static const int kEntityIdFieldNumber = 1;
  inline ::google::protobuf::int32 entityid() const;
  inline void set_entityid(::google::protobuf::int32 value);

  // required float positionX = 2;
  inline bool has_positionx() const;
  inline void clear_positionx();
  static const int kPositionXFieldNumber = 2;
  inline float positionx() const;
  inline void set_positionx(float value);

  // required float positionY = 3;
  inline bool has_positiony() const;
  inline void clear_positiony();
  static const int kPositionYFieldNumber = 3;
  inline float positiony() const;
  inline void set_positiony(float value);

  // required float positionZ = 4;
  inline bool has_positionz() const;
  inline void clear_positionz();
  static const int kPositionZFieldNumber = 4;
  inline float positionz() const;
  inline void set_positionz(float value);

  // @@protoc_insertion_point(class_scope:Analytics.GameNavigationStuck)
 private:
  inline void set_has_entityid();
  inline void clear_has_entityid();
  inline void set_has_positionx();
  inline void clear_has_positionx();
  inline void set_has_positiony();
  inline void clear_has_positiony();
  inline void set_has_positionz();
  inline void clear_has_positionz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 entityid_;
  float positionx_;
  float positiony_;
  float positionz_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameNavigationStuck* default_instance_;
};
// -------------------------------------------------------------------

class MessageUnion : public ::google::protobuf::Message {
 public:
  MessageUnion();
  virtual ~MessageUnion();

  MessageUnion(const MessageUnion& from);

  inline MessageUnion& operator=(const MessageUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageUnion& default_instance();

  enum MsgCase {
    kGameInfo = 9,
    kGameNavNotFound = 10,
    kSystemNavDownloaded = 11,
    kGameAssert = 12,
    kGameCrash = 13,
    kGameModelData = 14,
    kGameEntityList = 100,
    kGameWeaponFired = 101,
    kGameDeath = 102,
    kGameTookDamage = 103,
    kGameNavigationStuck = 104,
    kTopicSubscribe = 1000,
    kTopicUnsubscribe = 1001,
    MSG_NOT_SET = 0,
  };

  void Swap(MessageUnion* other);

  // implements Message ----------------------------------------------

  MessageUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageUnion& from);
  void MergeFrom(const MessageUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional .Analytics.GameInfo gameInfo = 9;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 9;
  inline const ::Analytics::GameInfo& gameinfo() const;
  inline ::Analytics::GameInfo* mutable_gameinfo();
  inline ::Analytics::GameInfo* release_gameinfo();
  inline void set_allocated_gameinfo(::Analytics::GameInfo* gameinfo);

  // optional .Analytics.GameNavNotFound gameNavNotFound = 10;
  inline bool has_gamenavnotfound() const;
  inline void clear_gamenavnotfound();
  static const int kGameNavNotFoundFieldNumber = 10;
  inline const ::Analytics::GameNavNotFound& gamenavnotfound() const;
  inline ::Analytics::GameNavNotFound* mutable_gamenavnotfound();
  inline ::Analytics::GameNavNotFound* release_gamenavnotfound();
  inline void set_allocated_gamenavnotfound(::Analytics::GameNavNotFound* gamenavnotfound);

  // optional .Analytics.GameNavAutoDownloaded systemNavDownloaded = 11;
  inline bool has_systemnavdownloaded() const;
  inline void clear_systemnavdownloaded();
  static const int kSystemNavDownloadedFieldNumber = 11;
  inline const ::Analytics::GameNavAutoDownloaded& systemnavdownloaded() const;
  inline ::Analytics::GameNavAutoDownloaded* mutable_systemnavdownloaded();
  inline ::Analytics::GameNavAutoDownloaded* release_systemnavdownloaded();
  inline void set_allocated_systemnavdownloaded(::Analytics::GameNavAutoDownloaded* systemnavdownloaded);

  // optional .Analytics.GameAssert gameAssert = 12;
  inline bool has_gameassert() const;
  inline void clear_gameassert();
  static const int kGameAssertFieldNumber = 12;
  inline const ::Analytics::GameAssert& gameassert() const;
  inline ::Analytics::GameAssert* mutable_gameassert();
  inline ::Analytics::GameAssert* release_gameassert();
  inline void set_allocated_gameassert(::Analytics::GameAssert* gameassert);

  // optional .Analytics.GameCrash gameCrash = 13;
  inline bool has_gamecrash() const;
  inline void clear_gamecrash();
  static const int kGameCrashFieldNumber = 13;
  inline const ::Analytics::GameCrash& gamecrash() const;
  inline ::Analytics::GameCrash* mutable_gamecrash();
  inline ::Analytics::GameCrash* release_gamecrash();
  inline void set_allocated_gamecrash(::Analytics::GameCrash* gamecrash);

  // optional .Analytics.GameModelData gameModelData = 14;
  inline bool has_gamemodeldata() const;
  inline void clear_gamemodeldata();
  static const int kGameModelDataFieldNumber = 14;
  inline const ::Analytics::GameModelData& gamemodeldata() const;
  inline ::Analytics::GameModelData* mutable_gamemodeldata();
  inline ::Analytics::GameModelData* release_gamemodeldata();
  inline void set_allocated_gamemodeldata(::Analytics::GameModelData* gamemodeldata);

  // optional .Analytics.GameEntityList gameEntityList = 100;
  inline bool has_gameentitylist() const;
  inline void clear_gameentitylist();
  static const int kGameEntityListFieldNumber = 100;
  inline const ::Analytics::GameEntityList& gameentitylist() const;
  inline ::Analytics::GameEntityList* mutable_gameentitylist();
  inline ::Analytics::GameEntityList* release_gameentitylist();
  inline void set_allocated_gameentitylist(::Analytics::GameEntityList* gameentitylist);

  // optional .Analytics.GameWeaponFired gameWeaponFired = 101;
  inline bool has_gameweaponfired() const;
  inline void clear_gameweaponfired();
  static const int kGameWeaponFiredFieldNumber = 101;
  inline const ::Analytics::GameWeaponFired& gameweaponfired() const;
  inline ::Analytics::GameWeaponFired* mutable_gameweaponfired();
  inline ::Analytics::GameWeaponFired* release_gameweaponfired();
  inline void set_allocated_gameweaponfired(::Analytics::GameWeaponFired* gameweaponfired);

  // optional .Analytics.GameDeath gameDeath = 102;
  inline bool has_gamedeath() const;
  inline void clear_gamedeath();
  static const int kGameDeathFieldNumber = 102;
  inline const ::Analytics::GameDeath& gamedeath() const;
  inline ::Analytics::GameDeath* mutable_gamedeath();
  inline ::Analytics::GameDeath* release_gamedeath();
  inline void set_allocated_gamedeath(::Analytics::GameDeath* gamedeath);

  // optional .Analytics.GameTookDamage gameTookDamage = 103;
  inline bool has_gametookdamage() const;
  inline void clear_gametookdamage();
  static const int kGameTookDamageFieldNumber = 103;
  inline const ::Analytics::GameTookDamage& gametookdamage() const;
  inline ::Analytics::GameTookDamage* mutable_gametookdamage();
  inline ::Analytics::GameTookDamage* release_gametookdamage();
  inline void set_allocated_gametookdamage(::Analytics::GameTookDamage* gametookdamage);

  // optional .Analytics.GameNavigationStuck gameNavigationStuck = 104;
  inline bool has_gamenavigationstuck() const;
  inline void clear_gamenavigationstuck();
  static const int kGameNavigationStuckFieldNumber = 104;
  inline const ::Analytics::GameNavigationStuck& gamenavigationstuck() const;
  inline ::Analytics::GameNavigationStuck* mutable_gamenavigationstuck();
  inline ::Analytics::GameNavigationStuck* release_gamenavigationstuck();
  inline void set_allocated_gamenavigationstuck(::Analytics::GameNavigationStuck* gamenavigationstuck);

  // optional .Analytics.TopicSubscribe topicSubscribe = 1000;
  inline bool has_topicsubscribe() const;
  inline void clear_topicsubscribe();
  static const int kTopicSubscribeFieldNumber = 1000;
  inline const ::Analytics::TopicSubscribe& topicsubscribe() const;
  inline ::Analytics::TopicSubscribe* mutable_topicsubscribe();
  inline ::Analytics::TopicSubscribe* release_topicsubscribe();
  inline void set_allocated_topicsubscribe(::Analytics::TopicSubscribe* topicsubscribe);

  // optional .Analytics.TopicUnsubscribe topicUnsubscribe = 1001;
  inline bool has_topicunsubscribe() const;
  inline void clear_topicunsubscribe();
  static const int kTopicUnsubscribeFieldNumber = 1001;
  inline const ::Analytics::TopicUnsubscribe& topicunsubscribe() const;
  inline ::Analytics::TopicUnsubscribe* mutable_topicunsubscribe();
  inline ::Analytics::TopicUnsubscribe* release_topicunsubscribe();
  inline void set_allocated_topicunsubscribe(::Analytics::TopicUnsubscribe* topicunsubscribe);

  inline MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:Analytics.MessageUnion)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_gameinfo();
  inline void set_has_gamenavnotfound();
  inline void set_has_systemnavdownloaded();
  inline void set_has_gameassert();
  inline void set_has_gamecrash();
  inline void set_has_gamemodeldata();
  inline void set_has_gameentitylist();
  inline void set_has_gameweaponfired();
  inline void set_has_gamedeath();
  inline void set_has_gametookdamage();
  inline void set_has_gamenavigationstuck();
  inline void set_has_topicsubscribe();
  inline void set_has_topicunsubscribe();

  inline bool has_msg();
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamp_;
  union MsgUnion {
    ::Analytics::GameInfo* gameinfo_;
    ::Analytics::GameNavNotFound* gamenavnotfound_;
    ::Analytics::GameNavAutoDownloaded* systemnavdownloaded_;
    ::Analytics::GameAssert* gameassert_;
    ::Analytics::GameCrash* gamecrash_;
    ::Analytics::GameModelData* gamemodeldata_;
    ::Analytics::GameEntityList* gameentitylist_;
    ::Analytics::GameWeaponFired* gameweaponfired_;
    ::Analytics::GameDeath* gamedeath_;
    ::Analytics::GameTookDamage* gametookdamage_;
    ::Analytics::GameNavigationStuck* gamenavigationstuck_;
    ::Analytics::TopicSubscribe* topicsubscribe_;
    ::Analytics::TopicUnsubscribe* topicunsubscribe_;
  } msg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static MessageUnion* default_instance_;
};
// ===================================================================

static const int kCachelastvalueFieldNumber = 5000;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  cachelastvalue;
static const int kCachekeysuffixFieldNumber = 5001;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  cachekeysuffix;

// ===================================================================

// TopicSubscribe

// required string topic = 1;
inline bool TopicSubscribe::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicSubscribe::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicSubscribe::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicSubscribe::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& TopicSubscribe::topic() const {
  // @@protoc_insertion_point(field_get:Analytics.TopicSubscribe.topic)
  return *topic_;
}
inline void TopicSubscribe::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.TopicSubscribe.topic)
}
inline void TopicSubscribe::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.TopicSubscribe.topic)
}
inline void TopicSubscribe::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.TopicSubscribe.topic)
}
inline ::std::string* TopicSubscribe::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.TopicSubscribe.topic)
  return topic_;
}
inline ::std::string* TopicSubscribe::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TopicSubscribe::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.TopicSubscribe.topic)
}

// -------------------------------------------------------------------

// TopicUnsubscribe

// required string topic = 1;
inline bool TopicUnsubscribe::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicUnsubscribe::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicUnsubscribe::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicUnsubscribe::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& TopicUnsubscribe::topic() const {
  // @@protoc_insertion_point(field_get:Analytics.TopicUnsubscribe.topic)
  return *topic_;
}
inline void TopicUnsubscribe::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.TopicUnsubscribe.topic)
}
inline void TopicUnsubscribe::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.TopicUnsubscribe.topic)
}
inline void TopicUnsubscribe::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.TopicUnsubscribe.topic)
}
inline ::std::string* TopicUnsubscribe::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.TopicUnsubscribe.topic)
  return topic_;
}
inline ::std::string* TopicUnsubscribe::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TopicUnsubscribe::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.TopicUnsubscribe.topic)
}

// -------------------------------------------------------------------

// GameInfo

// required string mapName = 1;
inline bool GameInfo::has_mapname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_mapname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_mapname() {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_->clear();
  }
  clear_has_mapname();
}
inline const ::std::string& GameInfo::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInfo.mapName)
  return *mapname_;
}
inline void GameInfo::set_mapname(const ::std::string& value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.GameInfo.mapName)
}
inline void GameInfo::set_mapname(const char* value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.GameInfo.mapName)
}
inline void GameInfo::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameInfo.mapName)
}
inline ::std::string* GameInfo::mutable_mapname() {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameInfo.mapName)
  return mapname_;
}
inline ::std::string* GameInfo::release_mapname() {
  clear_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapname_;
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameInfo::set_allocated_mapname(::std::string* mapname) {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapname_;
  }
  if (mapname) {
    set_has_mapname();
    mapname_ = mapname;
  } else {
    clear_has_mapname();
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInfo.mapName)
}

// -------------------------------------------------------------------

// GameNavNotFound

// required string mapName = 1;
inline bool GameNavNotFound::has_mapname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameNavNotFound::set_has_mapname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameNavNotFound::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameNavNotFound::clear_mapname() {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_->clear();
  }
  clear_has_mapname();
}
inline const ::std::string& GameNavNotFound::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavNotFound.mapName)
  return *mapname_;
}
inline void GameNavNotFound::set_mapname(const ::std::string& value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNavNotFound.mapName)
}
inline void GameNavNotFound::set_mapname(const char* value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.GameNavNotFound.mapName)
}
inline void GameNavNotFound::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNavNotFound.mapName)
}
inline ::std::string* GameNavNotFound::mutable_mapname() {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameNavNotFound.mapName)
  return mapname_;
}
inline ::std::string* GameNavNotFound::release_mapname() {
  clear_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapname_;
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameNavNotFound::set_allocated_mapname(::std::string* mapname) {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapname_;
  }
  if (mapname) {
    set_has_mapname();
    mapname_ = mapname;
  } else {
    clear_has_mapname();
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNavNotFound.mapName)
}

// -------------------------------------------------------------------

// GameNavAutoDownloaded

// required string mapName = 1;
inline bool GameNavAutoDownloaded::has_mapname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameNavAutoDownloaded::set_has_mapname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameNavAutoDownloaded::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameNavAutoDownloaded::clear_mapname() {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_->clear();
  }
  clear_has_mapname();
}
inline const ::std::string& GameNavAutoDownloaded::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavAutoDownloaded.mapName)
  return *mapname_;
}
inline void GameNavAutoDownloaded::set_mapname(const ::std::string& value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNavAutoDownloaded.mapName)
}
inline void GameNavAutoDownloaded::set_mapname(const char* value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.GameNavAutoDownloaded.mapName)
}
inline void GameNavAutoDownloaded::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNavAutoDownloaded.mapName)
}
inline ::std::string* GameNavAutoDownloaded::mutable_mapname() {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameNavAutoDownloaded.mapName)
  return mapname_;
}
inline ::std::string* GameNavAutoDownloaded::release_mapname() {
  clear_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapname_;
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameNavAutoDownloaded::set_allocated_mapname(::std::string* mapname) {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapname_;
  }
  if (mapname) {
    set_has_mapname();
    mapname_ = mapname;
  } else {
    clear_has_mapname();
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNavAutoDownloaded.mapName)
}

// -------------------------------------------------------------------

// GameAssert

// required string condition = 1;
inline bool GameAssert::has_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameAssert::set_has_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameAssert::clear_has_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameAssert::clear_condition() {
  if (condition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_->clear();
  }
  clear_has_condition();
}
inline const ::std::string& GameAssert::condition() const {
  // @@protoc_insertion_point(field_get:Analytics.GameAssert.condition)
  return *condition_;
}
inline void GameAssert::set_condition(const ::std::string& value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.GameAssert.condition)
}
inline void GameAssert::set_condition(const char* value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.GameAssert.condition)
}
inline void GameAssert::set_condition(const char* value, size_t size) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  condition_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameAssert.condition)
}
inline ::std::string* GameAssert::mutable_condition() {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameAssert.condition)
  return condition_;
}
inline ::std::string* GameAssert::release_condition() {
  clear_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = condition_;
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameAssert::set_allocated_condition(::std::string* condition) {
  if (condition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete condition_;
  }
  if (condition) {
    set_has_condition();
    condition_ = condition;
  } else {
    clear_has_condition();
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameAssert.condition)
}

// optional string file = 2;
inline bool GameAssert::has_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameAssert::set_has_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameAssert::clear_has_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameAssert::clear_file() {
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& GameAssert::file() const {
  // @@protoc_insertion_point(field_get:Analytics.GameAssert.file)
  return *file_;
}
inline void GameAssert::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.GameAssert.file)
}
inline void GameAssert::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.GameAssert.file)
}
inline void GameAssert::set_file(const char* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameAssert.file)
}
inline ::std::string* GameAssert::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameAssert.file)
  return file_;
}
inline ::std::string* GameAssert::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameAssert::set_allocated_file(::std::string* file) {
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_;
  }
  if (file) {
    set_has_file();
    file_ = file;
  } else {
    clear_has_file();
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameAssert.file)
}

// optional int32 line = 3;
inline bool GameAssert::has_line() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameAssert::set_has_line() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameAssert::clear_has_line() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameAssert::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 GameAssert::line() const {
  // @@protoc_insertion_point(field_get:Analytics.GameAssert.line)
  return line_;
}
inline void GameAssert::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameAssert.line)
}

// -------------------------------------------------------------------

// GameCrash

// required string info = 1;
inline bool GameCrash::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameCrash::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameCrash::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameCrash::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& GameCrash::info() const {
  // @@protoc_insertion_point(field_get:Analytics.GameCrash.info)
  return *info_;
}
inline void GameCrash::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.GameCrash.info)
}
inline void GameCrash::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.GameCrash.info)
}
inline void GameCrash::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameCrash.info)
}
inline ::std::string* GameCrash::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameCrash.info)
  return info_;
}
inline ::std::string* GameCrash::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameCrash::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameCrash.info)
}

// -------------------------------------------------------------------

// GameModelData

// optional .Analytics.Compression compressionType = 1 [default = Compression_None];
inline bool GameModelData::has_compressiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameModelData::set_has_compressiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameModelData::clear_has_compressiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameModelData::clear_compressiontype() {
  compressiontype_ = 0;
  clear_has_compressiontype();
}
inline ::Analytics::Compression GameModelData::compressiontype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameModelData.compressionType)
  return static_cast< ::Analytics::Compression >(compressiontype_);
}
inline void GameModelData::set_compressiontype(::Analytics::Compression value) {
  assert(::Analytics::Compression_IsValid(value));
  set_has_compressiontype();
  compressiontype_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameModelData.compressionType)
}

// required string modelName = 2;
inline bool GameModelData::has_modelname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameModelData::set_has_modelname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameModelData::clear_has_modelname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameModelData::clear_modelname() {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_->clear();
  }
  clear_has_modelname();
}
inline const ::std::string& GameModelData::modelname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameModelData.modelName)
  return *modelname_;
}
inline void GameModelData::set_modelname(const ::std::string& value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.GameModelData.modelName)
}
inline void GameModelData::set_modelname(const char* value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.GameModelData.modelName)
}
inline void GameModelData::set_modelname(const char* value, size_t size) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameModelData.modelName)
}
inline ::std::string* GameModelData::mutable_modelname() {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameModelData.modelName)
  return modelname_;
}
inline ::std::string* GameModelData::release_modelname() {
  clear_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelname_;
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameModelData::set_allocated_modelname(::std::string* modelname) {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelname_;
  }
  if (modelname) {
    set_has_modelname();
    modelname_ = modelname;
  } else {
    clear_has_modelname();
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameModelData.modelName)
}

// required bytes modelBytes = 3;
inline bool GameModelData::has_modelbytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameModelData::set_has_modelbytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameModelData::clear_has_modelbytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameModelData::clear_modelbytes() {
  if (modelbytes_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_->clear();
  }
  clear_has_modelbytes();
}
inline const ::std::string& GameModelData::modelbytes() const {
  // @@protoc_insertion_point(field_get:Analytics.GameModelData.modelBytes)
  return *modelbytes_;
}
inline void GameModelData::set_modelbytes(const ::std::string& value) {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  modelbytes_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.GameModelData.modelBytes)
}
inline void GameModelData::set_modelbytes(const char* value) {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  modelbytes_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.GameModelData.modelBytes)
}
inline void GameModelData::set_modelbytes(const void* value, size_t size) {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  modelbytes_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameModelData.modelBytes)
}
inline ::std::string* GameModelData::mutable_modelbytes() {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameModelData.modelBytes)
  return modelbytes_;
}
inline ::std::string* GameModelData::release_modelbytes() {
  clear_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelbytes_;
    modelbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameModelData::set_allocated_modelbytes(::std::string* modelbytes) {
  if (modelbytes_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelbytes_;
  }
  if (modelbytes) {
    set_has_modelbytes();
    modelbytes_ = modelbytes;
  } else {
    clear_has_modelbytes();
    modelbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameModelData.modelBytes)
}

// optional uint32 modelBytesUncompressed = 4;
inline bool GameModelData::has_modelbytesuncompressed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameModelData::set_has_modelbytesuncompressed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameModelData::clear_has_modelbytesuncompressed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameModelData::clear_modelbytesuncompressed() {
  modelbytesuncompressed_ = 0u;
  clear_has_modelbytesuncompressed();
}
inline ::google::protobuf::uint32 GameModelData::modelbytesuncompressed() const {
  // @@protoc_insertion_point(field_get:Analytics.GameModelData.modelBytesUncompressed)
  return modelbytesuncompressed_;
}
inline void GameModelData::set_modelbytesuncompressed(::google::protobuf::uint32 value) {
  set_has_modelbytesuncompressed();
  modelbytesuncompressed_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameModelData.modelBytesUncompressed)
}

// -------------------------------------------------------------------

// GameEntityInfo_Ammo

// required uint32 ammoType = 1;
inline bool GameEntityInfo_Ammo::has_ammotype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameEntityInfo_Ammo::set_has_ammotype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameEntityInfo_Ammo::clear_has_ammotype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameEntityInfo_Ammo::clear_ammotype() {
  ammotype_ = 0u;
  clear_has_ammotype();
}
inline ::google::protobuf::uint32 GameEntityInfo_Ammo::ammotype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.Ammo.ammoType)
  return ammotype_;
}
inline void GameEntityInfo_Ammo::set_ammotype(::google::protobuf::uint32 value) {
  set_has_ammotype();
  ammotype_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.Ammo.ammoType)
}

// optional uint32 ammoCount = 2;
inline bool GameEntityInfo_Ammo::has_ammocount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameEntityInfo_Ammo::set_has_ammocount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameEntityInfo_Ammo::clear_has_ammocount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameEntityInfo_Ammo::clear_ammocount() {
  ammocount_ = 0u;
  clear_has_ammocount();
}
inline ::google::protobuf::uint32 GameEntityInfo_Ammo::ammocount() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.Ammo.ammoCount)
  return ammocount_;
}
inline void GameEntityInfo_Ammo::set_ammocount(::google::protobuf::uint32 value) {
  set_has_ammocount();
  ammocount_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.Ammo.ammoCount)
}

// -------------------------------------------------------------------

// GameEntityInfo

// optional string name = 1;
inline bool GameEntityInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameEntityInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameEntityInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameEntityInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GameEntityInfo::name() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.name)
  return *name_;
}
inline void GameEntityInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.name)
}
inline void GameEntityInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.GameEntityInfo.name)
}
inline void GameEntityInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameEntityInfo.name)
}
inline ::std::string* GameEntityInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.name)
  return name_;
}
inline ::std::string* GameEntityInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void GameEntityInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.name)
}

// required int32 entityId = 2;
inline bool GameEntityInfo::has_entityid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameEntityInfo::set_has_entityid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameEntityInfo::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameEntityInfo::clear_entityid() {
  entityid_ = 0;
  clear_has_entityid();
}
inline ::google::protobuf::int32 GameEntityInfo::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entityId)
  return entityid_;
}
inline void GameEntityInfo::set_entityid(::google::protobuf::int32 value) {
  set_has_entityid();
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entityId)
}

// optional int32 groupId = 3;
inline bool GameEntityInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameEntityInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameEntityInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameEntityInfo::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 GameEntityInfo::groupid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.groupId)
  return groupid_;
}
inline void GameEntityInfo::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.groupId)
}

// optional int32 classId = 4;
inline bool GameEntityInfo::has_classid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameEntityInfo::set_has_classid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameEntityInfo::clear_has_classid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameEntityInfo::clear_classid() {
  classid_ = 0;
  clear_has_classid();
}
inline ::google::protobuf::int32 GameEntityInfo::classid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.classId)
  return classid_;
}
inline void GameEntityInfo::set_classid(::google::protobuf::int32 value) {
  set_has_classid();
  classid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.classId)
}

// optional float positionX = 5;
inline bool GameEntityInfo::has_positionx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameEntityInfo::set_has_positionx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameEntityInfo::clear_has_positionx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameEntityInfo::clear_positionx() {
  positionx_ = 0;
  clear_has_positionx();
}
inline float GameEntityInfo::positionx() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.positionX)
  return positionx_;
}
inline void GameEntityInfo::set_positionx(float value) {
  set_has_positionx();
  positionx_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.positionX)
}

// optional float positionY = 6;
inline bool GameEntityInfo::has_positiony() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameEntityInfo::set_has_positiony() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameEntityInfo::clear_has_positiony() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameEntityInfo::clear_positiony() {
  positiony_ = 0;
  clear_has_positiony();
}
inline float GameEntityInfo::positiony() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.positionY)
  return positiony_;
}
inline void GameEntityInfo::set_positiony(float value) {
  set_has_positiony();
  positiony_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.positionY)
}

// optional float positionZ = 7;
inline bool GameEntityInfo::has_positionz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameEntityInfo::set_has_positionz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameEntityInfo::clear_has_positionz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameEntityInfo::clear_positionz() {
  positionz_ = 0;
  clear_has_positionz();
}
inline float GameEntityInfo::positionz() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.positionZ)
  return positionz_;
}
inline void GameEntityInfo::set_positionz(float value) {
  set_has_positionz();
  positionz_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.positionZ)
}

// optional float heading = 8;
inline bool GameEntityInfo::has_heading() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameEntityInfo::set_has_heading() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameEntityInfo::clear_has_heading() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameEntityInfo::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float GameEntityInfo::heading() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.heading)
  return heading_;
}
inline void GameEntityInfo::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.heading)
}

// optional float pitch = 9;
inline bool GameEntityInfo::has_pitch() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameEntityInfo::set_has_pitch() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameEntityInfo::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameEntityInfo::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float GameEntityInfo::pitch() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.pitch)
  return pitch_;
}
inline void GameEntityInfo::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.pitch)
}

// optional float roll = 10;
inline bool GameEntityInfo::has_roll() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameEntityInfo::set_has_roll() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameEntityInfo::clear_has_roll() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameEntityInfo::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float GameEntityInfo::roll() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.roll)
  return roll_;
}
inline void GameEntityInfo::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.roll)
}

// optional uint32 health = 12;
inline bool GameEntityInfo::has_health() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameEntityInfo::set_has_health() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameEntityInfo::clear_has_health() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameEntityInfo::clear_health() {
  health_ = 0u;
  clear_has_health();
}
inline ::google::protobuf::uint32 GameEntityInfo::health() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.health)
  return health_;
}
inline void GameEntityInfo::set_health(::google::protobuf::uint32 value) {
  set_has_health();
  health_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.health)
}

// optional uint32 healthMax = 13;
inline bool GameEntityInfo::has_healthmax() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameEntityInfo::set_has_healthmax() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameEntityInfo::clear_has_healthmax() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameEntityInfo::clear_healthmax() {
  healthmax_ = 0u;
  clear_has_healthmax();
}
inline ::google::protobuf::uint32 GameEntityInfo::healthmax() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.healthMax)
  return healthmax_;
}
inline void GameEntityInfo::set_healthmax(::google::protobuf::uint32 value) {
  set_has_healthmax();
  healthmax_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.healthMax)
}

// optional uint32 armor = 14;
inline bool GameEntityInfo::has_armor() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameEntityInfo::set_has_armor() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameEntityInfo::clear_has_armor() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameEntityInfo::clear_armor() {
  armor_ = 0u;
  clear_has_armor();
}
inline ::google::protobuf::uint32 GameEntityInfo::armor() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.armor)
  return armor_;
}
inline void GameEntityInfo::set_armor(::google::protobuf::uint32 value) {
  set_has_armor();
  armor_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.armor)
}

// optional uint32 armorMax = 15;
inline bool GameEntityInfo::has_armormax() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GameEntityInfo::set_has_armormax() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GameEntityInfo::clear_has_armormax() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GameEntityInfo::clear_armormax() {
  armormax_ = 0u;
  clear_has_armormax();
}
inline ::google::protobuf::uint32 GameEntityInfo::armormax() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.armorMax)
  return armormax_;
}
inline void GameEntityInfo::set_armormax(::google::protobuf::uint32 value) {
  set_has_armormax();
  armormax_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.armorMax)
}

// optional uint32 team = 16;
inline bool GameEntityInfo::has_team() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GameEntityInfo::set_has_team() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GameEntityInfo::clear_has_team() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GameEntityInfo::clear_team() {
  team_ = 0u;
  clear_has_team();
}
inline ::google::protobuf::uint32 GameEntityInfo::team() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.team)
  return team_;
}
inline void GameEntityInfo::set_team(::google::protobuf::uint32 value) {
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.team)
}

// repeated .Analytics.GameEntityInfo.Ammo ammo = 20;
inline int GameEntityInfo::ammo_size() const {
  return ammo_.size();
}
inline void GameEntityInfo::clear_ammo() {
  ammo_.Clear();
}
inline const ::Analytics::GameEntityInfo_Ammo& GameEntityInfo::ammo(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo)
  return ammo_.Get(index);
}
inline ::Analytics::GameEntityInfo_Ammo* GameEntityInfo::mutable_ammo(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.ammo)
  return ammo_.Mutable(index);
}
inline ::Analytics::GameEntityInfo_Ammo* GameEntityInfo::add_ammo() {
  // @@protoc_insertion_point(field_add:Analytics.GameEntityInfo.ammo)
  return ammo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >&
GameEntityInfo::ammo() const {
  // @@protoc_insertion_point(field_list:Analytics.GameEntityInfo.ammo)
  return ammo_;
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >*
GameEntityInfo::mutable_ammo() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.GameEntityInfo.ammo)
  return &ammo_;
}

// -------------------------------------------------------------------

// GameEntityList

// repeated .Analytics.GameEntityInfo entities = 1;
inline int GameEntityList::entities_size() const {
  return entities_.size();
}
inline void GameEntityList::clear_entities() {
  entities_.Clear();
}
inline const ::Analytics::GameEntityInfo& GameEntityList::entities(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityList.entities)
  return entities_.Get(index);
}
inline ::Analytics::GameEntityInfo* GameEntityList::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityList.entities)
  return entities_.Mutable(index);
}
inline ::Analytics::GameEntityInfo* GameEntityList::add_entities() {
  // @@protoc_insertion_point(field_add:Analytics.GameEntityList.entities)
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >&
GameEntityList::entities() const {
  // @@protoc_insertion_point(field_list:Analytics.GameEntityList.entities)
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >*
GameEntityList::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.GameEntityList.entities)
  return &entities_;
}

// -------------------------------------------------------------------

// GameWeaponFired

// required int32 weaponId = 1;
inline bool GameWeaponFired::has_weaponid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameWeaponFired::set_has_weaponid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameWeaponFired::clear_has_weaponid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameWeaponFired::clear_weaponid() {
  weaponid_ = 0;
  clear_has_weaponid();
}
inline ::google::protobuf::int32 GameWeaponFired::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.weaponId)
  return weaponid_;
}
inline void GameWeaponFired::set_weaponid(::google::protobuf::int32 value) {
  set_has_weaponid();
  weaponid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.weaponId)
}

// optional float positionX = 2;
inline bool GameWeaponFired::has_positionx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameWeaponFired::set_has_positionx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameWeaponFired::clear_has_positionx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameWeaponFired::clear_positionx() {
  positionx_ = 0;
  clear_has_positionx();
}
inline float GameWeaponFired::positionx() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.positionX)
  return positionx_;
}
inline void GameWeaponFired::set_positionx(float value) {
  set_has_positionx();
  positionx_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.positionX)
}

// optional float positionY = 3;
inline bool GameWeaponFired::has_positiony() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameWeaponFired::set_has_positiony() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameWeaponFired::clear_has_positiony() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameWeaponFired::clear_positiony() {
  positiony_ = 0;
  clear_has_positiony();
}
inline float GameWeaponFired::positiony() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.positionY)
  return positiony_;
}
inline void GameWeaponFired::set_positiony(float value) {
  set_has_positiony();
  positiony_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.positionY)
}

// optional float positionZ = 4;
inline bool GameWeaponFired::has_positionz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameWeaponFired::set_has_positionz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameWeaponFired::clear_has_positionz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameWeaponFired::clear_positionz() {
  positionz_ = 0;
  clear_has_positionz();
}
inline float GameWeaponFired::positionz() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.positionZ)
  return positionz_;
}
inline void GameWeaponFired::set_positionz(float value) {
  set_has_positionz();
  positionz_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.positionZ)
}

// optional uint32 fireMode = 5;
inline bool GameWeaponFired::has_firemode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameWeaponFired::set_has_firemode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameWeaponFired::clear_has_firemode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameWeaponFired::clear_firemode() {
  firemode_ = 0u;
  clear_has_firemode();
}
inline ::google::protobuf::uint32 GameWeaponFired::firemode() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.fireMode)
  return firemode_;
}
inline void GameWeaponFired::set_firemode(::google::protobuf::uint32 value) {
  set_has_firemode();
  firemode_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.fireMode)
}

// optional int32 team = 6;
inline bool GameWeaponFired::has_team() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameWeaponFired::set_has_team() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameWeaponFired::clear_has_team() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameWeaponFired::clear_team() {
  team_ = 0;
  clear_has_team();
}
inline ::google::protobuf::int32 GameWeaponFired::team() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.team)
  return team_;
}
inline void GameWeaponFired::set_team(::google::protobuf::int32 value) {
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.team)
}

// -------------------------------------------------------------------

// GameDeath

// required int32 killedByClass = 1;
inline bool GameDeath::has_killedbyclass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameDeath::set_has_killedbyclass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameDeath::clear_has_killedbyclass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameDeath::clear_killedbyclass() {
  killedbyclass_ = 0;
  clear_has_killedbyclass();
}
inline ::google::protobuf::int32 GameDeath::killedbyclass() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.killedByClass)
  return killedbyclass_;
}
inline void GameDeath::set_killedbyclass(::google::protobuf::int32 value) {
  set_has_killedbyclass();
  killedbyclass_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.killedByClass)
}

// required int32 killedByWeapon = 2;
inline bool GameDeath::has_killedbyweapon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameDeath::set_has_killedbyweapon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameDeath::clear_has_killedbyweapon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameDeath::clear_killedbyweapon() {
  killedbyweapon_ = 0;
  clear_has_killedbyweapon();
}
inline ::google::protobuf::int32 GameDeath::killedbyweapon() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.killedByWeapon)
  return killedbyweapon_;
}
inline void GameDeath::set_killedbyweapon(::google::protobuf::int32 value) {
  set_has_killedbyweapon();
  killedbyweapon_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.killedByWeapon)
}

// required int32 killedByHealth = 3;
inline bool GameDeath::has_killedbyhealth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameDeath::set_has_killedbyhealth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameDeath::clear_has_killedbyhealth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameDeath::clear_killedbyhealth() {
  killedbyhealth_ = 0;
  clear_has_killedbyhealth();
}
inline ::google::protobuf::int32 GameDeath::killedbyhealth() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.killedByHealth)
  return killedbyhealth_;
}
inline void GameDeath::set_killedbyhealth(::google::protobuf::int32 value) {
  set_has_killedbyhealth();
  killedbyhealth_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.killedByHealth)
}

// optional uint32 team = 4;
inline bool GameDeath::has_team() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameDeath::set_has_team() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameDeath::clear_has_team() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameDeath::clear_team() {
  team_ = 0u;
  clear_has_team();
}
inline ::google::protobuf::uint32 GameDeath::team() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.team)
  return team_;
}
inline void GameDeath::set_team(::google::protobuf::uint32 value) {
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.team)
}

// -------------------------------------------------------------------

// GameTookDamage

// required int32 weaponId = 1;
inline bool GameTookDamage::has_weaponid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameTookDamage::set_has_weaponid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameTookDamage::clear_has_weaponid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameTookDamage::clear_weaponid() {
  weaponid_ = 0;
  clear_has_weaponid();
}
inline ::google::protobuf::int32 GameTookDamage::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.weaponId)
  return weaponid_;
}
inline void GameTookDamage::set_weaponid(::google::protobuf::int32 value) {
  set_has_weaponid();
  weaponid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.weaponId)
}

// required float positionX = 2;
inline bool GameTookDamage::has_positionx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameTookDamage::set_has_positionx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameTookDamage::clear_has_positionx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameTookDamage::clear_positionx() {
  positionx_ = 0;
  clear_has_positionx();
}
inline float GameTookDamage::positionx() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.positionX)
  return positionx_;
}
inline void GameTookDamage::set_positionx(float value) {
  set_has_positionx();
  positionx_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.positionX)
}

// required float positionY = 3;
inline bool GameTookDamage::has_positiony() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameTookDamage::set_has_positiony() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameTookDamage::clear_has_positiony() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameTookDamage::clear_positiony() {
  positiony_ = 0;
  clear_has_positiony();
}
inline float GameTookDamage::positiony() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.positionY)
  return positiony_;
}
inline void GameTookDamage::set_positiony(float value) {
  set_has_positiony();
  positiony_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.positionY)
}

// required float positionZ = 4;
inline bool GameTookDamage::has_positionz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameTookDamage::set_has_positionz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameTookDamage::clear_has_positionz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameTookDamage::clear_positionz() {
  positionz_ = 0;
  clear_has_positionz();
}
inline float GameTookDamage::positionz() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.positionZ)
  return positionz_;
}
inline void GameTookDamage::set_positionz(float value) {
  set_has_positionz();
  positionz_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.positionZ)
}

// optional uint32 team = 5;
inline bool GameTookDamage::has_team() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameTookDamage::set_has_team() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameTookDamage::clear_has_team() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameTookDamage::clear_team() {
  team_ = 0u;
  clear_has_team();
}
inline ::google::protobuf::uint32 GameTookDamage::team() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.team)
  return team_;
}
inline void GameTookDamage::set_team(::google::protobuf::uint32 value) {
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.team)
}

// -------------------------------------------------------------------

// GameNavigationStuck

// required int32 entityId = 1;
inline bool GameNavigationStuck::has_entityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameNavigationStuck::set_has_entityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameNavigationStuck::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameNavigationStuck::clear_entityid() {
  entityid_ = 0;
  clear_has_entityid();
}
inline ::google::protobuf::int32 GameNavigationStuck::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.entityId)
  return entityid_;
}
inline void GameNavigationStuck::set_entityid(::google::protobuf::int32 value) {
  set_has_entityid();
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.entityId)
}

// required float positionX = 2;
inline bool GameNavigationStuck::has_positionx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameNavigationStuck::set_has_positionx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameNavigationStuck::clear_has_positionx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameNavigationStuck::clear_positionx() {
  positionx_ = 0;
  clear_has_positionx();
}
inline float GameNavigationStuck::positionx() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.positionX)
  return positionx_;
}
inline void GameNavigationStuck::set_positionx(float value) {
  set_has_positionx();
  positionx_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.positionX)
}

// required float positionY = 3;
inline bool GameNavigationStuck::has_positiony() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameNavigationStuck::set_has_positiony() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameNavigationStuck::clear_has_positiony() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameNavigationStuck::clear_positiony() {
  positiony_ = 0;
  clear_has_positiony();
}
inline float GameNavigationStuck::positiony() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.positionY)
  return positiony_;
}
inline void GameNavigationStuck::set_positiony(float value) {
  set_has_positiony();
  positiony_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.positionY)
}

// required float positionZ = 4;
inline bool GameNavigationStuck::has_positionz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameNavigationStuck::set_has_positionz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameNavigationStuck::clear_has_positionz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameNavigationStuck::clear_positionz() {
  positionz_ = 0;
  clear_has_positionz();
}
inline float GameNavigationStuck::positionz() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.positionZ)
  return positionz_;
}
inline void GameNavigationStuck::set_positionz(float value) {
  set_has_positionz();
  positionz_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.positionZ)
}

// -------------------------------------------------------------------

// MessageUnion

// required int64 timestamp = 1;
inline bool MessageUnion::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageUnion::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageUnion::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageUnion::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MessageUnion::timestamp() const {
  // @@protoc_insertion_point(field_get:Analytics.MessageUnion.timestamp)
  return timestamp_;
}
inline void MessageUnion::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Analytics.MessageUnion.timestamp)
}

// optional .Analytics.GameInfo gameInfo = 9;
inline bool MessageUnion::has_gameinfo() const {
  return msg_case() == kGameInfo;
}
inline void MessageUnion::set_has_gameinfo() {
  _oneof_case_[0] = kGameInfo;
}
inline void MessageUnion::clear_gameinfo() {
  if (has_gameinfo()) {
    delete msg_.gameinfo_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameInfo& MessageUnion::gameinfo() const {
  return has_gameinfo() ? *msg_.gameinfo_
                      : ::Analytics::GameInfo::default_instance();
}
inline ::Analytics::GameInfo* MessageUnion::mutable_gameinfo() {
  if (!has_gameinfo()) {
    clear_msg();
    set_has_gameinfo();
    msg_.gameinfo_ = new ::Analytics::GameInfo;
  }
  return msg_.gameinfo_;
}
inline ::Analytics::GameInfo* MessageUnion::release_gameinfo() {
  if (has_gameinfo()) {
    clear_has_msg();
    ::Analytics::GameInfo* temp = msg_.gameinfo_;
    msg_.gameinfo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gameinfo(::Analytics::GameInfo* gameinfo) {
  clear_msg();
  if (gameinfo) {
    set_has_gameinfo();
    msg_.gameinfo_ = gameinfo;
  }
}

// optional .Analytics.GameNavNotFound gameNavNotFound = 10;
inline bool MessageUnion::has_gamenavnotfound() const {
  return msg_case() == kGameNavNotFound;
}
inline void MessageUnion::set_has_gamenavnotfound() {
  _oneof_case_[0] = kGameNavNotFound;
}
inline void MessageUnion::clear_gamenavnotfound() {
  if (has_gamenavnotfound()) {
    delete msg_.gamenavnotfound_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameNavNotFound& MessageUnion::gamenavnotfound() const {
  return has_gamenavnotfound() ? *msg_.gamenavnotfound_
                      : ::Analytics::GameNavNotFound::default_instance();
}
inline ::Analytics::GameNavNotFound* MessageUnion::mutable_gamenavnotfound() {
  if (!has_gamenavnotfound()) {
    clear_msg();
    set_has_gamenavnotfound();
    msg_.gamenavnotfound_ = new ::Analytics::GameNavNotFound;
  }
  return msg_.gamenavnotfound_;
}
inline ::Analytics::GameNavNotFound* MessageUnion::release_gamenavnotfound() {
  if (has_gamenavnotfound()) {
    clear_has_msg();
    ::Analytics::GameNavNotFound* temp = msg_.gamenavnotfound_;
    msg_.gamenavnotfound_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gamenavnotfound(::Analytics::GameNavNotFound* gamenavnotfound) {
  clear_msg();
  if (gamenavnotfound) {
    set_has_gamenavnotfound();
    msg_.gamenavnotfound_ = gamenavnotfound;
  }
}

// optional .Analytics.GameNavAutoDownloaded systemNavDownloaded = 11;
inline bool MessageUnion::has_systemnavdownloaded() const {
  return msg_case() == kSystemNavDownloaded;
}
inline void MessageUnion::set_has_systemnavdownloaded() {
  _oneof_case_[0] = kSystemNavDownloaded;
}
inline void MessageUnion::clear_systemnavdownloaded() {
  if (has_systemnavdownloaded()) {
    delete msg_.systemnavdownloaded_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameNavAutoDownloaded& MessageUnion::systemnavdownloaded() const {
  return has_systemnavdownloaded() ? *msg_.systemnavdownloaded_
                      : ::Analytics::GameNavAutoDownloaded::default_instance();
}
inline ::Analytics::GameNavAutoDownloaded* MessageUnion::mutable_systemnavdownloaded() {
  if (!has_systemnavdownloaded()) {
    clear_msg();
    set_has_systemnavdownloaded();
    msg_.systemnavdownloaded_ = new ::Analytics::GameNavAutoDownloaded;
  }
  return msg_.systemnavdownloaded_;
}
inline ::Analytics::GameNavAutoDownloaded* MessageUnion::release_systemnavdownloaded() {
  if (has_systemnavdownloaded()) {
    clear_has_msg();
    ::Analytics::GameNavAutoDownloaded* temp = msg_.systemnavdownloaded_;
    msg_.systemnavdownloaded_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemnavdownloaded(::Analytics::GameNavAutoDownloaded* systemnavdownloaded) {
  clear_msg();
  if (systemnavdownloaded) {
    set_has_systemnavdownloaded();
    msg_.systemnavdownloaded_ = systemnavdownloaded;
  }
}

// optional .Analytics.GameAssert gameAssert = 12;
inline bool MessageUnion::has_gameassert() const {
  return msg_case() == kGameAssert;
}
inline void MessageUnion::set_has_gameassert() {
  _oneof_case_[0] = kGameAssert;
}
inline void MessageUnion::clear_gameassert() {
  if (has_gameassert()) {
    delete msg_.gameassert_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameAssert& MessageUnion::gameassert() const {
  return has_gameassert() ? *msg_.gameassert_
                      : ::Analytics::GameAssert::default_instance();
}
inline ::Analytics::GameAssert* MessageUnion::mutable_gameassert() {
  if (!has_gameassert()) {
    clear_msg();
    set_has_gameassert();
    msg_.gameassert_ = new ::Analytics::GameAssert;
  }
  return msg_.gameassert_;
}
inline ::Analytics::GameAssert* MessageUnion::release_gameassert() {
  if (has_gameassert()) {
    clear_has_msg();
    ::Analytics::GameAssert* temp = msg_.gameassert_;
    msg_.gameassert_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gameassert(::Analytics::GameAssert* gameassert) {
  clear_msg();
  if (gameassert) {
    set_has_gameassert();
    msg_.gameassert_ = gameassert;
  }
}

// optional .Analytics.GameCrash gameCrash = 13;
inline bool MessageUnion::has_gamecrash() const {
  return msg_case() == kGameCrash;
}
inline void MessageUnion::set_has_gamecrash() {
  _oneof_case_[0] = kGameCrash;
}
inline void MessageUnion::clear_gamecrash() {
  if (has_gamecrash()) {
    delete msg_.gamecrash_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameCrash& MessageUnion::gamecrash() const {
  return has_gamecrash() ? *msg_.gamecrash_
                      : ::Analytics::GameCrash::default_instance();
}
inline ::Analytics::GameCrash* MessageUnion::mutable_gamecrash() {
  if (!has_gamecrash()) {
    clear_msg();
    set_has_gamecrash();
    msg_.gamecrash_ = new ::Analytics::GameCrash;
  }
  return msg_.gamecrash_;
}
inline ::Analytics::GameCrash* MessageUnion::release_gamecrash() {
  if (has_gamecrash()) {
    clear_has_msg();
    ::Analytics::GameCrash* temp = msg_.gamecrash_;
    msg_.gamecrash_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gamecrash(::Analytics::GameCrash* gamecrash) {
  clear_msg();
  if (gamecrash) {
    set_has_gamecrash();
    msg_.gamecrash_ = gamecrash;
  }
}

// optional .Analytics.GameModelData gameModelData = 14;
inline bool MessageUnion::has_gamemodeldata() const {
  return msg_case() == kGameModelData;
}
inline void MessageUnion::set_has_gamemodeldata() {
  _oneof_case_[0] = kGameModelData;
}
inline void MessageUnion::clear_gamemodeldata() {
  if (has_gamemodeldata()) {
    delete msg_.gamemodeldata_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameModelData& MessageUnion::gamemodeldata() const {
  return has_gamemodeldata() ? *msg_.gamemodeldata_
                      : ::Analytics::GameModelData::default_instance();
}
inline ::Analytics::GameModelData* MessageUnion::mutable_gamemodeldata() {
  if (!has_gamemodeldata()) {
    clear_msg();
    set_has_gamemodeldata();
    msg_.gamemodeldata_ = new ::Analytics::GameModelData;
  }
  return msg_.gamemodeldata_;
}
inline ::Analytics::GameModelData* MessageUnion::release_gamemodeldata() {
  if (has_gamemodeldata()) {
    clear_has_msg();
    ::Analytics::GameModelData* temp = msg_.gamemodeldata_;
    msg_.gamemodeldata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gamemodeldata(::Analytics::GameModelData* gamemodeldata) {
  clear_msg();
  if (gamemodeldata) {
    set_has_gamemodeldata();
    msg_.gamemodeldata_ = gamemodeldata;
  }
}

// optional .Analytics.GameEntityList gameEntityList = 100;
inline bool MessageUnion::has_gameentitylist() const {
  return msg_case() == kGameEntityList;
}
inline void MessageUnion::set_has_gameentitylist() {
  _oneof_case_[0] = kGameEntityList;
}
inline void MessageUnion::clear_gameentitylist() {
  if (has_gameentitylist()) {
    delete msg_.gameentitylist_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameEntityList& MessageUnion::gameentitylist() const {
  return has_gameentitylist() ? *msg_.gameentitylist_
                      : ::Analytics::GameEntityList::default_instance();
}
inline ::Analytics::GameEntityList* MessageUnion::mutable_gameentitylist() {
  if (!has_gameentitylist()) {
    clear_msg();
    set_has_gameentitylist();
    msg_.gameentitylist_ = new ::Analytics::GameEntityList;
  }
  return msg_.gameentitylist_;
}
inline ::Analytics::GameEntityList* MessageUnion::release_gameentitylist() {
  if (has_gameentitylist()) {
    clear_has_msg();
    ::Analytics::GameEntityList* temp = msg_.gameentitylist_;
    msg_.gameentitylist_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gameentitylist(::Analytics::GameEntityList* gameentitylist) {
  clear_msg();
  if (gameentitylist) {
    set_has_gameentitylist();
    msg_.gameentitylist_ = gameentitylist;
  }
}

// optional .Analytics.GameWeaponFired gameWeaponFired = 101;
inline bool MessageUnion::has_gameweaponfired() const {
  return msg_case() == kGameWeaponFired;
}
inline void MessageUnion::set_has_gameweaponfired() {
  _oneof_case_[0] = kGameWeaponFired;
}
inline void MessageUnion::clear_gameweaponfired() {
  if (has_gameweaponfired()) {
    delete msg_.gameweaponfired_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameWeaponFired& MessageUnion::gameweaponfired() const {
  return has_gameweaponfired() ? *msg_.gameweaponfired_
                      : ::Analytics::GameWeaponFired::default_instance();
}
inline ::Analytics::GameWeaponFired* MessageUnion::mutable_gameweaponfired() {
  if (!has_gameweaponfired()) {
    clear_msg();
    set_has_gameweaponfired();
    msg_.gameweaponfired_ = new ::Analytics::GameWeaponFired;
  }
  return msg_.gameweaponfired_;
}
inline ::Analytics::GameWeaponFired* MessageUnion::release_gameweaponfired() {
  if (has_gameweaponfired()) {
    clear_has_msg();
    ::Analytics::GameWeaponFired* temp = msg_.gameweaponfired_;
    msg_.gameweaponfired_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gameweaponfired(::Analytics::GameWeaponFired* gameweaponfired) {
  clear_msg();
  if (gameweaponfired) {
    set_has_gameweaponfired();
    msg_.gameweaponfired_ = gameweaponfired;
  }
}

// optional .Analytics.GameDeath gameDeath = 102;
inline bool MessageUnion::has_gamedeath() const {
  return msg_case() == kGameDeath;
}
inline void MessageUnion::set_has_gamedeath() {
  _oneof_case_[0] = kGameDeath;
}
inline void MessageUnion::clear_gamedeath() {
  if (has_gamedeath()) {
    delete msg_.gamedeath_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameDeath& MessageUnion::gamedeath() const {
  return has_gamedeath() ? *msg_.gamedeath_
                      : ::Analytics::GameDeath::default_instance();
}
inline ::Analytics::GameDeath* MessageUnion::mutable_gamedeath() {
  if (!has_gamedeath()) {
    clear_msg();
    set_has_gamedeath();
    msg_.gamedeath_ = new ::Analytics::GameDeath;
  }
  return msg_.gamedeath_;
}
inline ::Analytics::GameDeath* MessageUnion::release_gamedeath() {
  if (has_gamedeath()) {
    clear_has_msg();
    ::Analytics::GameDeath* temp = msg_.gamedeath_;
    msg_.gamedeath_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gamedeath(::Analytics::GameDeath* gamedeath) {
  clear_msg();
  if (gamedeath) {
    set_has_gamedeath();
    msg_.gamedeath_ = gamedeath;
  }
}

// optional .Analytics.GameTookDamage gameTookDamage = 103;
inline bool MessageUnion::has_gametookdamage() const {
  return msg_case() == kGameTookDamage;
}
inline void MessageUnion::set_has_gametookdamage() {
  _oneof_case_[0] = kGameTookDamage;
}
inline void MessageUnion::clear_gametookdamage() {
  if (has_gametookdamage()) {
    delete msg_.gametookdamage_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameTookDamage& MessageUnion::gametookdamage() const {
  return has_gametookdamage() ? *msg_.gametookdamage_
                      : ::Analytics::GameTookDamage::default_instance();
}
inline ::Analytics::GameTookDamage* MessageUnion::mutable_gametookdamage() {
  if (!has_gametookdamage()) {
    clear_msg();
    set_has_gametookdamage();
    msg_.gametookdamage_ = new ::Analytics::GameTookDamage;
  }
  return msg_.gametookdamage_;
}
inline ::Analytics::GameTookDamage* MessageUnion::release_gametookdamage() {
  if (has_gametookdamage()) {
    clear_has_msg();
    ::Analytics::GameTookDamage* temp = msg_.gametookdamage_;
    msg_.gametookdamage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gametookdamage(::Analytics::GameTookDamage* gametookdamage) {
  clear_msg();
  if (gametookdamage) {
    set_has_gametookdamage();
    msg_.gametookdamage_ = gametookdamage;
  }
}

// optional .Analytics.GameNavigationStuck gameNavigationStuck = 104;
inline bool MessageUnion::has_gamenavigationstuck() const {
  return msg_case() == kGameNavigationStuck;
}
inline void MessageUnion::set_has_gamenavigationstuck() {
  _oneof_case_[0] = kGameNavigationStuck;
}
inline void MessageUnion::clear_gamenavigationstuck() {
  if (has_gamenavigationstuck()) {
    delete msg_.gamenavigationstuck_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameNavigationStuck& MessageUnion::gamenavigationstuck() const {
  return has_gamenavigationstuck() ? *msg_.gamenavigationstuck_
                      : ::Analytics::GameNavigationStuck::default_instance();
}
inline ::Analytics::GameNavigationStuck* MessageUnion::mutable_gamenavigationstuck() {
  if (!has_gamenavigationstuck()) {
    clear_msg();
    set_has_gamenavigationstuck();
    msg_.gamenavigationstuck_ = new ::Analytics::GameNavigationStuck;
  }
  return msg_.gamenavigationstuck_;
}
inline ::Analytics::GameNavigationStuck* MessageUnion::release_gamenavigationstuck() {
  if (has_gamenavigationstuck()) {
    clear_has_msg();
    ::Analytics::GameNavigationStuck* temp = msg_.gamenavigationstuck_;
    msg_.gamenavigationstuck_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gamenavigationstuck(::Analytics::GameNavigationStuck* gamenavigationstuck) {
  clear_msg();
  if (gamenavigationstuck) {
    set_has_gamenavigationstuck();
    msg_.gamenavigationstuck_ = gamenavigationstuck;
  }
}

// optional .Analytics.TopicSubscribe topicSubscribe = 1000;
inline bool MessageUnion::has_topicsubscribe() const {
  return msg_case() == kTopicSubscribe;
}
inline void MessageUnion::set_has_topicsubscribe() {
  _oneof_case_[0] = kTopicSubscribe;
}
inline void MessageUnion::clear_topicsubscribe() {
  if (has_topicsubscribe()) {
    delete msg_.topicsubscribe_;
    clear_has_msg();
  }
}
inline const ::Analytics::TopicSubscribe& MessageUnion::topicsubscribe() const {
  return has_topicsubscribe() ? *msg_.topicsubscribe_
                      : ::Analytics::TopicSubscribe::default_instance();
}
inline ::Analytics::TopicSubscribe* MessageUnion::mutable_topicsubscribe() {
  if (!has_topicsubscribe()) {
    clear_msg();
    set_has_topicsubscribe();
    msg_.topicsubscribe_ = new ::Analytics::TopicSubscribe;
  }
  return msg_.topicsubscribe_;
}
inline ::Analytics::TopicSubscribe* MessageUnion::release_topicsubscribe() {
  if (has_topicsubscribe()) {
    clear_has_msg();
    ::Analytics::TopicSubscribe* temp = msg_.topicsubscribe_;
    msg_.topicsubscribe_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_topicsubscribe(::Analytics::TopicSubscribe* topicsubscribe) {
  clear_msg();
  if (topicsubscribe) {
    set_has_topicsubscribe();
    msg_.topicsubscribe_ = topicsubscribe;
  }
}

// optional .Analytics.TopicUnsubscribe topicUnsubscribe = 1001;
inline bool MessageUnion::has_topicunsubscribe() const {
  return msg_case() == kTopicUnsubscribe;
}
inline void MessageUnion::set_has_topicunsubscribe() {
  _oneof_case_[0] = kTopicUnsubscribe;
}
inline void MessageUnion::clear_topicunsubscribe() {
  if (has_topicunsubscribe()) {
    delete msg_.topicunsubscribe_;
    clear_has_msg();
  }
}
inline const ::Analytics::TopicUnsubscribe& MessageUnion::topicunsubscribe() const {
  return has_topicunsubscribe() ? *msg_.topicunsubscribe_
                      : ::Analytics::TopicUnsubscribe::default_instance();
}
inline ::Analytics::TopicUnsubscribe* MessageUnion::mutable_topicunsubscribe() {
  if (!has_topicunsubscribe()) {
    clear_msg();
    set_has_topicunsubscribe();
    msg_.topicunsubscribe_ = new ::Analytics::TopicUnsubscribe;
  }
  return msg_.topicunsubscribe_;
}
inline ::Analytics::TopicUnsubscribe* MessageUnion::release_topicunsubscribe() {
  if (has_topicunsubscribe()) {
    clear_has_msg();
    ::Analytics::TopicUnsubscribe* temp = msg_.topicunsubscribe_;
    msg_.topicunsubscribe_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_topicunsubscribe(::Analytics::TopicUnsubscribe* topicunsubscribe) {
  clear_msg();
  if (topicunsubscribe) {
    set_has_topicunsubscribe();
    msg_.topicunsubscribe_ = topicunsubscribe;
  }
}

inline bool MessageUnion::has_msg() {
  return msg_case() != MSG_NOT_SET;
}
inline void MessageUnion::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline MessageUnion::MsgCase MessageUnion::msg_case() const {
  return MessageUnion::MsgCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace Analytics

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Analytics::Compression> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::Compression>() {
  return ::Analytics::Compression_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_analytics_2eproto__INCLUDED
