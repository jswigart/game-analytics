// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: analytics.proto

#ifndef PROTOBUF_analytics_2eproto__INCLUDED
#define PROTOBUF_analytics_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "google/protobuf/descriptor.pb.h"
// @@protoc_insertion_point(includes)

namespace Analytics {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_analytics_2eproto();
void protobuf_AssignDesc_analytics_2eproto();
void protobuf_ShutdownFile_analytics_2eproto();

class TopicSubscribe;
class TopicUnsubscribe;
class SystemNavNotFound;
class SystemNavAutoDownloaded;
class SystemAssert;
class SystemCrash;
class SystemModelData;
class GameEntityInfo;
class GameEntityList;
class GameWeaponFired;
class GameDeath;
class GameTookDamage;
class GameNavigationStuck;
class MessageUnion;

enum Compression {
  Compression_None = 0,
  Compression_FastLZ = 1
};
bool Compression_IsValid(int value);
const Compression Compression_MIN = Compression_None;
const Compression Compression_MAX = Compression_FastLZ;
const int Compression_ARRAYSIZE = Compression_MAX + 1;

const ::google::protobuf::EnumDescriptor* Compression_descriptor();
inline const ::std::string& Compression_Name(Compression value) {
  return ::google::protobuf::internal::NameOfEnum(
    Compression_descriptor(), value);
}
inline bool Compression_Parse(
    const ::std::string& name, Compression* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Compression>(
    Compression_descriptor(), name, value);
}
// ===================================================================

class TopicSubscribe : public ::google::protobuf::Message {
 public:
  TopicSubscribe();
  virtual ~TopicSubscribe();

  TopicSubscribe(const TopicSubscribe& from);

  inline TopicSubscribe& operator=(const TopicSubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicSubscribe& default_instance();

  void Swap(TopicSubscribe* other);

  // implements Message ----------------------------------------------

  TopicSubscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicSubscribe& from);
  void MergeFrom(const TopicSubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:Analytics.TopicSubscribe)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* topic_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static TopicSubscribe* default_instance_;
};
// -------------------------------------------------------------------

class TopicUnsubscribe : public ::google::protobuf::Message {
 public:
  TopicUnsubscribe();
  virtual ~TopicUnsubscribe();

  TopicUnsubscribe(const TopicUnsubscribe& from);

  inline TopicUnsubscribe& operator=(const TopicUnsubscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicUnsubscribe& default_instance();

  void Swap(TopicUnsubscribe* other);

  // implements Message ----------------------------------------------

  TopicUnsubscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TopicUnsubscribe& from);
  void MergeFrom(const TopicUnsubscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string topic = 1;
  inline bool has_topic() const;
  inline void clear_topic();
  static const int kTopicFieldNumber = 1;
  inline const ::std::string& topic() const;
  inline void set_topic(const ::std::string& value);
  inline void set_topic(const char* value);
  inline void set_topic(const char* value, size_t size);
  inline ::std::string* mutable_topic();
  inline ::std::string* release_topic();
  inline void set_allocated_topic(::std::string* topic);

  // @@protoc_insertion_point(class_scope:Analytics.TopicUnsubscribe)
 private:
  inline void set_has_topic();
  inline void clear_has_topic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* topic_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static TopicUnsubscribe* default_instance_;
};
// -------------------------------------------------------------------

class SystemNavNotFound : public ::google::protobuf::Message {
 public:
  SystemNavNotFound();
  virtual ~SystemNavNotFound();

  SystemNavNotFound(const SystemNavNotFound& from);

  inline SystemNavNotFound& operator=(const SystemNavNotFound& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemNavNotFound& default_instance();

  void Swap(SystemNavNotFound* other);

  // implements Message ----------------------------------------------

  SystemNavNotFound* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemNavNotFound& from);
  void MergeFrom(const SystemNavNotFound& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mapName = 1;
  inline bool has_mapname() const;
  inline void clear_mapname();
  static const int kMapNameFieldNumber = 1;
  inline const ::std::string& mapname() const;
  inline void set_mapname(const ::std::string& value);
  inline void set_mapname(const char* value);
  inline void set_mapname(const char* value, size_t size);
  inline ::std::string* mutable_mapname();
  inline ::std::string* release_mapname();
  inline void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Analytics.SystemNavNotFound)
 private:
  inline void set_has_mapname();
  inline void clear_has_mapname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mapname_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemNavNotFound* default_instance_;
};
// -------------------------------------------------------------------

class SystemNavAutoDownloaded : public ::google::protobuf::Message {
 public:
  SystemNavAutoDownloaded();
  virtual ~SystemNavAutoDownloaded();

  SystemNavAutoDownloaded(const SystemNavAutoDownloaded& from);

  inline SystemNavAutoDownloaded& operator=(const SystemNavAutoDownloaded& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemNavAutoDownloaded& default_instance();

  void Swap(SystemNavAutoDownloaded* other);

  // implements Message ----------------------------------------------

  SystemNavAutoDownloaded* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemNavAutoDownloaded& from);
  void MergeFrom(const SystemNavAutoDownloaded& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mapName = 1;
  inline bool has_mapname() const;
  inline void clear_mapname();
  static const int kMapNameFieldNumber = 1;
  inline const ::std::string& mapname() const;
  inline void set_mapname(const ::std::string& value);
  inline void set_mapname(const char* value);
  inline void set_mapname(const char* value, size_t size);
  inline ::std::string* mutable_mapname();
  inline ::std::string* release_mapname();
  inline void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Analytics.SystemNavAutoDownloaded)
 private:
  inline void set_has_mapname();
  inline void clear_has_mapname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* mapname_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemNavAutoDownloaded* default_instance_;
};
// -------------------------------------------------------------------

class SystemAssert : public ::google::protobuf::Message {
 public:
  SystemAssert();
  virtual ~SystemAssert();

  SystemAssert(const SystemAssert& from);

  inline SystemAssert& operator=(const SystemAssert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemAssert& default_instance();

  void Swap(SystemAssert* other);

  // implements Message ----------------------------------------------

  SystemAssert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemAssert& from);
  void MergeFrom(const SystemAssert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string condition = 1;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 1;
  inline const ::std::string& condition() const;
  inline void set_condition(const ::std::string& value);
  inline void set_condition(const char* value);
  inline void set_condition(const char* value, size_t size);
  inline ::std::string* mutable_condition();
  inline ::std::string* release_condition();
  inline void set_allocated_condition(::std::string* condition);

  // optional string file = 2;
  inline bool has_file() const;
  inline void clear_file();
  static const int kFileFieldNumber = 2;
  inline const ::std::string& file() const;
  inline void set_file(const ::std::string& value);
  inline void set_file(const char* value);
  inline void set_file(const char* value, size_t size);
  inline ::std::string* mutable_file();
  inline ::std::string* release_file();
  inline void set_allocated_file(::std::string* file);

  // optional int32 line = 3;
  inline bool has_line() const;
  inline void clear_line();
  static const int kLineFieldNumber = 3;
  inline ::google::protobuf::int32 line() const;
  inline void set_line(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.SystemAssert)
 private:
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_file();
  inline void clear_has_file();
  inline void set_has_line();
  inline void clear_has_line();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* condition_;
  ::std::string* file_;
  ::google::protobuf::int32 line_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemAssert* default_instance_;
};
// -------------------------------------------------------------------

class SystemCrash : public ::google::protobuf::Message {
 public:
  SystemCrash();
  virtual ~SystemCrash();

  SystemCrash(const SystemCrash& from);

  inline SystemCrash& operator=(const SystemCrash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemCrash& default_instance();

  void Swap(SystemCrash* other);

  // implements Message ----------------------------------------------

  SystemCrash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemCrash& from);
  void MergeFrom(const SystemCrash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string info = 1;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 1;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:Analytics.SystemCrash)
 private:
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* info_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemCrash* default_instance_;
};
// -------------------------------------------------------------------

class SystemModelData : public ::google::protobuf::Message {
 public:
  SystemModelData();
  virtual ~SystemModelData();

  SystemModelData(const SystemModelData& from);

  inline SystemModelData& operator=(const SystemModelData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemModelData& default_instance();

  void Swap(SystemModelData* other);

  // implements Message ----------------------------------------------

  SystemModelData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SystemModelData& from);
  void MergeFrom(const SystemModelData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Analytics.Compression compressionType = 1 [default = Compression_None];
  inline bool has_compressiontype() const;
  inline void clear_compressiontype();
  static const int kCompressionTypeFieldNumber = 1;
  inline ::Analytics::Compression compressiontype() const;
  inline void set_compressiontype(::Analytics::Compression value);

  // required string modelName = 2;
  inline bool has_modelname() const;
  inline void clear_modelname();
  static const int kModelNameFieldNumber = 2;
  inline const ::std::string& modelname() const;
  inline void set_modelname(const ::std::string& value);
  inline void set_modelname(const char* value);
  inline void set_modelname(const char* value, size_t size);
  inline ::std::string* mutable_modelname();
  inline ::std::string* release_modelname();
  inline void set_allocated_modelname(::std::string* modelname);

  // required bytes modelBytes = 3;
  inline bool has_modelbytes() const;
  inline void clear_modelbytes();
  static const int kModelBytesFieldNumber = 3;
  inline const ::std::string& modelbytes() const;
  inline void set_modelbytes(const ::std::string& value);
  inline void set_modelbytes(const char* value);
  inline void set_modelbytes(const void* value, size_t size);
  inline ::std::string* mutable_modelbytes();
  inline ::std::string* release_modelbytes();
  inline void set_allocated_modelbytes(::std::string* modelbytes);

  // @@protoc_insertion_point(class_scope:Analytics.SystemModelData)
 private:
  inline void set_has_compressiontype();
  inline void clear_has_compressiontype();
  inline void set_has_modelname();
  inline void clear_has_modelname();
  inline void set_has_modelbytes();
  inline void clear_has_modelbytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* modelname_;
  ::std::string* modelbytes_;
  int compressiontype_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static SystemModelData* default_instance_;
};
// -------------------------------------------------------------------

class GameEntityInfo : public ::google::protobuf::Message {
 public:
  GameEntityInfo();
  virtual ~GameEntityInfo();

  GameEntityInfo(const GameEntityInfo& from);

  inline GameEntityInfo& operator=(const GameEntityInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEntityInfo& default_instance();

  void Swap(GameEntityInfo* other);

  // implements Message ----------------------------------------------

  GameEntityInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEntityInfo& from);
  void MergeFrom(const GameEntityInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 entityId = 1;
  inline bool has_entityid() const;
  inline void clear_entityid();
  static const int kEntityIdFieldNumber = 1;
  inline ::google::protobuf::int32 entityid() const;
  inline void set_entityid(::google::protobuf::int32 value);

  // required int32 groupId = 2;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::int32 groupid() const;
  inline void set_groupid(::google::protobuf::int32 value);

  // required int32 classId = 3;
  inline bool has_classid() const;
  inline void clear_classid();
  static const int kClassIdFieldNumber = 3;
  inline ::google::protobuf::int32 classid() const;
  inline void set_classid(::google::protobuf::int32 value);

  // required float positionX = 4;
  inline bool has_positionx() const;
  inline void clear_positionx();
  static const int kPositionXFieldNumber = 4;
  inline float positionx() const;
  inline void set_positionx(float value);

  // required float positionY = 5;
  inline bool has_positiony() const;
  inline void clear_positiony();
  static const int kPositionYFieldNumber = 5;
  inline float positiony() const;
  inline void set_positiony(float value);

  // required float positionZ = 6;
  inline bool has_positionz() const;
  inline void clear_positionz();
  static const int kPositionZFieldNumber = 6;
  inline float positionz() const;
  inline void set_positionz(float value);

  // required float heading = 7;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 7;
  inline float heading() const;
  inline void set_heading(float value);

  // required float pitch = 8;
  inline bool has_pitch() const;
  inline void clear_pitch();
  static const int kPitchFieldNumber = 8;
  inline float pitch() const;
  inline void set_pitch(float value);

  // required float roll = 9;
  inline bool has_roll() const;
  inline void clear_roll();
  static const int kRollFieldNumber = 9;
  inline float roll() const;
  inline void set_roll(float value);

  // optional uint32 quantity = 10;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 10;
  inline ::google::protobuf::uint32 quantity() const;
  inline void set_quantity(::google::protobuf::uint32 value);

  // optional uint32 quantityMax = 11;
  inline bool has_quantitymax() const;
  inline void clear_quantitymax();
  static const int kQuantityMaxFieldNumber = 11;
  inline ::google::protobuf::uint32 quantitymax() const;
  inline void set_quantitymax(::google::protobuf::uint32 value);

  // optional uint32 health = 12;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 12;
  inline ::google::protobuf::uint32 health() const;
  inline void set_health(::google::protobuf::uint32 value);

  // optional uint32 healthMax = 13;
  inline bool has_healthmax() const;
  inline void clear_healthmax();
  static const int kHealthMaxFieldNumber = 13;
  inline ::google::protobuf::uint32 healthmax() const;
  inline void set_healthmax(::google::protobuf::uint32 value);

  // optional uint32 armor = 14;
  inline bool has_armor() const;
  inline void clear_armor();
  static const int kArmorFieldNumber = 14;
  inline ::google::protobuf::uint32 armor() const;
  inline void set_armor(::google::protobuf::uint32 value);

  // optional uint32 armorMax = 15;
  inline bool has_armormax() const;
  inline void clear_armormax();
  static const int kArmorMaxFieldNumber = 15;
  inline ::google::protobuf::uint32 armormax() const;
  inline void set_armormax(::google::protobuf::uint32 value);

  // optional uint32 ammo1 = 16;
  inline bool has_ammo1() const;
  inline void clear_ammo1();
  static const int kAmmo1FieldNumber = 16;
  inline ::google::protobuf::uint32 ammo1() const;
  inline void set_ammo1(::google::protobuf::uint32 value);

  // optional uint32 ammo1Max = 17;
  inline bool has_ammo1max() const;
  inline void clear_ammo1max();
  static const int kAmmo1MaxFieldNumber = 17;
  inline ::google::protobuf::uint32 ammo1max() const;
  inline void set_ammo1max(::google::protobuf::uint32 value);

  // optional uint32 ammo2 = 18;
  inline bool has_ammo2() const;
  inline void clear_ammo2();
  static const int kAmmo2FieldNumber = 18;
  inline ::google::protobuf::uint32 ammo2() const;
  inline void set_ammo2(::google::protobuf::uint32 value);

  // optional uint32 ammo2Max = 19;
  inline bool has_ammo2max() const;
  inline void clear_ammo2max();
  static const int kAmmo2MaxFieldNumber = 19;
  inline ::google::protobuf::uint32 ammo2max() const;
  inline void set_ammo2max(::google::protobuf::uint32 value);

  // optional uint32 ammo3 = 20;
  inline bool has_ammo3() const;
  inline void clear_ammo3();
  static const int kAmmo3FieldNumber = 20;
  inline ::google::protobuf::uint32 ammo3() const;
  inline void set_ammo3(::google::protobuf::uint32 value);

  // optional uint32 ammo3Max = 21;
  inline bool has_ammo3max() const;
  inline void clear_ammo3max();
  static const int kAmmo3MaxFieldNumber = 21;
  inline ::google::protobuf::uint32 ammo3max() const;
  inline void set_ammo3max(::google::protobuf::uint32 value);

  // optional uint32 ammo4 = 22;
  inline bool has_ammo4() const;
  inline void clear_ammo4();
  static const int kAmmo4FieldNumber = 22;
  inline ::google::protobuf::uint32 ammo4() const;
  inline void set_ammo4(::google::protobuf::uint32 value);

  // optional uint32 ammo4Max = 23;
  inline bool has_ammo4max() const;
  inline void clear_ammo4max();
  static const int kAmmo4MaxFieldNumber = 23;
  inline ::google::protobuf::uint32 ammo4max() const;
  inline void set_ammo4max(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityInfo)
 private:
  inline void set_has_entityid();
  inline void clear_has_entityid();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_classid();
  inline void clear_has_classid();
  inline void set_has_positionx();
  inline void clear_has_positionx();
  inline void set_has_positiony();
  inline void clear_has_positiony();
  inline void set_has_positionz();
  inline void clear_has_positionz();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_pitch();
  inline void clear_has_pitch();
  inline void set_has_roll();
  inline void clear_has_roll();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_quantitymax();
  inline void clear_has_quantitymax();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_healthmax();
  inline void clear_has_healthmax();
  inline void set_has_armor();
  inline void clear_has_armor();
  inline void set_has_armormax();
  inline void clear_has_armormax();
  inline void set_has_ammo1();
  inline void clear_has_ammo1();
  inline void set_has_ammo1max();
  inline void clear_has_ammo1max();
  inline void set_has_ammo2();
  inline void clear_has_ammo2();
  inline void set_has_ammo2max();
  inline void clear_has_ammo2max();
  inline void set_has_ammo3();
  inline void clear_has_ammo3();
  inline void set_has_ammo3max();
  inline void clear_has_ammo3max();
  inline void set_has_ammo4();
  inline void clear_has_ammo4();
  inline void set_has_ammo4max();
  inline void clear_has_ammo4max();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 entityid_;
  ::google::protobuf::int32 groupid_;
  ::google::protobuf::int32 classid_;
  float positionx_;
  float positiony_;
  float positionz_;
  float heading_;
  float pitch_;
  float roll_;
  ::google::protobuf::uint32 quantity_;
  ::google::protobuf::uint32 quantitymax_;
  ::google::protobuf::uint32 health_;
  ::google::protobuf::uint32 healthmax_;
  ::google::protobuf::uint32 armor_;
  ::google::protobuf::uint32 armormax_;
  ::google::protobuf::uint32 ammo1_;
  ::google::protobuf::uint32 ammo1max_;
  ::google::protobuf::uint32 ammo2_;
  ::google::protobuf::uint32 ammo2max_;
  ::google::protobuf::uint32 ammo3_;
  ::google::protobuf::uint32 ammo3max_;
  ::google::protobuf::uint32 ammo4_;
  ::google::protobuf::uint32 ammo4max_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameEntityInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameEntityList : public ::google::protobuf::Message {
 public:
  GameEntityList();
  virtual ~GameEntityList();

  GameEntityList(const GameEntityList& from);

  inline GameEntityList& operator=(const GameEntityList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameEntityList& default_instance();

  void Swap(GameEntityList* other);

  // implements Message ----------------------------------------------

  GameEntityList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameEntityList& from);
  void MergeFrom(const GameEntityList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Analytics.GameEntityInfo entities = 1;
  inline int entities_size() const;
  inline void clear_entities();
  static const int kEntitiesFieldNumber = 1;
  inline const ::Analytics::GameEntityInfo& entities(int index) const;
  inline ::Analytics::GameEntityInfo* mutable_entities(int index);
  inline ::Analytics::GameEntityInfo* add_entities();
  inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >&
      entities() const;
  inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >*
      mutable_entities();

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo > entities_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameEntityList* default_instance_;
};
// -------------------------------------------------------------------

class GameWeaponFired : public ::google::protobuf::Message {
 public:
  GameWeaponFired();
  virtual ~GameWeaponFired();

  GameWeaponFired(const GameWeaponFired& from);

  inline GameWeaponFired& operator=(const GameWeaponFired& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameWeaponFired& default_instance();

  void Swap(GameWeaponFired* other);

  // implements Message ----------------------------------------------

  GameWeaponFired* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameWeaponFired& from);
  void MergeFrom(const GameWeaponFired& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 weaponId = 1;
  inline bool has_weaponid() const;
  inline void clear_weaponid();
  static const int kWeaponIdFieldNumber = 1;
  inline ::google::protobuf::int32 weaponid() const;
  inline void set_weaponid(::google::protobuf::int32 value);

  // required float positionX = 2;
  inline bool has_positionx() const;
  inline void clear_positionx();
  static const int kPositionXFieldNumber = 2;
  inline float positionx() const;
  inline void set_positionx(float value);

  // required float positionY = 3;
  inline bool has_positiony() const;
  inline void clear_positiony();
  static const int kPositionYFieldNumber = 3;
  inline float positiony() const;
  inline void set_positiony(float value);

  // required float positionZ = 4;
  inline bool has_positionz() const;
  inline void clear_positionz();
  static const int kPositionZFieldNumber = 4;
  inline float positionz() const;
  inline void set_positionz(float value);

  // @@protoc_insertion_point(class_scope:Analytics.GameWeaponFired)
 private:
  inline void set_has_weaponid();
  inline void clear_has_weaponid();
  inline void set_has_positionx();
  inline void clear_has_positionx();
  inline void set_has_positiony();
  inline void clear_has_positiony();
  inline void set_has_positionz();
  inline void clear_has_positionz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 weaponid_;
  float positionx_;
  float positiony_;
  float positionz_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameWeaponFired* default_instance_;
};
// -------------------------------------------------------------------

class GameDeath : public ::google::protobuf::Message {
 public:
  GameDeath();
  virtual ~GameDeath();

  GameDeath(const GameDeath& from);

  inline GameDeath& operator=(const GameDeath& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameDeath& default_instance();

  void Swap(GameDeath* other);

  // implements Message ----------------------------------------------

  GameDeath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameDeath& from);
  void MergeFrom(const GameDeath& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 killedByClass = 1;
  inline bool has_killedbyclass() const;
  inline void clear_killedbyclass();
  static const int kKilledByClassFieldNumber = 1;
  inline ::google::protobuf::int32 killedbyclass() const;
  inline void set_killedbyclass(::google::protobuf::int32 value);

  // required int32 killedByWeapon = 2;
  inline bool has_killedbyweapon() const;
  inline void clear_killedbyweapon();
  static const int kKilledByWeaponFieldNumber = 2;
  inline ::google::protobuf::int32 killedbyweapon() const;
  inline void set_killedbyweapon(::google::protobuf::int32 value);

  // required int32 killedByHealth = 3;
  inline bool has_killedbyhealth() const;
  inline void clear_killedbyhealth();
  static const int kKilledByHealthFieldNumber = 3;
  inline ::google::protobuf::int32 killedbyhealth() const;
  inline void set_killedbyhealth(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameDeath)
 private:
  inline void set_has_killedbyclass();
  inline void clear_has_killedbyclass();
  inline void set_has_killedbyweapon();
  inline void clear_has_killedbyweapon();
  inline void set_has_killedbyhealth();
  inline void clear_has_killedbyhealth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 killedbyclass_;
  ::google::protobuf::int32 killedbyweapon_;
  ::google::protobuf::int32 killedbyhealth_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameDeath* default_instance_;
};
// -------------------------------------------------------------------

class GameTookDamage : public ::google::protobuf::Message {
 public:
  GameTookDamage();
  virtual ~GameTookDamage();

  GameTookDamage(const GameTookDamage& from);

  inline GameTookDamage& operator=(const GameTookDamage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameTookDamage& default_instance();

  void Swap(GameTookDamage* other);

  // implements Message ----------------------------------------------

  GameTookDamage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameTookDamage& from);
  void MergeFrom(const GameTookDamage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 weaponId = 1;
  inline bool has_weaponid() const;
  inline void clear_weaponid();
  static const int kWeaponIdFieldNumber = 1;
  inline ::google::protobuf::int32 weaponid() const;
  inline void set_weaponid(::google::protobuf::int32 value);

  // required float positionX = 2;
  inline bool has_positionx() const;
  inline void clear_positionx();
  static const int kPositionXFieldNumber = 2;
  inline float positionx() const;
  inline void set_positionx(float value);

  // required float positionY = 3;
  inline bool has_positiony() const;
  inline void clear_positiony();
  static const int kPositionYFieldNumber = 3;
  inline float positiony() const;
  inline void set_positiony(float value);

  // required float positionZ = 4;
  inline bool has_positionz() const;
  inline void clear_positionz();
  static const int kPositionZFieldNumber = 4;
  inline float positionz() const;
  inline void set_positionz(float value);

  // @@protoc_insertion_point(class_scope:Analytics.GameTookDamage)
 private:
  inline void set_has_weaponid();
  inline void clear_has_weaponid();
  inline void set_has_positionx();
  inline void clear_has_positionx();
  inline void set_has_positiony();
  inline void clear_has_positiony();
  inline void set_has_positionz();
  inline void clear_has_positionz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 weaponid_;
  float positionx_;
  float positiony_;
  float positionz_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameTookDamage* default_instance_;
};
// -------------------------------------------------------------------

class GameNavigationStuck : public ::google::protobuf::Message {
 public:
  GameNavigationStuck();
  virtual ~GameNavigationStuck();

  GameNavigationStuck(const GameNavigationStuck& from);

  inline GameNavigationStuck& operator=(const GameNavigationStuck& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameNavigationStuck& default_instance();

  void Swap(GameNavigationStuck* other);

  // implements Message ----------------------------------------------

  GameNavigationStuck* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameNavigationStuck& from);
  void MergeFrom(const GameNavigationStuck& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 entityId = 1;
  inline bool has_entityid() const;
  inline void clear_entityid();
  static const int kEntityIdFieldNumber = 1;
  inline ::google::protobuf::int32 entityid() const;
  inline void set_entityid(::google::protobuf::int32 value);

  // required float positionX = 2;
  inline bool has_positionx() const;
  inline void clear_positionx();
  static const int kPositionXFieldNumber = 2;
  inline float positionx() const;
  inline void set_positionx(float value);

  // required float positionY = 3;
  inline bool has_positiony() const;
  inline void clear_positiony();
  static const int kPositionYFieldNumber = 3;
  inline float positiony() const;
  inline void set_positiony(float value);

  // required float positionZ = 4;
  inline bool has_positionz() const;
  inline void clear_positionz();
  static const int kPositionZFieldNumber = 4;
  inline float positionz() const;
  inline void set_positionz(float value);

  // @@protoc_insertion_point(class_scope:Analytics.GameNavigationStuck)
 private:
  inline void set_has_entityid();
  inline void clear_has_entityid();
  inline void set_has_positionx();
  inline void clear_has_positionx();
  inline void set_has_positiony();
  inline void clear_has_positiony();
  inline void set_has_positionz();
  inline void clear_has_positionz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 entityid_;
  float positionx_;
  float positiony_;
  float positionz_;
  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static GameNavigationStuck* default_instance_;
};
// -------------------------------------------------------------------

class MessageUnion : public ::google::protobuf::Message {
 public:
  MessageUnion();
  virtual ~MessageUnion();

  MessageUnion(const MessageUnion& from);

  inline MessageUnion& operator=(const MessageUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageUnion& default_instance();

  enum MsgCase {
    kSystemNavNotFound = 2,
    kSystemNavDownloaded = 3,
    kSystemAssert = 4,
    kSystemCrash = 5,
    kSystemModelData = 6,
    kGameEntityList = 100,
    kGameWeaponFired = 101,
    kGameDeath = 102,
    kGameTookDamage = 103,
    kGameNavigationStuck = 104,
    kTopicSubscribe = 1000,
    kTopicUnsubscribe = 1001,
    MSG_NOT_SET = 0,
  };

  void Swap(MessageUnion* other);

  // implements Message ----------------------------------------------

  MessageUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageUnion& from);
  void MergeFrom(const MessageUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 timestamp = 1;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional .Analytics.SystemNavNotFound systemNavNotFound = 2;
  inline bool has_systemnavnotfound() const;
  inline void clear_systemnavnotfound();
  static const int kSystemNavNotFoundFieldNumber = 2;
  inline const ::Analytics::SystemNavNotFound& systemnavnotfound() const;
  inline ::Analytics::SystemNavNotFound* mutable_systemnavnotfound();
  inline ::Analytics::SystemNavNotFound* release_systemnavnotfound();
  inline void set_allocated_systemnavnotfound(::Analytics::SystemNavNotFound* systemnavnotfound);

  // optional .Analytics.SystemNavAutoDownloaded systemNavDownloaded = 3;
  inline bool has_systemnavdownloaded() const;
  inline void clear_systemnavdownloaded();
  static const int kSystemNavDownloadedFieldNumber = 3;
  inline const ::Analytics::SystemNavAutoDownloaded& systemnavdownloaded() const;
  inline ::Analytics::SystemNavAutoDownloaded* mutable_systemnavdownloaded();
  inline ::Analytics::SystemNavAutoDownloaded* release_systemnavdownloaded();
  inline void set_allocated_systemnavdownloaded(::Analytics::SystemNavAutoDownloaded* systemnavdownloaded);

  // optional .Analytics.SystemAssert systemAssert = 4;
  inline bool has_systemassert() const;
  inline void clear_systemassert();
  static const int kSystemAssertFieldNumber = 4;
  inline const ::Analytics::SystemAssert& systemassert() const;
  inline ::Analytics::SystemAssert* mutable_systemassert();
  inline ::Analytics::SystemAssert* release_systemassert();
  inline void set_allocated_systemassert(::Analytics::SystemAssert* systemassert);

  // optional .Analytics.SystemCrash systemCrash = 5;
  inline bool has_systemcrash() const;
  inline void clear_systemcrash();
  static const int kSystemCrashFieldNumber = 5;
  inline const ::Analytics::SystemCrash& systemcrash() const;
  inline ::Analytics::SystemCrash* mutable_systemcrash();
  inline ::Analytics::SystemCrash* release_systemcrash();
  inline void set_allocated_systemcrash(::Analytics::SystemCrash* systemcrash);

  // optional .Analytics.SystemModelData systemModelData = 6;
  inline bool has_systemmodeldata() const;
  inline void clear_systemmodeldata();
  static const int kSystemModelDataFieldNumber = 6;
  inline const ::Analytics::SystemModelData& systemmodeldata() const;
  inline ::Analytics::SystemModelData* mutable_systemmodeldata();
  inline ::Analytics::SystemModelData* release_systemmodeldata();
  inline void set_allocated_systemmodeldata(::Analytics::SystemModelData* systemmodeldata);

  // optional .Analytics.GameEntityList gameEntityList = 100;
  inline bool has_gameentitylist() const;
  inline void clear_gameentitylist();
  static const int kGameEntityListFieldNumber = 100;
  inline const ::Analytics::GameEntityList& gameentitylist() const;
  inline ::Analytics::GameEntityList* mutable_gameentitylist();
  inline ::Analytics::GameEntityList* release_gameentitylist();
  inline void set_allocated_gameentitylist(::Analytics::GameEntityList* gameentitylist);

  // optional .Analytics.GameWeaponFired gameWeaponFired = 101;
  inline bool has_gameweaponfired() const;
  inline void clear_gameweaponfired();
  static const int kGameWeaponFiredFieldNumber = 101;
  inline const ::Analytics::GameWeaponFired& gameweaponfired() const;
  inline ::Analytics::GameWeaponFired* mutable_gameweaponfired();
  inline ::Analytics::GameWeaponFired* release_gameweaponfired();
  inline void set_allocated_gameweaponfired(::Analytics::GameWeaponFired* gameweaponfired);

  // optional .Analytics.GameDeath gameDeath = 102;
  inline bool has_gamedeath() const;
  inline void clear_gamedeath();
  static const int kGameDeathFieldNumber = 102;
  inline const ::Analytics::GameDeath& gamedeath() const;
  inline ::Analytics::GameDeath* mutable_gamedeath();
  inline ::Analytics::GameDeath* release_gamedeath();
  inline void set_allocated_gamedeath(::Analytics::GameDeath* gamedeath);

  // optional .Analytics.GameTookDamage gameTookDamage = 103;
  inline bool has_gametookdamage() const;
  inline void clear_gametookdamage();
  static const int kGameTookDamageFieldNumber = 103;
  inline const ::Analytics::GameTookDamage& gametookdamage() const;
  inline ::Analytics::GameTookDamage* mutable_gametookdamage();
  inline ::Analytics::GameTookDamage* release_gametookdamage();
  inline void set_allocated_gametookdamage(::Analytics::GameTookDamage* gametookdamage);

  // optional .Analytics.GameNavigationStuck gameNavigationStuck = 104;
  inline bool has_gamenavigationstuck() const;
  inline void clear_gamenavigationstuck();
  static const int kGameNavigationStuckFieldNumber = 104;
  inline const ::Analytics::GameNavigationStuck& gamenavigationstuck() const;
  inline ::Analytics::GameNavigationStuck* mutable_gamenavigationstuck();
  inline ::Analytics::GameNavigationStuck* release_gamenavigationstuck();
  inline void set_allocated_gamenavigationstuck(::Analytics::GameNavigationStuck* gamenavigationstuck);

  // optional .Analytics.TopicSubscribe topicSubscribe = 1000;
  inline bool has_topicsubscribe() const;
  inline void clear_topicsubscribe();
  static const int kTopicSubscribeFieldNumber = 1000;
  inline const ::Analytics::TopicSubscribe& topicsubscribe() const;
  inline ::Analytics::TopicSubscribe* mutable_topicsubscribe();
  inline ::Analytics::TopicSubscribe* release_topicsubscribe();
  inline void set_allocated_topicsubscribe(::Analytics::TopicSubscribe* topicsubscribe);

  // optional .Analytics.TopicUnsubscribe topicUnsubscribe = 1001;
  inline bool has_topicunsubscribe() const;
  inline void clear_topicunsubscribe();
  static const int kTopicUnsubscribeFieldNumber = 1001;
  inline const ::Analytics::TopicUnsubscribe& topicunsubscribe() const;
  inline ::Analytics::TopicUnsubscribe* mutable_topicunsubscribe();
  inline ::Analytics::TopicUnsubscribe* release_topicunsubscribe();
  inline void set_allocated_topicunsubscribe(::Analytics::TopicUnsubscribe* topicunsubscribe);

  inline MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:Analytics.MessageUnion)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_systemnavnotfound();
  inline void set_has_systemnavdownloaded();
  inline void set_has_systemassert();
  inline void set_has_systemcrash();
  inline void set_has_systemmodeldata();
  inline void set_has_gameentitylist();
  inline void set_has_gameweaponfired();
  inline void set_has_gamedeath();
  inline void set_has_gametookdamage();
  inline void set_has_gamenavigationstuck();
  inline void set_has_topicsubscribe();
  inline void set_has_topicunsubscribe();

  inline bool has_msg();
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 timestamp_;
  union MsgUnion {
    ::Analytics::SystemNavNotFound* systemnavnotfound_;
    ::Analytics::SystemNavAutoDownloaded* systemnavdownloaded_;
    ::Analytics::SystemAssert* systemassert_;
    ::Analytics::SystemCrash* systemcrash_;
    ::Analytics::SystemModelData* systemmodeldata_;
    ::Analytics::GameEntityList* gameentitylist_;
    ::Analytics::GameWeaponFired* gameweaponfired_;
    ::Analytics::GameDeath* gamedeath_;
    ::Analytics::GameTookDamage* gametookdamage_;
    ::Analytics::GameNavigationStuck* gamenavigationstuck_;
    ::Analytics::TopicSubscribe* topicsubscribe_;
    ::Analytics::TopicUnsubscribe* topicunsubscribe_;
  } msg_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_analytics_2eproto();
  friend void protobuf_AssignDesc_analytics_2eproto();
  friend void protobuf_ShutdownFile_analytics_2eproto();

  void InitAsDefaultInstance();
  static MessageUnion* default_instance_;
};
// ===================================================================

static const int kCachelastvalueFieldNumber = 5000;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  cachelastvalue;
static const int kCachekeysuffixFieldNumber = 5001;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  cachekeysuffix;

// ===================================================================

// TopicSubscribe

// required string topic = 1;
inline bool TopicSubscribe::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicSubscribe::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicSubscribe::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicSubscribe::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& TopicSubscribe::topic() const {
  // @@protoc_insertion_point(field_get:Analytics.TopicSubscribe.topic)
  return *topic_;
}
inline void TopicSubscribe::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.TopicSubscribe.topic)
}
inline void TopicSubscribe::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.TopicSubscribe.topic)
}
inline void TopicSubscribe::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.TopicSubscribe.topic)
}
inline ::std::string* TopicSubscribe::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.TopicSubscribe.topic)
  return topic_;
}
inline ::std::string* TopicSubscribe::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TopicSubscribe::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.TopicSubscribe.topic)
}

// -------------------------------------------------------------------

// TopicUnsubscribe

// required string topic = 1;
inline bool TopicUnsubscribe::has_topic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicUnsubscribe::set_has_topic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicUnsubscribe::clear_has_topic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicUnsubscribe::clear_topic() {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_->clear();
  }
  clear_has_topic();
}
inline const ::std::string& TopicUnsubscribe::topic() const {
  // @@protoc_insertion_point(field_get:Analytics.TopicUnsubscribe.topic)
  return *topic_;
}
inline void TopicUnsubscribe::set_topic(const ::std::string& value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.TopicUnsubscribe.topic)
}
inline void TopicUnsubscribe::set_topic(const char* value) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.TopicUnsubscribe.topic)
}
inline void TopicUnsubscribe::set_topic(const char* value, size_t size) {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  topic_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.TopicUnsubscribe.topic)
}
inline ::std::string* TopicUnsubscribe::mutable_topic() {
  set_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    topic_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.TopicUnsubscribe.topic)
  return topic_;
}
inline ::std::string* TopicUnsubscribe::release_topic() {
  clear_has_topic();
  if (topic_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = topic_;
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TopicUnsubscribe::set_allocated_topic(::std::string* topic) {
  if (topic_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete topic_;
  }
  if (topic) {
    set_has_topic();
    topic_ = topic;
  } else {
    clear_has_topic();
    topic_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.TopicUnsubscribe.topic)
}

// -------------------------------------------------------------------

// SystemNavNotFound

// required string mapName = 1;
inline bool SystemNavNotFound::has_mapname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemNavNotFound::set_has_mapname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemNavNotFound::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemNavNotFound::clear_mapname() {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_->clear();
  }
  clear_has_mapname();
}
inline const ::std::string& SystemNavNotFound::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemNavNotFound.mapName)
  return *mapname_;
}
inline void SystemNavNotFound::set_mapname(const ::std::string& value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemNavNotFound.mapName)
}
inline void SystemNavNotFound::set_mapname(const char* value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemNavNotFound.mapName)
}
inline void SystemNavNotFound::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemNavNotFound.mapName)
}
inline ::std::string* SystemNavNotFound::mutable_mapname() {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemNavNotFound.mapName)
  return mapname_;
}
inline ::std::string* SystemNavNotFound::release_mapname() {
  clear_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapname_;
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemNavNotFound::set_allocated_mapname(::std::string* mapname) {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapname_;
  }
  if (mapname) {
    set_has_mapname();
    mapname_ = mapname;
  } else {
    clear_has_mapname();
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemNavNotFound.mapName)
}

// -------------------------------------------------------------------

// SystemNavAutoDownloaded

// required string mapName = 1;
inline bool SystemNavAutoDownloaded::has_mapname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemNavAutoDownloaded::set_has_mapname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemNavAutoDownloaded::clear_has_mapname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemNavAutoDownloaded::clear_mapname() {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_->clear();
  }
  clear_has_mapname();
}
inline const ::std::string& SystemNavAutoDownloaded::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemNavAutoDownloaded.mapName)
  return *mapname_;
}
inline void SystemNavAutoDownloaded::set_mapname(const ::std::string& value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemNavAutoDownloaded.mapName)
}
inline void SystemNavAutoDownloaded::set_mapname(const char* value) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemNavAutoDownloaded.mapName)
}
inline void SystemNavAutoDownloaded::set_mapname(const char* value, size_t size) {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  mapname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemNavAutoDownloaded.mapName)
}
inline ::std::string* SystemNavAutoDownloaded::mutable_mapname() {
  set_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemNavAutoDownloaded.mapName)
  return mapname_;
}
inline ::std::string* SystemNavAutoDownloaded::release_mapname() {
  clear_has_mapname();
  if (mapname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapname_;
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemNavAutoDownloaded::set_allocated_mapname(::std::string* mapname) {
  if (mapname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapname_;
  }
  if (mapname) {
    set_has_mapname();
    mapname_ = mapname;
  } else {
    clear_has_mapname();
    mapname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemNavAutoDownloaded.mapName)
}

// -------------------------------------------------------------------

// SystemAssert

// required string condition = 1;
inline bool SystemAssert::has_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemAssert::set_has_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemAssert::clear_has_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemAssert::clear_condition() {
  if (condition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_->clear();
  }
  clear_has_condition();
}
inline const ::std::string& SystemAssert::condition() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemAssert.condition)
  return *condition_;
}
inline void SystemAssert::set_condition(const ::std::string& value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemAssert.condition)
}
inline void SystemAssert::set_condition(const char* value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemAssert.condition)
}
inline void SystemAssert::set_condition(const char* value, size_t size) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  condition_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemAssert.condition)
}
inline ::std::string* SystemAssert::mutable_condition() {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    condition_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemAssert.condition)
  return condition_;
}
inline ::std::string* SystemAssert::release_condition() {
  clear_has_condition();
  if (condition_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = condition_;
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemAssert::set_allocated_condition(::std::string* condition) {
  if (condition_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete condition_;
  }
  if (condition) {
    set_has_condition();
    condition_ = condition;
  } else {
    clear_has_condition();
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemAssert.condition)
}

// optional string file = 2;
inline bool SystemAssert::has_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemAssert::set_has_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemAssert::clear_has_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemAssert::clear_file() {
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_->clear();
  }
  clear_has_file();
}
inline const ::std::string& SystemAssert::file() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemAssert.file)
  return *file_;
}
inline void SystemAssert::set_file(const ::std::string& value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemAssert.file)
}
inline void SystemAssert::set_file(const char* value) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemAssert.file)
}
inline void SystemAssert::set_file(const char* value, size_t size) {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  file_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemAssert.file)
}
inline ::std::string* SystemAssert::mutable_file() {
  set_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemAssert.file)
  return file_;
}
inline ::std::string* SystemAssert::release_file() {
  clear_has_file();
  if (file_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_;
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemAssert::set_allocated_file(::std::string* file) {
  if (file_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_;
  }
  if (file) {
    set_has_file();
    file_ = file;
  } else {
    clear_has_file();
    file_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemAssert.file)
}

// optional int32 line = 3;
inline bool SystemAssert::has_line() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemAssert::set_has_line() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemAssert::clear_has_line() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemAssert::clear_line() {
  line_ = 0;
  clear_has_line();
}
inline ::google::protobuf::int32 SystemAssert::line() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemAssert.line)
  return line_;
}
inline void SystemAssert::set_line(::google::protobuf::int32 value) {
  set_has_line();
  line_ = value;
  // @@protoc_insertion_point(field_set:Analytics.SystemAssert.line)
}

// -------------------------------------------------------------------

// SystemCrash

// required string info = 1;
inline bool SystemCrash::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemCrash::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemCrash::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemCrash::clear_info() {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& SystemCrash::info() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemCrash.info)
  return *info_;
}
inline void SystemCrash::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemCrash.info)
}
inline void SystemCrash::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemCrash.info)
}
inline void SystemCrash::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemCrash.info)
}
inline ::std::string* SystemCrash::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    info_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemCrash.info)
  return info_;
}
inline ::std::string* SystemCrash::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemCrash::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemCrash.info)
}

// -------------------------------------------------------------------

// SystemModelData

// optional .Analytics.Compression compressionType = 1 [default = Compression_None];
inline bool SystemModelData::has_compressiontype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemModelData::set_has_compressiontype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemModelData::clear_has_compressiontype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemModelData::clear_compressiontype() {
  compressiontype_ = 0;
  clear_has_compressiontype();
}
inline ::Analytics::Compression SystemModelData::compressiontype() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemModelData.compressionType)
  return static_cast< ::Analytics::Compression >(compressiontype_);
}
inline void SystemModelData::set_compressiontype(::Analytics::Compression value) {
  assert(::Analytics::Compression_IsValid(value));
  set_has_compressiontype();
  compressiontype_ = value;
  // @@protoc_insertion_point(field_set:Analytics.SystemModelData.compressionType)
}

// required string modelName = 2;
inline bool SystemModelData::has_modelname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemModelData::set_has_modelname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemModelData::clear_has_modelname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemModelData::clear_modelname() {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_->clear();
  }
  clear_has_modelname();
}
inline const ::std::string& SystemModelData::modelname() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemModelData.modelName)
  return *modelname_;
}
inline void SystemModelData::set_modelname(const ::std::string& value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemModelData.modelName)
}
inline void SystemModelData::set_modelname(const char* value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemModelData.modelName)
}
inline void SystemModelData::set_modelname(const char* value, size_t size) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemModelData.modelName)
}
inline ::std::string* SystemModelData::mutable_modelname() {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemModelData.modelName)
  return modelname_;
}
inline ::std::string* SystemModelData::release_modelname() {
  clear_has_modelname();
  if (modelname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelname_;
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemModelData::set_allocated_modelname(::std::string* modelname) {
  if (modelname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelname_;
  }
  if (modelname) {
    set_has_modelname();
    modelname_ = modelname;
  } else {
    clear_has_modelname();
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemModelData.modelName)
}

// required bytes modelBytes = 3;
inline bool SystemModelData::has_modelbytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SystemModelData::set_has_modelbytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SystemModelData::clear_has_modelbytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SystemModelData::clear_modelbytes() {
  if (modelbytes_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_->clear();
  }
  clear_has_modelbytes();
}
inline const ::std::string& SystemModelData::modelbytes() const {
  // @@protoc_insertion_point(field_get:Analytics.SystemModelData.modelBytes)
  return *modelbytes_;
}
inline void SystemModelData::set_modelbytes(const ::std::string& value) {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  modelbytes_->assign(value);
  // @@protoc_insertion_point(field_set:Analytics.SystemModelData.modelBytes)
}
inline void SystemModelData::set_modelbytes(const char* value) {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  modelbytes_->assign(value);
  // @@protoc_insertion_point(field_set_char:Analytics.SystemModelData.modelBytes)
}
inline void SystemModelData::set_modelbytes(const void* value, size_t size) {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  modelbytes_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Analytics.SystemModelData.modelBytes)
}
inline ::std::string* SystemModelData::mutable_modelbytes() {
  set_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    modelbytes_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.SystemModelData.modelBytes)
  return modelbytes_;
}
inline ::std::string* SystemModelData::release_modelbytes() {
  clear_has_modelbytes();
  if (modelbytes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = modelbytes_;
    modelbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SystemModelData::set_allocated_modelbytes(::std::string* modelbytes) {
  if (modelbytes_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete modelbytes_;
  }
  if (modelbytes) {
    set_has_modelbytes();
    modelbytes_ = modelbytes;
  } else {
    clear_has_modelbytes();
    modelbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Analytics.SystemModelData.modelBytes)
}

// -------------------------------------------------------------------

// GameEntityInfo

// required int32 entityId = 1;
inline bool GameEntityInfo::has_entityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameEntityInfo::set_has_entityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameEntityInfo::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameEntityInfo::clear_entityid() {
  entityid_ = 0;
  clear_has_entityid();
}
inline ::google::protobuf::int32 GameEntityInfo::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entityId)
  return entityid_;
}
inline void GameEntityInfo::set_entityid(::google::protobuf::int32 value) {
  set_has_entityid();
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entityId)
}

// required int32 groupId = 2;
inline bool GameEntityInfo::has_groupid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameEntityInfo::set_has_groupid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameEntityInfo::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameEntityInfo::clear_groupid() {
  groupid_ = 0;
  clear_has_groupid();
}
inline ::google::protobuf::int32 GameEntityInfo::groupid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.groupId)
  return groupid_;
}
inline void GameEntityInfo::set_groupid(::google::protobuf::int32 value) {
  set_has_groupid();
  groupid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.groupId)
}

// required int32 classId = 3;
inline bool GameEntityInfo::has_classid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameEntityInfo::set_has_classid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameEntityInfo::clear_has_classid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameEntityInfo::clear_classid() {
  classid_ = 0;
  clear_has_classid();
}
inline ::google::protobuf::int32 GameEntityInfo::classid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.classId)
  return classid_;
}
inline void GameEntityInfo::set_classid(::google::protobuf::int32 value) {
  set_has_classid();
  classid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.classId)
}

// required float positionX = 4;
inline bool GameEntityInfo::has_positionx() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameEntityInfo::set_has_positionx() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameEntityInfo::clear_has_positionx() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameEntityInfo::clear_positionx() {
  positionx_ = 0;
  clear_has_positionx();
}
inline float GameEntityInfo::positionx() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.positionX)
  return positionx_;
}
inline void GameEntityInfo::set_positionx(float value) {
  set_has_positionx();
  positionx_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.positionX)
}

// required float positionY = 5;
inline bool GameEntityInfo::has_positiony() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameEntityInfo::set_has_positiony() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameEntityInfo::clear_has_positiony() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameEntityInfo::clear_positiony() {
  positiony_ = 0;
  clear_has_positiony();
}
inline float GameEntityInfo::positiony() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.positionY)
  return positiony_;
}
inline void GameEntityInfo::set_positiony(float value) {
  set_has_positiony();
  positiony_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.positionY)
}

// required float positionZ = 6;
inline bool GameEntityInfo::has_positionz() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameEntityInfo::set_has_positionz() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameEntityInfo::clear_has_positionz() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameEntityInfo::clear_positionz() {
  positionz_ = 0;
  clear_has_positionz();
}
inline float GameEntityInfo::positionz() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.positionZ)
  return positionz_;
}
inline void GameEntityInfo::set_positionz(float value) {
  set_has_positionz();
  positionz_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.positionZ)
}

// required float heading = 7;
inline bool GameEntityInfo::has_heading() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameEntityInfo::set_has_heading() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameEntityInfo::clear_has_heading() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameEntityInfo::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float GameEntityInfo::heading() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.heading)
  return heading_;
}
inline void GameEntityInfo::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.heading)
}

// required float pitch = 8;
inline bool GameEntityInfo::has_pitch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameEntityInfo::set_has_pitch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameEntityInfo::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameEntityInfo::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float GameEntityInfo::pitch() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.pitch)
  return pitch_;
}
inline void GameEntityInfo::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.pitch)
}

// required float roll = 9;
inline bool GameEntityInfo::has_roll() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameEntityInfo::set_has_roll() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameEntityInfo::clear_has_roll() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameEntityInfo::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float GameEntityInfo::roll() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.roll)
  return roll_;
}
inline void GameEntityInfo::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.roll)
}

// optional uint32 quantity = 10;
inline bool GameEntityInfo::has_quantity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameEntityInfo::set_has_quantity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameEntityInfo::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameEntityInfo::clear_quantity() {
  quantity_ = 0u;
  clear_has_quantity();
}
inline ::google::protobuf::uint32 GameEntityInfo::quantity() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.quantity)
  return quantity_;
}
inline void GameEntityInfo::set_quantity(::google::protobuf::uint32 value) {
  set_has_quantity();
  quantity_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.quantity)
}

// optional uint32 quantityMax = 11;
inline bool GameEntityInfo::has_quantitymax() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameEntityInfo::set_has_quantitymax() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameEntityInfo::clear_has_quantitymax() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameEntityInfo::clear_quantitymax() {
  quantitymax_ = 0u;
  clear_has_quantitymax();
}
inline ::google::protobuf::uint32 GameEntityInfo::quantitymax() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.quantityMax)
  return quantitymax_;
}
inline void GameEntityInfo::set_quantitymax(::google::protobuf::uint32 value) {
  set_has_quantitymax();
  quantitymax_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.quantityMax)
}

// optional uint32 health = 12;
inline bool GameEntityInfo::has_health() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameEntityInfo::set_has_health() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameEntityInfo::clear_has_health() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameEntityInfo::clear_health() {
  health_ = 0u;
  clear_has_health();
}
inline ::google::protobuf::uint32 GameEntityInfo::health() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.health)
  return health_;
}
inline void GameEntityInfo::set_health(::google::protobuf::uint32 value) {
  set_has_health();
  health_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.health)
}

// optional uint32 healthMax = 13;
inline bool GameEntityInfo::has_healthmax() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameEntityInfo::set_has_healthmax() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameEntityInfo::clear_has_healthmax() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameEntityInfo::clear_healthmax() {
  healthmax_ = 0u;
  clear_has_healthmax();
}
inline ::google::protobuf::uint32 GameEntityInfo::healthmax() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.healthMax)
  return healthmax_;
}
inline void GameEntityInfo::set_healthmax(::google::protobuf::uint32 value) {
  set_has_healthmax();
  healthmax_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.healthMax)
}

// optional uint32 armor = 14;
inline bool GameEntityInfo::has_armor() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GameEntityInfo::set_has_armor() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GameEntityInfo::clear_has_armor() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GameEntityInfo::clear_armor() {
  armor_ = 0u;
  clear_has_armor();
}
inline ::google::protobuf::uint32 GameEntityInfo::armor() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.armor)
  return armor_;
}
inline void GameEntityInfo::set_armor(::google::protobuf::uint32 value) {
  set_has_armor();
  armor_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.armor)
}

// optional uint32 armorMax = 15;
inline bool GameEntityInfo::has_armormax() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GameEntityInfo::set_has_armormax() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GameEntityInfo::clear_has_armormax() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GameEntityInfo::clear_armormax() {
  armormax_ = 0u;
  clear_has_armormax();
}
inline ::google::protobuf::uint32 GameEntityInfo::armormax() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.armorMax)
  return armormax_;
}
inline void GameEntityInfo::set_armormax(::google::protobuf::uint32 value) {
  set_has_armormax();
  armormax_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.armorMax)
}

// optional uint32 ammo1 = 16;
inline bool GameEntityInfo::has_ammo1() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GameEntityInfo::set_has_ammo1() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GameEntityInfo::clear_has_ammo1() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GameEntityInfo::clear_ammo1() {
  ammo1_ = 0u;
  clear_has_ammo1();
}
inline ::google::protobuf::uint32 GameEntityInfo::ammo1() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo1)
  return ammo1_;
}
inline void GameEntityInfo::set_ammo1(::google::protobuf::uint32 value) {
  set_has_ammo1();
  ammo1_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.ammo1)
}

// optional uint32 ammo1Max = 17;
inline bool GameEntityInfo::has_ammo1max() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GameEntityInfo::set_has_ammo1max() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GameEntityInfo::clear_has_ammo1max() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GameEntityInfo::clear_ammo1max() {
  ammo1max_ = 0u;
  clear_has_ammo1max();
}
inline ::google::protobuf::uint32 GameEntityInfo::ammo1max() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo1Max)
  return ammo1max_;
}
inline void GameEntityInfo::set_ammo1max(::google::protobuf::uint32 value) {
  set_has_ammo1max();
  ammo1max_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.ammo1Max)
}

// optional uint32 ammo2 = 18;
inline bool GameEntityInfo::has_ammo2() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GameEntityInfo::set_has_ammo2() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GameEntityInfo::clear_has_ammo2() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GameEntityInfo::clear_ammo2() {
  ammo2_ = 0u;
  clear_has_ammo2();
}
inline ::google::protobuf::uint32 GameEntityInfo::ammo2() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo2)
  return ammo2_;
}
inline void GameEntityInfo::set_ammo2(::google::protobuf::uint32 value) {
  set_has_ammo2();
  ammo2_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.ammo2)
}

// optional uint32 ammo2Max = 19;
inline bool GameEntityInfo::has_ammo2max() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GameEntityInfo::set_has_ammo2max() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GameEntityInfo::clear_has_ammo2max() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GameEntityInfo::clear_ammo2max() {
  ammo2max_ = 0u;
  clear_has_ammo2max();
}
inline ::google::protobuf::uint32 GameEntityInfo::ammo2max() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo2Max)
  return ammo2max_;
}
inline void GameEntityInfo::set_ammo2max(::google::protobuf::uint32 value) {
  set_has_ammo2max();
  ammo2max_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.ammo2Max)
}

// optional uint32 ammo3 = 20;
inline bool GameEntityInfo::has_ammo3() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GameEntityInfo::set_has_ammo3() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GameEntityInfo::clear_has_ammo3() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GameEntityInfo::clear_ammo3() {
  ammo3_ = 0u;
  clear_has_ammo3();
}
inline ::google::protobuf::uint32 GameEntityInfo::ammo3() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo3)
  return ammo3_;
}
inline void GameEntityInfo::set_ammo3(::google::protobuf::uint32 value) {
  set_has_ammo3();
  ammo3_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.ammo3)
}

// optional uint32 ammo3Max = 21;
inline bool GameEntityInfo::has_ammo3max() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GameEntityInfo::set_has_ammo3max() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GameEntityInfo::clear_has_ammo3max() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GameEntityInfo::clear_ammo3max() {
  ammo3max_ = 0u;
  clear_has_ammo3max();
}
inline ::google::protobuf::uint32 GameEntityInfo::ammo3max() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo3Max)
  return ammo3max_;
}
inline void GameEntityInfo::set_ammo3max(::google::protobuf::uint32 value) {
  set_has_ammo3max();
  ammo3max_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.ammo3Max)
}

// optional uint32 ammo4 = 22;
inline bool GameEntityInfo::has_ammo4() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GameEntityInfo::set_has_ammo4() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GameEntityInfo::clear_has_ammo4() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GameEntityInfo::clear_ammo4() {
  ammo4_ = 0u;
  clear_has_ammo4();
}
inline ::google::protobuf::uint32 GameEntityInfo::ammo4() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo4)
  return ammo4_;
}
inline void GameEntityInfo::set_ammo4(::google::protobuf::uint32 value) {
  set_has_ammo4();
  ammo4_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.ammo4)
}

// optional uint32 ammo4Max = 23;
inline bool GameEntityInfo::has_ammo4max() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GameEntityInfo::set_has_ammo4max() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GameEntityInfo::clear_has_ammo4max() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GameEntityInfo::clear_ammo4max() {
  ammo4max_ = 0u;
  clear_has_ammo4max();
}
inline ::google::protobuf::uint32 GameEntityInfo::ammo4max() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo4Max)
  return ammo4max_;
}
inline void GameEntityInfo::set_ammo4max(::google::protobuf::uint32 value) {
  set_has_ammo4max();
  ammo4max_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.ammo4Max)
}

// -------------------------------------------------------------------

// GameEntityList

// repeated .Analytics.GameEntityInfo entities = 1;
inline int GameEntityList::entities_size() const {
  return entities_.size();
}
inline void GameEntityList::clear_entities() {
  entities_.Clear();
}
inline const ::Analytics::GameEntityInfo& GameEntityList::entities(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityList.entities)
  return entities_.Get(index);
}
inline ::Analytics::GameEntityInfo* GameEntityList::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityList.entities)
  return entities_.Mutable(index);
}
inline ::Analytics::GameEntityInfo* GameEntityList::add_entities() {
  // @@protoc_insertion_point(field_add:Analytics.GameEntityList.entities)
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >&
GameEntityList::entities() const {
  // @@protoc_insertion_point(field_list:Analytics.GameEntityList.entities)
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo >*
GameEntityList::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.GameEntityList.entities)
  return &entities_;
}

// -------------------------------------------------------------------

// GameWeaponFired

// required int32 weaponId = 1;
inline bool GameWeaponFired::has_weaponid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameWeaponFired::set_has_weaponid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameWeaponFired::clear_has_weaponid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameWeaponFired::clear_weaponid() {
  weaponid_ = 0;
  clear_has_weaponid();
}
inline ::google::protobuf::int32 GameWeaponFired::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.weaponId)
  return weaponid_;
}
inline void GameWeaponFired::set_weaponid(::google::protobuf::int32 value) {
  set_has_weaponid();
  weaponid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.weaponId)
}

// required float positionX = 2;
inline bool GameWeaponFired::has_positionx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameWeaponFired::set_has_positionx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameWeaponFired::clear_has_positionx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameWeaponFired::clear_positionx() {
  positionx_ = 0;
  clear_has_positionx();
}
inline float GameWeaponFired::positionx() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.positionX)
  return positionx_;
}
inline void GameWeaponFired::set_positionx(float value) {
  set_has_positionx();
  positionx_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.positionX)
}

// required float positionY = 3;
inline bool GameWeaponFired::has_positiony() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameWeaponFired::set_has_positiony() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameWeaponFired::clear_has_positiony() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameWeaponFired::clear_positiony() {
  positiony_ = 0;
  clear_has_positiony();
}
inline float GameWeaponFired::positiony() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.positionY)
  return positiony_;
}
inline void GameWeaponFired::set_positiony(float value) {
  set_has_positiony();
  positiony_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.positionY)
}

// required float positionZ = 4;
inline bool GameWeaponFired::has_positionz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameWeaponFired::set_has_positionz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameWeaponFired::clear_has_positionz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameWeaponFired::clear_positionz() {
  positionz_ = 0;
  clear_has_positionz();
}
inline float GameWeaponFired::positionz() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.positionZ)
  return positionz_;
}
inline void GameWeaponFired::set_positionz(float value) {
  set_has_positionz();
  positionz_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.positionZ)
}

// -------------------------------------------------------------------

// GameDeath

// required int32 killedByClass = 1;
inline bool GameDeath::has_killedbyclass() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameDeath::set_has_killedbyclass() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameDeath::clear_has_killedbyclass() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameDeath::clear_killedbyclass() {
  killedbyclass_ = 0;
  clear_has_killedbyclass();
}
inline ::google::protobuf::int32 GameDeath::killedbyclass() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.killedByClass)
  return killedbyclass_;
}
inline void GameDeath::set_killedbyclass(::google::protobuf::int32 value) {
  set_has_killedbyclass();
  killedbyclass_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.killedByClass)
}

// required int32 killedByWeapon = 2;
inline bool GameDeath::has_killedbyweapon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameDeath::set_has_killedbyweapon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameDeath::clear_has_killedbyweapon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameDeath::clear_killedbyweapon() {
  killedbyweapon_ = 0;
  clear_has_killedbyweapon();
}
inline ::google::protobuf::int32 GameDeath::killedbyweapon() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.killedByWeapon)
  return killedbyweapon_;
}
inline void GameDeath::set_killedbyweapon(::google::protobuf::int32 value) {
  set_has_killedbyweapon();
  killedbyweapon_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.killedByWeapon)
}

// required int32 killedByHealth = 3;
inline bool GameDeath::has_killedbyhealth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameDeath::set_has_killedbyhealth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameDeath::clear_has_killedbyhealth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameDeath::clear_killedbyhealth() {
  killedbyhealth_ = 0;
  clear_has_killedbyhealth();
}
inline ::google::protobuf::int32 GameDeath::killedbyhealth() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.killedByHealth)
  return killedbyhealth_;
}
inline void GameDeath::set_killedbyhealth(::google::protobuf::int32 value) {
  set_has_killedbyhealth();
  killedbyhealth_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.killedByHealth)
}

// -------------------------------------------------------------------

// GameTookDamage

// required int32 weaponId = 1;
inline bool GameTookDamage::has_weaponid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameTookDamage::set_has_weaponid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameTookDamage::clear_has_weaponid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameTookDamage::clear_weaponid() {
  weaponid_ = 0;
  clear_has_weaponid();
}
inline ::google::protobuf::int32 GameTookDamage::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.weaponId)
  return weaponid_;
}
inline void GameTookDamage::set_weaponid(::google::protobuf::int32 value) {
  set_has_weaponid();
  weaponid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.weaponId)
}

// required float positionX = 2;
inline bool GameTookDamage::has_positionx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameTookDamage::set_has_positionx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameTookDamage::clear_has_positionx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameTookDamage::clear_positionx() {
  positionx_ = 0;
  clear_has_positionx();
}
inline float GameTookDamage::positionx() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.positionX)
  return positionx_;
}
inline void GameTookDamage::set_positionx(float value) {
  set_has_positionx();
  positionx_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.positionX)
}

// required float positionY = 3;
inline bool GameTookDamage::has_positiony() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameTookDamage::set_has_positiony() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameTookDamage::clear_has_positiony() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameTookDamage::clear_positiony() {
  positiony_ = 0;
  clear_has_positiony();
}
inline float GameTookDamage::positiony() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.positionY)
  return positiony_;
}
inline void GameTookDamage::set_positiony(float value) {
  set_has_positiony();
  positiony_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.positionY)
}

// required float positionZ = 4;
inline bool GameTookDamage::has_positionz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameTookDamage::set_has_positionz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameTookDamage::clear_has_positionz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameTookDamage::clear_positionz() {
  positionz_ = 0;
  clear_has_positionz();
}
inline float GameTookDamage::positionz() const {
  // @@protoc_insertion_point(field_get:Analytics.GameTookDamage.positionZ)
  return positionz_;
}
inline void GameTookDamage::set_positionz(float value) {
  set_has_positionz();
  positionz_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameTookDamage.positionZ)
}

// -------------------------------------------------------------------

// GameNavigationStuck

// required int32 entityId = 1;
inline bool GameNavigationStuck::has_entityid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameNavigationStuck::set_has_entityid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameNavigationStuck::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameNavigationStuck::clear_entityid() {
  entityid_ = 0;
  clear_has_entityid();
}
inline ::google::protobuf::int32 GameNavigationStuck::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.entityId)
  return entityid_;
}
inline void GameNavigationStuck::set_entityid(::google::protobuf::int32 value) {
  set_has_entityid();
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.entityId)
}

// required float positionX = 2;
inline bool GameNavigationStuck::has_positionx() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameNavigationStuck::set_has_positionx() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameNavigationStuck::clear_has_positionx() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameNavigationStuck::clear_positionx() {
  positionx_ = 0;
  clear_has_positionx();
}
inline float GameNavigationStuck::positionx() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.positionX)
  return positionx_;
}
inline void GameNavigationStuck::set_positionx(float value) {
  set_has_positionx();
  positionx_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.positionX)
}

// required float positionY = 3;
inline bool GameNavigationStuck::has_positiony() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameNavigationStuck::set_has_positiony() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameNavigationStuck::clear_has_positiony() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameNavigationStuck::clear_positiony() {
  positiony_ = 0;
  clear_has_positiony();
}
inline float GameNavigationStuck::positiony() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.positionY)
  return positiony_;
}
inline void GameNavigationStuck::set_positiony(float value) {
  set_has_positiony();
  positiony_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.positionY)
}

// required float positionZ = 4;
inline bool GameNavigationStuck::has_positionz() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameNavigationStuck::set_has_positionz() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameNavigationStuck::clear_has_positionz() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameNavigationStuck::clear_positionz() {
  positionz_ = 0;
  clear_has_positionz();
}
inline float GameNavigationStuck::positionz() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.positionZ)
  return positionz_;
}
inline void GameNavigationStuck::set_positionz(float value) {
  set_has_positionz();
  positionz_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.positionZ)
}

// -------------------------------------------------------------------

// MessageUnion

// required int64 timestamp = 1;
inline bool MessageUnion::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageUnion::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageUnion::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageUnion::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 MessageUnion::timestamp() const {
  // @@protoc_insertion_point(field_get:Analytics.MessageUnion.timestamp)
  return timestamp_;
}
inline void MessageUnion::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Analytics.MessageUnion.timestamp)
}

// optional .Analytics.SystemNavNotFound systemNavNotFound = 2;
inline bool MessageUnion::has_systemnavnotfound() const {
  return msg_case() == kSystemNavNotFound;
}
inline void MessageUnion::set_has_systemnavnotfound() {
  _oneof_case_[0] = kSystemNavNotFound;
}
inline void MessageUnion::clear_systemnavnotfound() {
  if (has_systemnavnotfound()) {
    delete msg_.systemnavnotfound_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemNavNotFound& MessageUnion::systemnavnotfound() const {
  return has_systemnavnotfound() ? *msg_.systemnavnotfound_
                      : ::Analytics::SystemNavNotFound::default_instance();
}
inline ::Analytics::SystemNavNotFound* MessageUnion::mutable_systemnavnotfound() {
  if (!has_systemnavnotfound()) {
    clear_msg();
    set_has_systemnavnotfound();
    msg_.systemnavnotfound_ = new ::Analytics::SystemNavNotFound;
  }
  return msg_.systemnavnotfound_;
}
inline ::Analytics::SystemNavNotFound* MessageUnion::release_systemnavnotfound() {
  if (has_systemnavnotfound()) {
    clear_has_msg();
    ::Analytics::SystemNavNotFound* temp = msg_.systemnavnotfound_;
    msg_.systemnavnotfound_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemnavnotfound(::Analytics::SystemNavNotFound* systemnavnotfound) {
  clear_msg();
  if (systemnavnotfound) {
    set_has_systemnavnotfound();
    msg_.systemnavnotfound_ = systemnavnotfound;
  }
}

// optional .Analytics.SystemNavAutoDownloaded systemNavDownloaded = 3;
inline bool MessageUnion::has_systemnavdownloaded() const {
  return msg_case() == kSystemNavDownloaded;
}
inline void MessageUnion::set_has_systemnavdownloaded() {
  _oneof_case_[0] = kSystemNavDownloaded;
}
inline void MessageUnion::clear_systemnavdownloaded() {
  if (has_systemnavdownloaded()) {
    delete msg_.systemnavdownloaded_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemNavAutoDownloaded& MessageUnion::systemnavdownloaded() const {
  return has_systemnavdownloaded() ? *msg_.systemnavdownloaded_
                      : ::Analytics::SystemNavAutoDownloaded::default_instance();
}
inline ::Analytics::SystemNavAutoDownloaded* MessageUnion::mutable_systemnavdownloaded() {
  if (!has_systemnavdownloaded()) {
    clear_msg();
    set_has_systemnavdownloaded();
    msg_.systemnavdownloaded_ = new ::Analytics::SystemNavAutoDownloaded;
  }
  return msg_.systemnavdownloaded_;
}
inline ::Analytics::SystemNavAutoDownloaded* MessageUnion::release_systemnavdownloaded() {
  if (has_systemnavdownloaded()) {
    clear_has_msg();
    ::Analytics::SystemNavAutoDownloaded* temp = msg_.systemnavdownloaded_;
    msg_.systemnavdownloaded_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemnavdownloaded(::Analytics::SystemNavAutoDownloaded* systemnavdownloaded) {
  clear_msg();
  if (systemnavdownloaded) {
    set_has_systemnavdownloaded();
    msg_.systemnavdownloaded_ = systemnavdownloaded;
  }
}

// optional .Analytics.SystemAssert systemAssert = 4;
inline bool MessageUnion::has_systemassert() const {
  return msg_case() == kSystemAssert;
}
inline void MessageUnion::set_has_systemassert() {
  _oneof_case_[0] = kSystemAssert;
}
inline void MessageUnion::clear_systemassert() {
  if (has_systemassert()) {
    delete msg_.systemassert_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemAssert& MessageUnion::systemassert() const {
  return has_systemassert() ? *msg_.systemassert_
                      : ::Analytics::SystemAssert::default_instance();
}
inline ::Analytics::SystemAssert* MessageUnion::mutable_systemassert() {
  if (!has_systemassert()) {
    clear_msg();
    set_has_systemassert();
    msg_.systemassert_ = new ::Analytics::SystemAssert;
  }
  return msg_.systemassert_;
}
inline ::Analytics::SystemAssert* MessageUnion::release_systemassert() {
  if (has_systemassert()) {
    clear_has_msg();
    ::Analytics::SystemAssert* temp = msg_.systemassert_;
    msg_.systemassert_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemassert(::Analytics::SystemAssert* systemassert) {
  clear_msg();
  if (systemassert) {
    set_has_systemassert();
    msg_.systemassert_ = systemassert;
  }
}

// optional .Analytics.SystemCrash systemCrash = 5;
inline bool MessageUnion::has_systemcrash() const {
  return msg_case() == kSystemCrash;
}
inline void MessageUnion::set_has_systemcrash() {
  _oneof_case_[0] = kSystemCrash;
}
inline void MessageUnion::clear_systemcrash() {
  if (has_systemcrash()) {
    delete msg_.systemcrash_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemCrash& MessageUnion::systemcrash() const {
  return has_systemcrash() ? *msg_.systemcrash_
                      : ::Analytics::SystemCrash::default_instance();
}
inline ::Analytics::SystemCrash* MessageUnion::mutable_systemcrash() {
  if (!has_systemcrash()) {
    clear_msg();
    set_has_systemcrash();
    msg_.systemcrash_ = new ::Analytics::SystemCrash;
  }
  return msg_.systemcrash_;
}
inline ::Analytics::SystemCrash* MessageUnion::release_systemcrash() {
  if (has_systemcrash()) {
    clear_has_msg();
    ::Analytics::SystemCrash* temp = msg_.systemcrash_;
    msg_.systemcrash_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemcrash(::Analytics::SystemCrash* systemcrash) {
  clear_msg();
  if (systemcrash) {
    set_has_systemcrash();
    msg_.systemcrash_ = systemcrash;
  }
}

// optional .Analytics.SystemModelData systemModelData = 6;
inline bool MessageUnion::has_systemmodeldata() const {
  return msg_case() == kSystemModelData;
}
inline void MessageUnion::set_has_systemmodeldata() {
  _oneof_case_[0] = kSystemModelData;
}
inline void MessageUnion::clear_systemmodeldata() {
  if (has_systemmodeldata()) {
    delete msg_.systemmodeldata_;
    clear_has_msg();
  }
}
inline const ::Analytics::SystemModelData& MessageUnion::systemmodeldata() const {
  return has_systemmodeldata() ? *msg_.systemmodeldata_
                      : ::Analytics::SystemModelData::default_instance();
}
inline ::Analytics::SystemModelData* MessageUnion::mutable_systemmodeldata() {
  if (!has_systemmodeldata()) {
    clear_msg();
    set_has_systemmodeldata();
    msg_.systemmodeldata_ = new ::Analytics::SystemModelData;
  }
  return msg_.systemmodeldata_;
}
inline ::Analytics::SystemModelData* MessageUnion::release_systemmodeldata() {
  if (has_systemmodeldata()) {
    clear_has_msg();
    ::Analytics::SystemModelData* temp = msg_.systemmodeldata_;
    msg_.systemmodeldata_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_systemmodeldata(::Analytics::SystemModelData* systemmodeldata) {
  clear_msg();
  if (systemmodeldata) {
    set_has_systemmodeldata();
    msg_.systemmodeldata_ = systemmodeldata;
  }
}

// optional .Analytics.GameEntityList gameEntityList = 100;
inline bool MessageUnion::has_gameentitylist() const {
  return msg_case() == kGameEntityList;
}
inline void MessageUnion::set_has_gameentitylist() {
  _oneof_case_[0] = kGameEntityList;
}
inline void MessageUnion::clear_gameentitylist() {
  if (has_gameentitylist()) {
    delete msg_.gameentitylist_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameEntityList& MessageUnion::gameentitylist() const {
  return has_gameentitylist() ? *msg_.gameentitylist_
                      : ::Analytics::GameEntityList::default_instance();
}
inline ::Analytics::GameEntityList* MessageUnion::mutable_gameentitylist() {
  if (!has_gameentitylist()) {
    clear_msg();
    set_has_gameentitylist();
    msg_.gameentitylist_ = new ::Analytics::GameEntityList;
  }
  return msg_.gameentitylist_;
}
inline ::Analytics::GameEntityList* MessageUnion::release_gameentitylist() {
  if (has_gameentitylist()) {
    clear_has_msg();
    ::Analytics::GameEntityList* temp = msg_.gameentitylist_;
    msg_.gameentitylist_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gameentitylist(::Analytics::GameEntityList* gameentitylist) {
  clear_msg();
  if (gameentitylist) {
    set_has_gameentitylist();
    msg_.gameentitylist_ = gameentitylist;
  }
}

// optional .Analytics.GameWeaponFired gameWeaponFired = 101;
inline bool MessageUnion::has_gameweaponfired() const {
  return msg_case() == kGameWeaponFired;
}
inline void MessageUnion::set_has_gameweaponfired() {
  _oneof_case_[0] = kGameWeaponFired;
}
inline void MessageUnion::clear_gameweaponfired() {
  if (has_gameweaponfired()) {
    delete msg_.gameweaponfired_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameWeaponFired& MessageUnion::gameweaponfired() const {
  return has_gameweaponfired() ? *msg_.gameweaponfired_
                      : ::Analytics::GameWeaponFired::default_instance();
}
inline ::Analytics::GameWeaponFired* MessageUnion::mutable_gameweaponfired() {
  if (!has_gameweaponfired()) {
    clear_msg();
    set_has_gameweaponfired();
    msg_.gameweaponfired_ = new ::Analytics::GameWeaponFired;
  }
  return msg_.gameweaponfired_;
}
inline ::Analytics::GameWeaponFired* MessageUnion::release_gameweaponfired() {
  if (has_gameweaponfired()) {
    clear_has_msg();
    ::Analytics::GameWeaponFired* temp = msg_.gameweaponfired_;
    msg_.gameweaponfired_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gameweaponfired(::Analytics::GameWeaponFired* gameweaponfired) {
  clear_msg();
  if (gameweaponfired) {
    set_has_gameweaponfired();
    msg_.gameweaponfired_ = gameweaponfired;
  }
}

// optional .Analytics.GameDeath gameDeath = 102;
inline bool MessageUnion::has_gamedeath() const {
  return msg_case() == kGameDeath;
}
inline void MessageUnion::set_has_gamedeath() {
  _oneof_case_[0] = kGameDeath;
}
inline void MessageUnion::clear_gamedeath() {
  if (has_gamedeath()) {
    delete msg_.gamedeath_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameDeath& MessageUnion::gamedeath() const {
  return has_gamedeath() ? *msg_.gamedeath_
                      : ::Analytics::GameDeath::default_instance();
}
inline ::Analytics::GameDeath* MessageUnion::mutable_gamedeath() {
  if (!has_gamedeath()) {
    clear_msg();
    set_has_gamedeath();
    msg_.gamedeath_ = new ::Analytics::GameDeath;
  }
  return msg_.gamedeath_;
}
inline ::Analytics::GameDeath* MessageUnion::release_gamedeath() {
  if (has_gamedeath()) {
    clear_has_msg();
    ::Analytics::GameDeath* temp = msg_.gamedeath_;
    msg_.gamedeath_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gamedeath(::Analytics::GameDeath* gamedeath) {
  clear_msg();
  if (gamedeath) {
    set_has_gamedeath();
    msg_.gamedeath_ = gamedeath;
  }
}

// optional .Analytics.GameTookDamage gameTookDamage = 103;
inline bool MessageUnion::has_gametookdamage() const {
  return msg_case() == kGameTookDamage;
}
inline void MessageUnion::set_has_gametookdamage() {
  _oneof_case_[0] = kGameTookDamage;
}
inline void MessageUnion::clear_gametookdamage() {
  if (has_gametookdamage()) {
    delete msg_.gametookdamage_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameTookDamage& MessageUnion::gametookdamage() const {
  return has_gametookdamage() ? *msg_.gametookdamage_
                      : ::Analytics::GameTookDamage::default_instance();
}
inline ::Analytics::GameTookDamage* MessageUnion::mutable_gametookdamage() {
  if (!has_gametookdamage()) {
    clear_msg();
    set_has_gametookdamage();
    msg_.gametookdamage_ = new ::Analytics::GameTookDamage;
  }
  return msg_.gametookdamage_;
}
inline ::Analytics::GameTookDamage* MessageUnion::release_gametookdamage() {
  if (has_gametookdamage()) {
    clear_has_msg();
    ::Analytics::GameTookDamage* temp = msg_.gametookdamage_;
    msg_.gametookdamage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gametookdamage(::Analytics::GameTookDamage* gametookdamage) {
  clear_msg();
  if (gametookdamage) {
    set_has_gametookdamage();
    msg_.gametookdamage_ = gametookdamage;
  }
}

// optional .Analytics.GameNavigationStuck gameNavigationStuck = 104;
inline bool MessageUnion::has_gamenavigationstuck() const {
  return msg_case() == kGameNavigationStuck;
}
inline void MessageUnion::set_has_gamenavigationstuck() {
  _oneof_case_[0] = kGameNavigationStuck;
}
inline void MessageUnion::clear_gamenavigationstuck() {
  if (has_gamenavigationstuck()) {
    delete msg_.gamenavigationstuck_;
    clear_has_msg();
  }
}
inline const ::Analytics::GameNavigationStuck& MessageUnion::gamenavigationstuck() const {
  return has_gamenavigationstuck() ? *msg_.gamenavigationstuck_
                      : ::Analytics::GameNavigationStuck::default_instance();
}
inline ::Analytics::GameNavigationStuck* MessageUnion::mutable_gamenavigationstuck() {
  if (!has_gamenavigationstuck()) {
    clear_msg();
    set_has_gamenavigationstuck();
    msg_.gamenavigationstuck_ = new ::Analytics::GameNavigationStuck;
  }
  return msg_.gamenavigationstuck_;
}
inline ::Analytics::GameNavigationStuck* MessageUnion::release_gamenavigationstuck() {
  if (has_gamenavigationstuck()) {
    clear_has_msg();
    ::Analytics::GameNavigationStuck* temp = msg_.gamenavigationstuck_;
    msg_.gamenavigationstuck_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_gamenavigationstuck(::Analytics::GameNavigationStuck* gamenavigationstuck) {
  clear_msg();
  if (gamenavigationstuck) {
    set_has_gamenavigationstuck();
    msg_.gamenavigationstuck_ = gamenavigationstuck;
  }
}

// optional .Analytics.TopicSubscribe topicSubscribe = 1000;
inline bool MessageUnion::has_topicsubscribe() const {
  return msg_case() == kTopicSubscribe;
}
inline void MessageUnion::set_has_topicsubscribe() {
  _oneof_case_[0] = kTopicSubscribe;
}
inline void MessageUnion::clear_topicsubscribe() {
  if (has_topicsubscribe()) {
    delete msg_.topicsubscribe_;
    clear_has_msg();
  }
}
inline const ::Analytics::TopicSubscribe& MessageUnion::topicsubscribe() const {
  return has_topicsubscribe() ? *msg_.topicsubscribe_
                      : ::Analytics::TopicSubscribe::default_instance();
}
inline ::Analytics::TopicSubscribe* MessageUnion::mutable_topicsubscribe() {
  if (!has_topicsubscribe()) {
    clear_msg();
    set_has_topicsubscribe();
    msg_.topicsubscribe_ = new ::Analytics::TopicSubscribe;
  }
  return msg_.topicsubscribe_;
}
inline ::Analytics::TopicSubscribe* MessageUnion::release_topicsubscribe() {
  if (has_topicsubscribe()) {
    clear_has_msg();
    ::Analytics::TopicSubscribe* temp = msg_.topicsubscribe_;
    msg_.topicsubscribe_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_topicsubscribe(::Analytics::TopicSubscribe* topicsubscribe) {
  clear_msg();
  if (topicsubscribe) {
    set_has_topicsubscribe();
    msg_.topicsubscribe_ = topicsubscribe;
  }
}

// optional .Analytics.TopicUnsubscribe topicUnsubscribe = 1001;
inline bool MessageUnion::has_topicunsubscribe() const {
  return msg_case() == kTopicUnsubscribe;
}
inline void MessageUnion::set_has_topicunsubscribe() {
  _oneof_case_[0] = kTopicUnsubscribe;
}
inline void MessageUnion::clear_topicunsubscribe() {
  if (has_topicunsubscribe()) {
    delete msg_.topicunsubscribe_;
    clear_has_msg();
  }
}
inline const ::Analytics::TopicUnsubscribe& MessageUnion::topicunsubscribe() const {
  return has_topicunsubscribe() ? *msg_.topicunsubscribe_
                      : ::Analytics::TopicUnsubscribe::default_instance();
}
inline ::Analytics::TopicUnsubscribe* MessageUnion::mutable_topicunsubscribe() {
  if (!has_topicunsubscribe()) {
    clear_msg();
    set_has_topicunsubscribe();
    msg_.topicunsubscribe_ = new ::Analytics::TopicUnsubscribe;
  }
  return msg_.topicunsubscribe_;
}
inline ::Analytics::TopicUnsubscribe* MessageUnion::release_topicunsubscribe() {
  if (has_topicunsubscribe()) {
    clear_has_msg();
    ::Analytics::TopicUnsubscribe* temp = msg_.topicunsubscribe_;
    msg_.topicunsubscribe_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void MessageUnion::set_allocated_topicunsubscribe(::Analytics::TopicUnsubscribe* topicunsubscribe) {
  clear_msg();
  if (topicunsubscribe) {
    set_has_topicunsubscribe();
    msg_.topicunsubscribe_ = topicunsubscribe;
  }
}

inline bool MessageUnion::has_msg() {
  return msg_case() != MSG_NOT_SET;
}
inline void MessageUnion::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline MessageUnion::MsgCase MessageUnion::msg_case() const {
  return MessageUnion::MsgCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace Analytics

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Analytics::Compression> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::Compression>() {
  return ::Analytics::Compression_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_analytics_2eproto__INCLUDED
