// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: analytics.proto

#ifndef PROTOBUF_INCLUDED_analytics_2eproto
#define PROTOBUF_INCLUDED_analytics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3006001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_analytics_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_analytics_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[37]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_analytics_2eproto();
namespace Analytics {
class EditorChangeValue;
class EditorChangeValueDefaultTypeInternal;
extern EditorChangeValueDefaultTypeInternal _EditorChangeValue_default_instance_;
class EditorChanges;
class EditorChangesDefaultTypeInternal;
extern EditorChangesDefaultTypeInternal _EditorChanges_default_instance_;
class Euler;
class EulerDefaultTypeInternal;
extern EulerDefaultTypeInternal _Euler_default_instance_;
class GameAssert;
class GameAssertDefaultTypeInternal;
extern GameAssertDefaultTypeInternal _GameAssert_default_instance_;
class GameCrash;
class GameCrashDefaultTypeInternal;
extern GameCrashDefaultTypeInternal _GameCrash_default_instance_;
class GameDeath;
class GameDeathDefaultTypeInternal;
extern GameDeathDefaultTypeInternal _GameDeath_default_instance_;
class GameEntityInfo;
class GameEntityInfoDefaultTypeInternal;
extern GameEntityInfoDefaultTypeInternal _GameEntityInfo_default_instance_;
class GameEntityInfo_Ammo;
class GameEntityInfo_AmmoDefaultTypeInternal;
extern GameEntityInfo_AmmoDefaultTypeInternal _GameEntityInfo_Ammo_default_instance_;
class GameEntityPosition;
class GameEntityPositionDefaultTypeInternal;
extern GameEntityPositionDefaultTypeInternal _GameEntityPosition_default_instance_;
class GameEnum;
class GameEnumDefaultTypeInternal;
extern GameEnumDefaultTypeInternal _GameEnum_default_instance_;
class GameEnum_EnumPair;
class GameEnum_EnumPairDefaultTypeInternal;
extern GameEnum_EnumPairDefaultTypeInternal _GameEnum_EnumPair_default_instance_;
class GameInflictDamage;
class GameInflictDamageDefaultTypeInternal;
extern GameInflictDamageDefaultTypeInternal _GameInflictDamage_default_instance_;
class GameInfo;
class GameInfoDefaultTypeInternal;
extern GameInfoDefaultTypeInternal _GameInfo_default_instance_;
class GameKilledSomeone;
class GameKilledSomeoneDefaultTypeInternal;
extern GameKilledSomeoneDefaultTypeInternal _GameKilledSomeone_default_instance_;
class GameLogMessage;
class GameLogMessageDefaultTypeInternal;
extern GameLogMessageDefaultTypeInternal _GameLogMessage_default_instance_;
class GameMeshData;
class GameMeshDataDefaultTypeInternal;
extern GameMeshDataDefaultTypeInternal _GameMeshData_default_instance_;
class GameNavAutoDownloaded;
class GameNavAutoDownloadedDefaultTypeInternal;
extern GameNavAutoDownloadedDefaultTypeInternal _GameNavAutoDownloaded_default_instance_;
class GameNavNotFound;
class GameNavNotFoundDefaultTypeInternal;
extern GameNavNotFoundDefaultTypeInternal _GameNavNotFound_default_instance_;
class GameNavigationStuck;
class GameNavigationStuckDefaultTypeInternal;
extern GameNavigationStuckDefaultTypeInternal _GameNavigationStuck_default_instance_;
class GameNode;
class GameNodeDefaultTypeInternal;
extern GameNodeDefaultTypeInternal _GameNode_default_instance_;
class GameRadiusDamage;
class GameRadiusDamageDefaultTypeInternal;
extern GameRadiusDamageDefaultTypeInternal _GameRadiusDamage_default_instance_;
class GameRecieveDamage;
class GameRecieveDamageDefaultTypeInternal;
extern GameRecieveDamageDefaultTypeInternal _GameRecieveDamage_default_instance_;
class GameVoiceMacro;
class GameVoiceMacroDefaultTypeInternal;
extern GameVoiceMacroDefaultTypeInternal _GameVoiceMacro_default_instance_;
class GameWeaponFired;
class GameWeaponFiredDefaultTypeInternal;
extern GameWeaponFiredDefaultTypeInternal _GameWeaponFired_default_instance_;
class Line;
class LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class LineEvent;
class LineEventDefaultTypeInternal;
extern LineEventDefaultTypeInternal _LineEvent_default_instance_;
class Material;
class MaterialDefaultTypeInternal;
extern MaterialDefaultTypeInternal _Material_default_instance_;
class Mesh;
class MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class PointEvent;
class PointEventDefaultTypeInternal;
extern PointEventDefaultTypeInternal _PointEvent_default_instance_;
class Primitive;
class PrimitiveDefaultTypeInternal;
extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
class PrimitiveOptions;
class PrimitiveOptionsDefaultTypeInternal;
extern PrimitiveOptionsDefaultTypeInternal _PrimitiveOptions_default_instance_;
class RangeF;
class RangeFDefaultTypeInternal;
extern RangeFDefaultTypeInternal _RangeF_default_instance_;
class RangeI;
class RangeIDefaultTypeInternal;
extern RangeIDefaultTypeInternal _RangeI_default_instance_;
class UTCTime;
class UTCTimeDefaultTypeInternal;
extern UTCTimeDefaultTypeInternal _UTCTime_default_instance_;
class Vec3;
class Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Vec3Color;
class Vec3ColorDefaultTypeInternal;
extern Vec3ColorDefaultTypeInternal _Vec3Color_default_instance_;
class Vec4;
class Vec4DefaultTypeInternal;
extern Vec4DefaultTypeInternal _Vec4_default_instance_;
}  // namespace Analytics
namespace google {
namespace protobuf {
template<> ::Analytics::EditorChangeValue* Arena::CreateMaybeMessage<::Analytics::EditorChangeValue>(Arena*);
template<> ::Analytics::EditorChanges* Arena::CreateMaybeMessage<::Analytics::EditorChanges>(Arena*);
template<> ::Analytics::Euler* Arena::CreateMaybeMessage<::Analytics::Euler>(Arena*);
template<> ::Analytics::GameAssert* Arena::CreateMaybeMessage<::Analytics::GameAssert>(Arena*);
template<> ::Analytics::GameCrash* Arena::CreateMaybeMessage<::Analytics::GameCrash>(Arena*);
template<> ::Analytics::GameDeath* Arena::CreateMaybeMessage<::Analytics::GameDeath>(Arena*);
template<> ::Analytics::GameEntityInfo* Arena::CreateMaybeMessage<::Analytics::GameEntityInfo>(Arena*);
template<> ::Analytics::GameEntityInfo_Ammo* Arena::CreateMaybeMessage<::Analytics::GameEntityInfo_Ammo>(Arena*);
template<> ::Analytics::GameEntityPosition* Arena::CreateMaybeMessage<::Analytics::GameEntityPosition>(Arena*);
template<> ::Analytics::GameEnum* Arena::CreateMaybeMessage<::Analytics::GameEnum>(Arena*);
template<> ::Analytics::GameEnum_EnumPair* Arena::CreateMaybeMessage<::Analytics::GameEnum_EnumPair>(Arena*);
template<> ::Analytics::GameInflictDamage* Arena::CreateMaybeMessage<::Analytics::GameInflictDamage>(Arena*);
template<> ::Analytics::GameInfo* Arena::CreateMaybeMessage<::Analytics::GameInfo>(Arena*);
template<> ::Analytics::GameKilledSomeone* Arena::CreateMaybeMessage<::Analytics::GameKilledSomeone>(Arena*);
template<> ::Analytics::GameLogMessage* Arena::CreateMaybeMessage<::Analytics::GameLogMessage>(Arena*);
template<> ::Analytics::GameMeshData* Arena::CreateMaybeMessage<::Analytics::GameMeshData>(Arena*);
template<> ::Analytics::GameNavAutoDownloaded* Arena::CreateMaybeMessage<::Analytics::GameNavAutoDownloaded>(Arena*);
template<> ::Analytics::GameNavNotFound* Arena::CreateMaybeMessage<::Analytics::GameNavNotFound>(Arena*);
template<> ::Analytics::GameNavigationStuck* Arena::CreateMaybeMessage<::Analytics::GameNavigationStuck>(Arena*);
template<> ::Analytics::GameNode* Arena::CreateMaybeMessage<::Analytics::GameNode>(Arena*);
template<> ::Analytics::GameRadiusDamage* Arena::CreateMaybeMessage<::Analytics::GameRadiusDamage>(Arena*);
template<> ::Analytics::GameRecieveDamage* Arena::CreateMaybeMessage<::Analytics::GameRecieveDamage>(Arena*);
template<> ::Analytics::GameVoiceMacro* Arena::CreateMaybeMessage<::Analytics::GameVoiceMacro>(Arena*);
template<> ::Analytics::GameWeaponFired* Arena::CreateMaybeMessage<::Analytics::GameWeaponFired>(Arena*);
template<> ::Analytics::Line* Arena::CreateMaybeMessage<::Analytics::Line>(Arena*);
template<> ::Analytics::LineEvent* Arena::CreateMaybeMessage<::Analytics::LineEvent>(Arena*);
template<> ::Analytics::Material* Arena::CreateMaybeMessage<::Analytics::Material>(Arena*);
template<> ::Analytics::Mesh* Arena::CreateMaybeMessage<::Analytics::Mesh>(Arena*);
template<> ::Analytics::PointEvent* Arena::CreateMaybeMessage<::Analytics::PointEvent>(Arena*);
template<> ::Analytics::Primitive* Arena::CreateMaybeMessage<::Analytics::Primitive>(Arena*);
template<> ::Analytics::PrimitiveOptions* Arena::CreateMaybeMessage<::Analytics::PrimitiveOptions>(Arena*);
template<> ::Analytics::RangeF* Arena::CreateMaybeMessage<::Analytics::RangeF>(Arena*);
template<> ::Analytics::RangeI* Arena::CreateMaybeMessage<::Analytics::RangeI>(Arena*);
template<> ::Analytics::UTCTime* Arena::CreateMaybeMessage<::Analytics::UTCTime>(Arena*);
template<> ::Analytics::Vec3* Arena::CreateMaybeMessage<::Analytics::Vec3>(Arena*);
template<> ::Analytics::Vec3Color* Arena::CreateMaybeMessage<::Analytics::Vec3Color>(Arena*);
template<> ::Analytics::Vec4* Arena::CreateMaybeMessage<::Analytics::Vec4>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Analytics {

enum RedisKeyType {
  UNKNOWN = 0,
  SET = 1,
  RPUSH = 2,
  HMSET = 3,
  RedisKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  RedisKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool RedisKeyType_IsValid(int value);
const RedisKeyType RedisKeyType_MIN = UNKNOWN;
const RedisKeyType RedisKeyType_MAX = HMSET;
const int RedisKeyType_ARRAYSIZE = RedisKeyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RedisKeyType_descriptor();
inline const ::std::string& RedisKeyType_Name(RedisKeyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RedisKeyType_descriptor(), value);
}
inline bool RedisKeyType_Parse(
    const ::std::string& name, RedisKeyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RedisKeyType>(
    RedisKeyType_descriptor(), name, value);
}
enum PrimitiveType {
  Triangles = 0,
  Lines = 1,
  Points = 2,
  Quad = 3,
  PrimitiveType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  PrimitiveType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool PrimitiveType_IsValid(int value);
const PrimitiveType PrimitiveType_MIN = Triangles;
const PrimitiveType PrimitiveType_MAX = Quad;
const int PrimitiveType_ARRAYSIZE = PrimitiveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PrimitiveType_descriptor();
inline const ::std::string& PrimitiveType_Name(PrimitiveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PrimitiveType_descriptor(), value);
}
inline bool PrimitiveType_Parse(
    const ::std::string& name, PrimitiveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PrimitiveType>(
    PrimitiveType_descriptor(), name, value);
}
enum Compression {
  Compression_None = 0,
  Compression_FastLZ = 1,
  Compression_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  Compression_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool Compression_IsValid(int value);
const Compression Compression_MIN = Compression_None;
const Compression Compression_MAX = Compression_FastLZ;
const int Compression_ARRAYSIZE = Compression_MAX + 1;

const ::google::protobuf::EnumDescriptor* Compression_descriptor();
inline const ::std::string& Compression_Name(Compression value) {
  return ::google::protobuf::internal::NameOfEnum(
    Compression_descriptor(), value);
}
inline bool Compression_Parse(
    const ::std::string& name, Compression* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Compression>(
    Compression_descriptor(), name, value);
}
enum LogType {
  Log = 0,
  Warning = 1,
  Error = 3,
  LogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  LogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool LogType_IsValid(int value);
const LogType LogType_MIN = Log;
const LogType LogType_MAX = Error;
const int LogType_ARRAYSIZE = LogType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LogType_descriptor();
inline const ::std::string& LogType_Name(LogType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LogType_descriptor(), value);
}
inline bool LogType_Parse(
    const ::std::string& name, LogType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LogType>(
    LogType_descriptor(), name, value);
}
// ===================================================================

class PointEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.PointEvent) */ {
 public:
  PointEvent();
  virtual ~PointEvent();

  PointEvent(const PointEvent& from);

  inline PointEvent& operator=(const PointEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointEvent(PointEvent&& from) noexcept
    : PointEvent() {
    *this = ::std::move(from);
  }

  inline PointEvent& operator=(PointEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PointEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointEvent* internal_default_instance() {
    return reinterpret_cast<const PointEvent*>(
               &_PointEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PointEvent* other);
  friend void swap(PointEvent& a, PointEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointEvent* New() const final {
    return CreateMaybeMessage<PointEvent>(NULL);
  }

  PointEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointEvent& from);
  void MergeFrom(const PointEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string radius = 1;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  const ::std::string& radius() const;
  void set_radius(const ::std::string& value);
  #if LANG_CXX11
  void set_radius(::std::string&& value);
  #endif
  void set_radius(const char* value);
  void set_radius(const char* value, size_t size);
  ::std::string* mutable_radius();
  ::std::string* release_radius();
  void set_allocated_radius(::std::string* radius);

  // string weight = 2;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  const ::std::string& weight() const;
  void set_weight(const ::std::string& value);
  #if LANG_CXX11
  void set_weight(::std::string&& value);
  #endif
  void set_weight(const char* value);
  void set_weight(const char* value, size_t size);
  ::std::string* mutable_weight();
  ::std::string* release_weight();
  void set_allocated_weight(::std::string* weight);

  // @@protoc_insertion_point(class_scope:Analytics.PointEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr radius_;
  ::google::protobuf::internal::ArenaStringPtr weight_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class LineEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.LineEvent) */ {
 public:
  LineEvent();
  virtual ~LineEvent();

  LineEvent(const LineEvent& from);

  inline LineEvent& operator=(const LineEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LineEvent(LineEvent&& from) noexcept
    : LineEvent() {
    *this = ::std::move(from);
  }

  inline LineEvent& operator=(LineEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LineEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LineEvent* internal_default_instance() {
    return reinterpret_cast<const LineEvent*>(
               &_LineEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(LineEvent* other);
  friend void swap(LineEvent& a, LineEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LineEvent* New() const final {
    return CreateMaybeMessage<LineEvent>(NULL);
  }

  LineEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LineEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LineEvent& from);
  void MergeFrom(const LineEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string radius = 1;
  void clear_radius();
  static const int kRadiusFieldNumber = 1;
  const ::std::string& radius() const;
  void set_radius(const ::std::string& value);
  #if LANG_CXX11
  void set_radius(::std::string&& value);
  #endif
  void set_radius(const char* value);
  void set_radius(const char* value, size_t size);
  ::std::string* mutable_radius();
  ::std::string* release_radius();
  void set_allocated_radius(::std::string* radius);

  // string weight = 2;
  void clear_weight();
  static const int kWeightFieldNumber = 2;
  const ::std::string& weight() const;
  void set_weight(const ::std::string& value);
  #if LANG_CXX11
  void set_weight(::std::string&& value);
  #endif
  void set_weight(const char* value);
  void set_weight(const char* value, size_t size);
  ::std::string* mutable_weight();
  ::std::string* release_weight();
  void set_allocated_weight(::std::string* weight);

  // @@protoc_insertion_point(class_scope:Analytics.LineEvent)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr radius_;
  ::google::protobuf::internal::ArenaStringPtr weight_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class EditorChangeValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.EditorChangeValue) */ {
 public:
  EditorChangeValue();
  virtual ~EditorChangeValue();

  EditorChangeValue(const EditorChangeValue& from);

  inline EditorChangeValue& operator=(const EditorChangeValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EditorChangeValue(EditorChangeValue&& from) noexcept
    : EditorChangeValue() {
    *this = ::std::move(from);
  }

  inline EditorChangeValue& operator=(EditorChangeValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EditorChangeValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EditorChangeValue* internal_default_instance() {
    return reinterpret_cast<const EditorChangeValue*>(
               &_EditorChangeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(EditorChangeValue* other);
  friend void swap(EditorChangeValue& a, EditorChangeValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EditorChangeValue* New() const final {
    return CreateMaybeMessage<EditorChangeValue>(NULL);
  }

  EditorChangeValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EditorChangeValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EditorChangeValue& from);
  void MergeFrom(const EditorChangeValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditorChangeValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string messageType = 1;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  const ::std::string& messagetype() const;
  void set_messagetype(const ::std::string& value);
  #if LANG_CXX11
  void set_messagetype(::std::string&& value);
  #endif
  void set_messagetype(const char* value);
  void set_messagetype(const char* value, size_t size);
  ::std::string* mutable_messagetype();
  ::std::string* release_messagetype();
  void set_allocated_messagetype(::std::string* messagetype);

  // string fieldName = 2;
  void clear_fieldname();
  static const int kFieldNameFieldNumber = 2;
  const ::std::string& fieldname() const;
  void set_fieldname(const ::std::string& value);
  #if LANG_CXX11
  void set_fieldname(::std::string&& value);
  #endif
  void set_fieldname(const char* value);
  void set_fieldname(const char* value, size_t size);
  ::std::string* mutable_fieldname();
  ::std::string* release_fieldname();
  void set_allocated_fieldname(::std::string* fieldname);

  // string payload = 3;
  void clear_payload();
  static const int kPayloadFieldNumber = 3;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const char* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // @@protoc_insertion_point(class_scope:Analytics.EditorChangeValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr messagetype_;
  ::google::protobuf::internal::ArenaStringPtr fieldname_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class EditorChanges : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.EditorChanges) */ {
 public:
  EditorChanges();
  virtual ~EditorChanges();

  EditorChanges(const EditorChanges& from);

  inline EditorChanges& operator=(const EditorChanges& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EditorChanges(EditorChanges&& from) noexcept
    : EditorChanges() {
    *this = ::std::move(from);
  }

  inline EditorChanges& operator=(EditorChanges&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const EditorChanges& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EditorChanges* internal_default_instance() {
    return reinterpret_cast<const EditorChanges*>(
               &_EditorChanges_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(EditorChanges* other);
  friend void swap(EditorChanges& a, EditorChanges& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EditorChanges* New() const final {
    return CreateMaybeMessage<EditorChanges>(NULL);
  }

  EditorChanges* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EditorChanges>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EditorChanges& from);
  void MergeFrom(const EditorChanges& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditorChanges* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Analytics.EditorChangeValue changes = 1;
  int changes_size() const;
  void clear_changes();
  static const int kChangesFieldNumber = 1;
  ::Analytics::EditorChangeValue* mutable_changes(int index);
  ::google::protobuf::RepeatedPtrField< ::Analytics::EditorChangeValue >*
      mutable_changes();
  const ::Analytics::EditorChangeValue& changes(int index) const;
  ::Analytics::EditorChangeValue* add_changes();
  const ::google::protobuf::RepeatedPtrField< ::Analytics::EditorChangeValue >&
      changes() const;

  // @@protoc_insertion_point(class_scope:Analytics.EditorChanges)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::EditorChangeValue > changes_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class RangeF : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.RangeF) */ {
 public:
  RangeF();
  virtual ~RangeF();

  RangeF(const RangeF& from);

  inline RangeF& operator=(const RangeF& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeF(RangeF&& from) noexcept
    : RangeF() {
    *this = ::std::move(from);
  }

  inline RangeF& operator=(RangeF&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RangeF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeF* internal_default_instance() {
    return reinterpret_cast<const RangeF*>(
               &_RangeF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RangeF* other);
  friend void swap(RangeF& a, RangeF& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeF* New() const final {
    return CreateMaybeMessage<RangeF>(NULL);
  }

  RangeF* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeF>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RangeF& from);
  void MergeFrom(const RangeF& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeF* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float min = 1;
  void clear_min();
  static const int kMinFieldNumber = 1;
  float min() const;
  void set_min(float value);

  // float max = 2;
  void clear_max();
  static const int kMaxFieldNumber = 2;
  float max() const;
  void set_max(float value);

  // @@protoc_insertion_point(class_scope:Analytics.RangeF)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float min_;
  float max_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class RangeI : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.RangeI) */ {
 public:
  RangeI();
  virtual ~RangeI();

  RangeI(const RangeI& from);

  inline RangeI& operator=(const RangeI& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RangeI(RangeI&& from) noexcept
    : RangeI() {
    *this = ::std::move(from);
  }

  inline RangeI& operator=(RangeI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RangeI& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeI* internal_default_instance() {
    return reinterpret_cast<const RangeI*>(
               &_RangeI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RangeI* other);
  friend void swap(RangeI& a, RangeI& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RangeI* New() const final {
    return CreateMaybeMessage<RangeI>(NULL);
  }

  RangeI* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RangeI>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RangeI& from);
  void MergeFrom(const RangeI& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 min = 1;
  void clear_min();
  static const int kMinFieldNumber = 1;
  ::google::protobuf::int32 min() const;
  void set_min(::google::protobuf::int32 value);

  // int32 max = 2;
  void clear_max();
  static const int kMaxFieldNumber = 2;
  ::google::protobuf::int32 max() const;
  void set_max(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.RangeI)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 min_;
  ::google::protobuf::int32 max_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Vec3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.Vec3) */ {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(Vec3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Vec3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Vec3* other);
  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec3* New() const final {
    return CreateMaybeMessage<Vec3>(NULL);
  }

  Vec3* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vec3>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Analytics.Vec3)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Vec3Color : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.Vec3Color) */ {
 public:
  Vec3Color();
  virtual ~Vec3Color();

  Vec3Color(const Vec3Color& from);

  inline Vec3Color& operator=(const Vec3Color& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vec3Color(Vec3Color&& from) noexcept
    : Vec3Color() {
    *this = ::std::move(from);
  }

  inline Vec3Color& operator=(Vec3Color&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Vec3Color& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec3Color* internal_default_instance() {
    return reinterpret_cast<const Vec3Color*>(
               &_Vec3Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Vec3Color* other);
  friend void swap(Vec3Color& a, Vec3Color& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec3Color* New() const final {
    return CreateMaybeMessage<Vec3Color>(NULL);
  }

  Vec3Color* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vec3Color>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vec3Color& from);
  void MergeFrom(const Vec3Color& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3Color* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // uint32 color = 4;
  void clear_color();
  static const int kColorFieldNumber = 4;
  ::google::protobuf::uint32 color() const;
  void set_color(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Analytics.Vec3Color)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  ::google::protobuf::uint32 color_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Vec4 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.Vec4) */ {
 public:
  Vec4();
  virtual ~Vec4();

  Vec4(const Vec4& from);

  inline Vec4& operator=(const Vec4& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vec4(Vec4&& from) noexcept
    : Vec4() {
    *this = ::std::move(from);
  }

  inline Vec4& operator=(Vec4&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Vec4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec4* internal_default_instance() {
    return reinterpret_cast<const Vec4*>(
               &_Vec4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Vec4* other);
  friend void swap(Vec4& a, Vec4& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vec4* New() const final {
    return CreateMaybeMessage<Vec4>(NULL);
  }

  Vec4* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vec4>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vec4& from);
  void MergeFrom(const Vec4& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec4* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // float w = 4;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:Analytics.Vec4)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  float w_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Line : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.Line) */ {
 public:
  Line();
  virtual ~Line();

  Line(const Line& from);

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(Line&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Line& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Line* other);
  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Line* New() const final {
    return CreateMaybeMessage<Line>(NULL);
  }

  Line* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Analytics.Vec3 p0 = 1;
  bool has_p0() const;
  void clear_p0();
  static const int kP0FieldNumber = 1;
  const ::Analytics::Vec3& p0() const;
  ::Analytics::Vec3* release_p0();
  ::Analytics::Vec3* mutable_p0();
  void set_allocated_p0(::Analytics::Vec3* p0);

  // .Analytics.Vec3 p1 = 2;
  bool has_p1() const;
  void clear_p1();
  static const int kP1FieldNumber = 2;
  const ::Analytics::Vec3& p1() const;
  ::Analytics::Vec3* release_p1();
  ::Analytics::Vec3* mutable_p1();
  void set_allocated_p1(::Analytics::Vec3* p1);

  // @@protoc_insertion_point(class_scope:Analytics.Line)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* p0_;
  ::Analytics::Vec3* p1_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Euler : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.Euler) */ {
 public:
  Euler();
  virtual ~Euler();

  Euler(const Euler& from);

  inline Euler& operator=(const Euler& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Euler(Euler&& from) noexcept
    : Euler() {
    *this = ::std::move(from);
  }

  inline Euler& operator=(Euler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Euler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Euler* internal_default_instance() {
    return reinterpret_cast<const Euler*>(
               &_Euler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(Euler* other);
  friend void swap(Euler& a, Euler& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Euler* New() const final {
    return CreateMaybeMessage<Euler>(NULL);
  }

  Euler* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Euler>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Euler& from);
  void MergeFrom(const Euler& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Euler* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float heading = 1;
  void clear_heading();
  static const int kHeadingFieldNumber = 1;
  float heading() const;
  void set_heading(float value);

  // float pitch = 2;
  void clear_pitch();
  static const int kPitchFieldNumber = 2;
  float pitch() const;
  void set_pitch(float value);

  // float roll = 3;
  void clear_roll();
  static const int kRollFieldNumber = 3;
  float roll() const;
  void set_roll(float value);

  // @@protoc_insertion_point(class_scope:Analytics.Euler)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float heading_;
  float pitch_;
  float roll_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Material : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.Material) */ {
 public:
  Material();
  virtual ~Material();

  Material(const Material& from);

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Material(Material&& from) noexcept
    : Material() {
    *this = ::std::move(from);
  }

  inline Material& operator=(Material&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Material& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Material* internal_default_instance() {
    return reinterpret_cast<const Material*>(
               &_Material_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(Material* other);
  friend void swap(Material& a, Material& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Material* New() const final {
    return CreateMaybeMessage<Material>(NULL);
  }

  Material* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Material>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Material* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // uint32 contents = 2 [(.Analytics.enumkey) = "CONTENT_FLAGS", (.Analytics.enumflags) = true];
  void clear_contents();
  static const int kContentsFieldNumber = 2;
  ::google::protobuf::uint32 contents() const;
  void set_contents(::google::protobuf::uint32 value);

  // uint32 surfaceFlags = 3 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.enumflags) = true];
  void clear_surfaceflags();
  static const int kSurfaceFlagsFieldNumber = 3;
  ::google::protobuf::uint32 surfaceflags() const;
  void set_surfaceflags(::google::protobuf::uint32 value);

  // bool renderEvents = 4;
  void clear_renderevents();
  static const int kRenderEventsFieldNumber = 4;
  bool renderevents() const;
  void set_renderevents(bool value);

  // @@protoc_insertion_point(class_scope:Analytics.Material)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 contents_;
  ::google::protobuf::uint32 surfaceflags_;
  bool renderevents_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class PrimitiveOptions : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.PrimitiveOptions) */ {
 public:
  PrimitiveOptions();
  virtual ~PrimitiveOptions();

  PrimitiveOptions(const PrimitiveOptions& from);

  inline PrimitiveOptions& operator=(const PrimitiveOptions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PrimitiveOptions(PrimitiveOptions&& from) noexcept
    : PrimitiveOptions() {
    *this = ::std::move(from);
  }

  inline PrimitiveOptions& operator=(PrimitiveOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PrimitiveOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrimitiveOptions* internal_default_instance() {
    return reinterpret_cast<const PrimitiveOptions*>(
               &_PrimitiveOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PrimitiveOptions* other);
  friend void swap(PrimitiveOptions& a, PrimitiveOptions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PrimitiveOptions* New() const final {
    return CreateMaybeMessage<PrimitiveOptions>(NULL);
  }

  PrimitiveOptions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PrimitiveOptions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PrimitiveOptions& from);
  void MergeFrom(const PrimitiveOptions& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrimitiveOptions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 partIndex = 1 [(.Analytics.editable_key) = true];
  void clear_partindex();
  static const int kPartIndexFieldNumber = 1;
  ::google::protobuf::uint32 partindex() const;
  void set_partindex(::google::protobuf::uint32 value);

  // uint32 overrideSurfaceFlags = 2 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.editable) = true, (.Analytics.enumflags) = true];
  void clear_overridesurfaceflags();
  static const int kOverrideSurfaceFlagsFieldNumber = 2;
  ::google::protobuf::uint32 overridesurfaceflags() const;
  void set_overridesurfaceflags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Analytics.PrimitiveOptions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 partindex_;
  ::google::protobuf::uint32 overridesurfaceflags_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Primitive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.Primitive) */ {
 public:
  Primitive();
  virtual ~Primitive();

  Primitive(const Primitive& from);

  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Primitive(Primitive&& from) noexcept
    : Primitive() {
    *this = ::std::move(from);
  }

  inline Primitive& operator=(Primitive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Primitive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Primitive* internal_default_instance() {
    return reinterpret_cast<const Primitive*>(
               &_Primitive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Primitive* other);
  friend void swap(Primitive& a, Primitive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Primitive* New() const final {
    return CreateMaybeMessage<Primitive>(NULL);
  }

  Primitive* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Primitive>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Primitive& from);
  void MergeFrom(const Primitive& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Primitive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Analytics.Vec3Color vertices = 5;
  int vertices_size() const;
  void clear_vertices();
  static const int kVerticesFieldNumber = 5;
  ::Analytics::Vec3Color* mutable_vertices(int index);
  ::google::protobuf::RepeatedPtrField< ::Analytics::Vec3Color >*
      mutable_vertices();
  const ::Analytics::Vec3Color& vertices(int index) const;
  ::Analytics::Vec3Color* add_vertices();
  const ::google::protobuf::RepeatedPtrField< ::Analytics::Vec3Color >&
      vertices() const;

  // .Analytics.PrimitiveOptions options = 3;
  bool has_options() const;
  void clear_options();
  static const int kOptionsFieldNumber = 3;
  const ::Analytics::PrimitiveOptions& options() const;
  ::Analytics::PrimitiveOptions* release_options();
  ::Analytics::PrimitiveOptions* mutable_options();
  void set_allocated_options(::Analytics::PrimitiveOptions* options);

  // .Analytics.PrimitiveType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::Analytics::PrimitiveType type() const;
  void set_type(::Analytics::PrimitiveType value);

  // uint32 materialIndex = 2;
  void clear_materialindex();
  static const int kMaterialIndexFieldNumber = 2;
  ::google::protobuf::uint32 materialindex() const;
  void set_materialindex(::google::protobuf::uint32 value);

  // float size = 4;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  float size() const;
  void set_size(float value);

  // @@protoc_insertion_point(class_scope:Analytics.Primitive)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::Vec3Color > vertices_;
  ::Analytics::PrimitiveOptions* options_;
  int type_;
  ::google::protobuf::uint32 materialindex_;
  float size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Mesh : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.Mesh) */ {
 public:
  Mesh();
  virtual ~Mesh();

  Mesh(const Mesh& from);

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Mesh(Mesh&& from) noexcept
    : Mesh() {
    *this = ::std::move(from);
  }

  inline Mesh& operator=(Mesh&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Mesh& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
               &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(Mesh* other);
  friend void swap(Mesh& a, Mesh& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Mesh* New() const final {
    return CreateMaybeMessage<Mesh>(NULL);
  }

  Mesh* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Mesh>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mesh* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Analytics.Primitive primitives = 1;
  int primitives_size() const;
  void clear_primitives();
  static const int kPrimitivesFieldNumber = 1;
  ::Analytics::Primitive* mutable_primitives(int index);
  ::google::protobuf::RepeatedPtrField< ::Analytics::Primitive >*
      mutable_primitives();
  const ::Analytics::Primitive& primitives(int index) const;
  ::Analytics::Primitive* add_primitives();
  const ::google::protobuf::RepeatedPtrField< ::Analytics::Primitive >&
      primitives() const;

  // repeated .Analytics.Material materials = 2;
  int materials_size() const;
  void clear_materials();
  static const int kMaterialsFieldNumber = 2;
  ::Analytics::Material* mutable_materials(int index);
  ::google::protobuf::RepeatedPtrField< ::Analytics::Material >*
      mutable_materials();
  const ::Analytics::Material& materials(int index) const;
  ::Analytics::Material* add_materials();
  const ::google::protobuf::RepeatedPtrField< ::Analytics::Material >&
      materials() const;

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:Analytics.Mesh)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::Primitive > primitives_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::Material > materials_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class UTCTime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.UTCTime) */ {
 public:
  UTCTime();
  virtual ~UTCTime();

  UTCTime(const UTCTime& from);

  inline UTCTime& operator=(const UTCTime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UTCTime(UTCTime&& from) noexcept
    : UTCTime() {
    *this = ::std::move(from);
  }

  inline UTCTime& operator=(UTCTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UTCTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UTCTime* internal_default_instance() {
    return reinterpret_cast<const UTCTime*>(
               &_UTCTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(UTCTime* other);
  friend void swap(UTCTime& a, UTCTime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UTCTime* New() const final {
    return CreateMaybeMessage<UTCTime>(NULL);
  }

  UTCTime* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UTCTime>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UTCTime& from);
  void MergeFrom(const UTCTime& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UTCTime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 hour = 1;
  void clear_hour();
  static const int kHourFieldNumber = 1;
  ::google::protobuf::int32 hour() const;
  void set_hour(::google::protobuf::int32 value);

  // int32 minute = 2;
  void clear_minute();
  static const int kMinuteFieldNumber = 2;
  ::google::protobuf::int32 minute() const;
  void set_minute(::google::protobuf::int32 value);

  // int32 second = 3;
  void clear_second();
  static const int kSecondFieldNumber = 3;
  ::google::protobuf::int32 second() const;
  void set_second(::google::protobuf::int32 value);

  // int32 day = 4;
  void clear_day();
  static const int kDayFieldNumber = 4;
  ::google::protobuf::int32 day() const;
  void set_day(::google::protobuf::int32 value);

  // int32 month = 5;
  void clear_month();
  static const int kMonthFieldNumber = 5;
  ::google::protobuf::int32 month() const;
  void set_month(::google::protobuf::int32 value);

  // int32 year = 6;
  void clear_year();
  static const int kYearFieldNumber = 6;
  ::google::protobuf::int32 year() const;
  void set_year(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.UTCTime)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 hour_;
  ::google::protobuf::int32 minute_;
  ::google::protobuf::int32 second_;
  ::google::protobuf::int32 day_;
  ::google::protobuf::int32 month_;
  ::google::protobuf::int32 year_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameInfo) */ {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameInfo(GameInfo&& from) noexcept
    : GameInfo() {
    *this = ::std::move(from);
  }

  inline GameInfo& operator=(GameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInfo* internal_default_instance() {
    return reinterpret_cast<const GameInfo*>(
               &_GameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GameInfo* other);
  friend void swap(GameInfo& a, GameInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameInfo* New() const final {
    return CreateMaybeMessage<GameInfo>(NULL);
  }

  GameInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string mapName = 2;
  void clear_mapname();
  static const int kMapNameFieldNumber = 2;
  const ::std::string& mapname() const;
  void set_mapname(const ::std::string& value);
  #if LANG_CXX11
  void set_mapname(::std::string&& value);
  #endif
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  ::std::string* mutable_mapname();
  ::std::string* release_mapname();
  void set_allocated_mapname(::std::string* mapname);

  // string gameName = 3;
  void clear_gamename();
  static const int kGameNameFieldNumber = 3;
  const ::std::string& gamename() const;
  void set_gamename(const ::std::string& value);
  #if LANG_CXX11
  void set_gamename(::std::string&& value);
  #endif
  void set_gamename(const char* value);
  void set_gamename(const char* value, size_t size);
  ::std::string* mutable_gamename();
  ::std::string* release_gamename();
  void set_allocated_gamename(::std::string* gamename);

  // string gameVersion = 4;
  void clear_gameversion();
  static const int kGameVersionFieldNumber = 4;
  const ::std::string& gameversion() const;
  void set_gameversion(const ::std::string& value);
  #if LANG_CXX11
  void set_gameversion(::std::string&& value);
  #endif
  void set_gameversion(const char* value);
  void set_gameversion(const char* value, size_t size);
  ::std::string* mutable_gameversion();
  ::std::string* release_gameversion();
  void set_allocated_gameversion(::std::string* gameversion);

  // .Analytics.UTCTime timeStamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 1;
  const ::Analytics::UTCTime& timestamp() const;
  ::Analytics::UTCTime* release_timestamp();
  ::Analytics::UTCTime* mutable_timestamp();
  void set_allocated_timestamp(::Analytics::UTCTime* timestamp);

  // @@protoc_insertion_point(class_scope:Analytics.GameInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mapname_;
  ::google::protobuf::internal::ArenaStringPtr gamename_;
  ::google::protobuf::internal::ArenaStringPtr gameversion_;
  ::Analytics::UTCTime* timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEnum_EnumPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEnum.EnumPair) */ {
 public:
  GameEnum_EnumPair();
  virtual ~GameEnum_EnumPair();

  GameEnum_EnumPair(const GameEnum_EnumPair& from);

  inline GameEnum_EnumPair& operator=(const GameEnum_EnumPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameEnum_EnumPair(GameEnum_EnumPair&& from) noexcept
    : GameEnum_EnumPair() {
    *this = ::std::move(from);
  }

  inline GameEnum_EnumPair& operator=(GameEnum_EnumPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameEnum_EnumPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEnum_EnumPair* internal_default_instance() {
    return reinterpret_cast<const GameEnum_EnumPair*>(
               &_GameEnum_EnumPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GameEnum_EnumPair* other);
  friend void swap(GameEnum_EnumPair& a, GameEnum_EnumPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameEnum_EnumPair* New() const final {
    return CreateMaybeMessage<GameEnum_EnumPair>(NULL);
  }

  GameEnum_EnumPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameEnum_EnumPair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameEnum_EnumPair& from);
  void MergeFrom(const GameEnum_EnumPair& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEnum_EnumPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameEnum.EnumPair)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEnum : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEnum) */ {
 public:
  GameEnum();
  virtual ~GameEnum();

  GameEnum(const GameEnum& from);

  inline GameEnum& operator=(const GameEnum& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameEnum(GameEnum&& from) noexcept
    : GameEnum() {
    *this = ::std::move(from);
  }

  inline GameEnum& operator=(GameEnum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameEnum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEnum* internal_default_instance() {
    return reinterpret_cast<const GameEnum*>(
               &_GameEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GameEnum* other);
  friend void swap(GameEnum& a, GameEnum& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameEnum* New() const final {
    return CreateMaybeMessage<GameEnum>(NULL);
  }

  GameEnum* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameEnum>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameEnum& from);
  void MergeFrom(const GameEnum& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEnum* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameEnum_EnumPair EnumPair;

  // accessors -------------------------------------------------------

  // repeated .Analytics.GameEnum.EnumPair values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::Analytics::GameEnum_EnumPair* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::Analytics::GameEnum_EnumPair >*
      mutable_values();
  const ::Analytics::GameEnum_EnumPair& values(int index) const;
  ::Analytics::GameEnum_EnumPair* add_values();
  const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEnum_EnumPair >&
      values() const;

  // string enumname = 2;
  void clear_enumname();
  static const int kEnumnameFieldNumber = 2;
  const ::std::string& enumname() const;
  void set_enumname(const ::std::string& value);
  #if LANG_CXX11
  void set_enumname(::std::string&& value);
  #endif
  void set_enumname(const char* value);
  void set_enumname(const char* value, size_t size);
  ::std::string* mutable_enumname();
  ::std::string* release_enumname();
  void set_allocated_enumname(::std::string* enumname);

  // bool isbitfield = 3;
  void clear_isbitfield();
  static const int kIsbitfieldFieldNumber = 3;
  bool isbitfield() const;
  void set_isbitfield(bool value);

  // @@protoc_insertion_point(class_scope:Analytics.GameEnum)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::GameEnum_EnumPair > values_;
  ::google::protobuf::internal::ArenaStringPtr enumname_;
  bool isbitfield_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameNavNotFound : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameNavNotFound) */ {
 public:
  GameNavNotFound();
  virtual ~GameNavNotFound();

  GameNavNotFound(const GameNavNotFound& from);

  inline GameNavNotFound& operator=(const GameNavNotFound& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameNavNotFound(GameNavNotFound&& from) noexcept
    : GameNavNotFound() {
    *this = ::std::move(from);
  }

  inline GameNavNotFound& operator=(GameNavNotFound&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameNavNotFound& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameNavNotFound* internal_default_instance() {
    return reinterpret_cast<const GameNavNotFound*>(
               &_GameNavNotFound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(GameNavNotFound* other);
  friend void swap(GameNavNotFound& a, GameNavNotFound& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameNavNotFound* New() const final {
    return CreateMaybeMessage<GameNavNotFound>(NULL);
  }

  GameNavNotFound* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameNavNotFound>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameNavNotFound& from);
  void MergeFrom(const GameNavNotFound& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameNavNotFound* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string mapName = 1;
  void clear_mapname();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& mapname() const;
  void set_mapname(const ::std::string& value);
  #if LANG_CXX11
  void set_mapname(::std::string&& value);
  #endif
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  ::std::string* mutable_mapname();
  ::std::string* release_mapname();
  void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Analytics.GameNavNotFound)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mapname_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameNavAutoDownloaded : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameNavAutoDownloaded) */ {
 public:
  GameNavAutoDownloaded();
  virtual ~GameNavAutoDownloaded();

  GameNavAutoDownloaded(const GameNavAutoDownloaded& from);

  inline GameNavAutoDownloaded& operator=(const GameNavAutoDownloaded& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameNavAutoDownloaded(GameNavAutoDownloaded&& from) noexcept
    : GameNavAutoDownloaded() {
    *this = ::std::move(from);
  }

  inline GameNavAutoDownloaded& operator=(GameNavAutoDownloaded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameNavAutoDownloaded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameNavAutoDownloaded* internal_default_instance() {
    return reinterpret_cast<const GameNavAutoDownloaded*>(
               &_GameNavAutoDownloaded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(GameNavAutoDownloaded* other);
  friend void swap(GameNavAutoDownloaded& a, GameNavAutoDownloaded& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameNavAutoDownloaded* New() const final {
    return CreateMaybeMessage<GameNavAutoDownloaded>(NULL);
  }

  GameNavAutoDownloaded* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameNavAutoDownloaded>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameNavAutoDownloaded& from);
  void MergeFrom(const GameNavAutoDownloaded& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameNavAutoDownloaded* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string mapName = 1;
  void clear_mapname();
  static const int kMapNameFieldNumber = 1;
  const ::std::string& mapname() const;
  void set_mapname(const ::std::string& value);
  #if LANG_CXX11
  void set_mapname(::std::string&& value);
  #endif
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  ::std::string* mutable_mapname();
  ::std::string* release_mapname();
  void set_allocated_mapname(::std::string* mapname);

  // @@protoc_insertion_point(class_scope:Analytics.GameNavAutoDownloaded)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr mapname_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameAssert : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameAssert) */ {
 public:
  GameAssert();
  virtual ~GameAssert();

  GameAssert(const GameAssert& from);

  inline GameAssert& operator=(const GameAssert& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameAssert(GameAssert&& from) noexcept
    : GameAssert() {
    *this = ::std::move(from);
  }

  inline GameAssert& operator=(GameAssert&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameAssert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameAssert* internal_default_instance() {
    return reinterpret_cast<const GameAssert*>(
               &_GameAssert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(GameAssert* other);
  friend void swap(GameAssert& a, GameAssert& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameAssert* New() const final {
    return CreateMaybeMessage<GameAssert>(NULL);
  }

  GameAssert* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameAssert>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameAssert& from);
  void MergeFrom(const GameAssert& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameAssert* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string condition = 1;
  void clear_condition();
  static const int kConditionFieldNumber = 1;
  const ::std::string& condition() const;
  void set_condition(const ::std::string& value);
  #if LANG_CXX11
  void set_condition(::std::string&& value);
  #endif
  void set_condition(const char* value);
  void set_condition(const char* value, size_t size);
  ::std::string* mutable_condition();
  ::std::string* release_condition();
  void set_allocated_condition(::std::string* condition);

  // string file = 2;
  void clear_file();
  static const int kFileFieldNumber = 2;
  const ::std::string& file() const;
  void set_file(const ::std::string& value);
  #if LANG_CXX11
  void set_file(::std::string&& value);
  #endif
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  ::std::string* mutable_file();
  ::std::string* release_file();
  void set_allocated_file(::std::string* file);

  // int32 line = 3;
  void clear_line();
  static const int kLineFieldNumber = 3;
  ::google::protobuf::int32 line() const;
  void set_line(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameAssert)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr condition_;
  ::google::protobuf::internal::ArenaStringPtr file_;
  ::google::protobuf::int32 line_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameCrash : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameCrash) */ {
 public:
  GameCrash();
  virtual ~GameCrash();

  GameCrash(const GameCrash& from);

  inline GameCrash& operator=(const GameCrash& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameCrash(GameCrash&& from) noexcept
    : GameCrash() {
    *this = ::std::move(from);
  }

  inline GameCrash& operator=(GameCrash&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameCrash& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameCrash* internal_default_instance() {
    return reinterpret_cast<const GameCrash*>(
               &_GameCrash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(GameCrash* other);
  friend void swap(GameCrash& a, GameCrash& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameCrash* New() const final {
    return CreateMaybeMessage<GameCrash>(NULL);
  }

  GameCrash* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameCrash>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameCrash& from);
  void MergeFrom(const GameCrash& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameCrash* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string info = 1;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:Analytics.GameCrash)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameMeshData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameMeshData) */ {
 public:
  GameMeshData();
  virtual ~GameMeshData();

  GameMeshData(const GameMeshData& from);

  inline GameMeshData& operator=(const GameMeshData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameMeshData(GameMeshData&& from) noexcept
    : GameMeshData() {
    *this = ::std::move(from);
  }

  inline GameMeshData& operator=(GameMeshData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameMeshData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMeshData* internal_default_instance() {
    return reinterpret_cast<const GameMeshData*>(
               &_GameMeshData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(GameMeshData* other);
  friend void swap(GameMeshData& a, GameMeshData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameMeshData* New() const final {
    return CreateMaybeMessage<GameMeshData>(NULL);
  }

  GameMeshData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameMeshData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameMeshData& from);
  void MergeFrom(const GameMeshData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMeshData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string modelName = 2;
  void clear_modelname();
  static const int kModelNameFieldNumber = 2;
  const ::std::string& modelname() const;
  void set_modelname(const ::std::string& value);
  #if LANG_CXX11
  void set_modelname(::std::string&& value);
  #endif
  void set_modelname(const char* value);
  void set_modelname(const char* value, size_t size);
  ::std::string* mutable_modelname();
  ::std::string* release_modelname();
  void set_allocated_modelname(::std::string* modelname);

  // bytes modelBytes = 3;
  void clear_modelbytes();
  static const int kModelBytesFieldNumber = 3;
  const ::std::string& modelbytes() const;
  void set_modelbytes(const ::std::string& value);
  #if LANG_CXX11
  void set_modelbytes(::std::string&& value);
  #endif
  void set_modelbytes(const char* value);
  void set_modelbytes(const void* value, size_t size);
  ::std::string* mutable_modelbytes();
  ::std::string* release_modelbytes();
  void set_allocated_modelbytes(::std::string* modelbytes);

  // .Analytics.Compression compressionType = 1;
  void clear_compressiontype();
  static const int kCompressionTypeFieldNumber = 1;
  ::Analytics::Compression compressiontype() const;
  void set_compressiontype(::Analytics::Compression value);

  // uint32 modelBytesUncompressed = 4;
  void clear_modelbytesuncompressed();
  static const int kModelBytesUncompressedFieldNumber = 4;
  ::google::protobuf::uint32 modelbytesuncompressed() const;
  void set_modelbytesuncompressed(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameMeshData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr modelname_;
  ::google::protobuf::internal::ArenaStringPtr modelbytes_;
  int compressiontype_;
  ::google::protobuf::uint32 modelbytesuncompressed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEntityInfo_Ammo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEntityInfo.Ammo) */ {
 public:
  GameEntityInfo_Ammo();
  virtual ~GameEntityInfo_Ammo();

  GameEntityInfo_Ammo(const GameEntityInfo_Ammo& from);

  inline GameEntityInfo_Ammo& operator=(const GameEntityInfo_Ammo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameEntityInfo_Ammo(GameEntityInfo_Ammo&& from) noexcept
    : GameEntityInfo_Ammo() {
    *this = ::std::move(from);
  }

  inline GameEntityInfo_Ammo& operator=(GameEntityInfo_Ammo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameEntityInfo_Ammo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEntityInfo_Ammo* internal_default_instance() {
    return reinterpret_cast<const GameEntityInfo_Ammo*>(
               &_GameEntityInfo_Ammo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(GameEntityInfo_Ammo* other);
  friend void swap(GameEntityInfo_Ammo& a, GameEntityInfo_Ammo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameEntityInfo_Ammo* New() const final {
    return CreateMaybeMessage<GameEntityInfo_Ammo>(NULL);
  }

  GameEntityInfo_Ammo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameEntityInfo_Ammo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameEntityInfo_Ammo& from);
  void MergeFrom(const GameEntityInfo_Ammo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEntityInfo_Ammo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 ammoType = 1 [(.Analytics.enumkey) = "AMMO_TYPE"];
  void clear_ammotype();
  static const int kAmmoTypeFieldNumber = 1;
  ::google::protobuf::uint32 ammotype() const;
  void set_ammotype(::google::protobuf::uint32 value);

  // uint32 ammoCount = 2;
  void clear_ammocount();
  static const int kAmmoCountFieldNumber = 2;
  ::google::protobuf::uint32 ammocount() const;
  void set_ammocount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityInfo.Ammo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 ammotype_;
  ::google::protobuf::uint32 ammocount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEntityInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEntityInfo) */ {
 public:
  GameEntityInfo();
  virtual ~GameEntityInfo();

  GameEntityInfo(const GameEntityInfo& from);

  inline GameEntityInfo& operator=(const GameEntityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameEntityInfo(GameEntityInfo&& from) noexcept
    : GameEntityInfo() {
    *this = ::std::move(from);
  }

  inline GameEntityInfo& operator=(GameEntityInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameEntityInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEntityInfo* internal_default_instance() {
    return reinterpret_cast<const GameEntityInfo*>(
               &_GameEntityInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(GameEntityInfo* other);
  friend void swap(GameEntityInfo& a, GameEntityInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameEntityInfo* New() const final {
    return CreateMaybeMessage<GameEntityInfo>(NULL);
  }

  GameEntityInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameEntityInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameEntityInfo& from);
  void MergeFrom(const GameEntityInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEntityInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GameEntityInfo_Ammo Ammo;

  // accessors -------------------------------------------------------

  // repeated .Analytics.GameEntityInfo.Ammo ammo = 19;
  int ammo_size() const;
  void clear_ammo();
  static const int kAmmoFieldNumber = 19;
  ::Analytics::GameEntityInfo_Ammo* mutable_ammo(int index);
  ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >*
      mutable_ammo();
  const ::Analytics::GameEntityInfo_Ammo& ammo(int index) const;
  ::Analytics::GameEntityInfo_Ammo* add_ammo();
  const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >&
      ammo() const;

  // string entityName = 1;
  void clear_entityname();
  static const int kEntityNameFieldNumber = 1;
  const ::std::string& entityname() const;
  void set_entityname(const ::std::string& value);
  #if LANG_CXX11
  void set_entityname(::std::string&& value);
  #endif
  void set_entityname(const char* value);
  void set_entityname(const char* value, size_t size);
  ::std::string* mutable_entityname();
  ::std::string* release_entityname();
  void set_allocated_entityname(::std::string* entityname);

  // .Analytics.Vec3 eulerRotation = 11 [(.Analytics.hidden) = true];
  bool has_eulerrotation() const;
  void clear_eulerrotation();
  static const int kEulerRotationFieldNumber = 11;
  const ::Analytics::Vec3& eulerrotation() const;
  ::Analytics::Vec3* release_eulerrotation();
  ::Analytics::Vec3* mutable_eulerrotation();
  void set_allocated_eulerrotation(::Analytics::Vec3* eulerrotation);

  // .Analytics.Vec3 position = 12 [(.Analytics.hidden) = true];
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 12;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // .Analytics.Vec3 eyeOffset = 13 [(.Analytics.hidden) = true];
  bool has_eyeoffset() const;
  void clear_eyeoffset();
  static const int kEyeOffsetFieldNumber = 13;
  const ::Analytics::Vec3& eyeoffset() const;
  ::Analytics::Vec3* release_eyeoffset();
  ::Analytics::Vec3* mutable_eyeoffset();
  void set_allocated_eyeoffset(::Analytics::Vec3* eyeoffset);

  // .Analytics.Vec3 eyeDir = 14 [(.Analytics.hidden) = true];
  bool has_eyedir() const;
  void clear_eyedir();
  static const int kEyeDirFieldNumber = 14;
  const ::Analytics::Vec3& eyedir() const;
  ::Analytics::Vec3* release_eyedir();
  ::Analytics::Vec3* mutable_eyedir();
  void set_allocated_eyedir(::Analytics::Vec3* eyedir);

  // .Analytics.RangeI health = 15;
  bool has_health() const;
  void clear_health();
  static const int kHealthFieldNumber = 15;
  const ::Analytics::RangeI& health() const;
  ::Analytics::RangeI* release_health();
  ::Analytics::RangeI* mutable_health();
  void set_allocated_health(::Analytics::RangeI* health);

  // .Analytics.RangeI armor = 16;
  bool has_armor() const;
  void clear_armor();
  static const int kArmorFieldNumber = 16;
  const ::Analytics::RangeI& armor() const;
  ::Analytics::RangeI* release_armor();
  ::Analytics::RangeI* mutable_armor();
  void set_allocated_armor(::Analytics::RangeI* armor);

  // .Analytics.Vec3 boundsMin = 17;
  bool has_boundsmin() const;
  void clear_boundsmin();
  static const int kBoundsMinFieldNumber = 17;
  const ::Analytics::Vec3& boundsmin() const;
  ::Analytics::Vec3* release_boundsmin();
  ::Analytics::Vec3* mutable_boundsmin();
  void set_allocated_boundsmin(::Analytics::Vec3* boundsmin);

  // .Analytics.Vec3 boundsMax = 18;
  bool has_boundsmax() const;
  void clear_boundsmax();
  static const int kBoundsMaxFieldNumber = 18;
  const ::Analytics::Vec3& boundsmax() const;
  ::Analytics::Vec3* release_boundsmax();
  ::Analytics::Vec3* mutable_boundsmax();
  void set_allocated_boundsmax(::Analytics::Vec3* boundsmax);

  // int32 entityIndex = 2;
  void clear_entityindex();
  static const int kEntityIndexFieldNumber = 2;
  ::google::protobuf::int32 entityindex() const;
  void set_entityindex(::google::protobuf::int32 value);

  // int32 entitySerial = 3;
  void clear_entityserial();
  static const int kEntitySerialFieldNumber = 3;
  ::google::protobuf::int32 entityserial() const;
  void set_entityserial(::google::protobuf::int32 value);

  // int32 groupId = 4 [(.Analytics.enumkey) = "GROUP_ID"];
  void clear_groupid();
  static const int kGroupIdFieldNumber = 4;
  ::google::protobuf::int32 groupid() const;
  void set_groupid(::google::protobuf::int32 value);

  // int32 classId = 5 [(.Analytics.enumkey) = "CLASS_ID"];
  void clear_classid();
  static const int kClassIdFieldNumber = 5;
  ::google::protobuf::int32 classid() const;
  void set_classid(::google::protobuf::int32 value);

  // int64 entityFlags = 7 [(.Analytics.enumkey) = "ENTITY_FLAGS", (.Analytics.enumflagsindexed) = true];
  void clear_entityflags();
  static const int kEntityFlagsFieldNumber = 7;
  ::google::protobuf::int64 entityflags() const;
  void set_entityflags(::google::protobuf::int64 value);

  // int32 team = 6 [(.Analytics.enumkey) = "TEAM_ID"];
  void clear_team();
  static const int kTeamFieldNumber = 6;
  ::google::protobuf::int32 team() const;
  void set_team(::google::protobuf::int32 value);

  // int32 category = 8 [(.Analytics.enumkey) = "CATEGORY_ID", (.Analytics.enumflagsindexed) = true];
  void clear_category();
  static const int kCategoryFieldNumber = 8;
  ::google::protobuf::int32 category() const;
  void set_category(::google::protobuf::int32 value);

  // int64 navFlags = 10 [(.Analytics.enumkey) = "NAV_FLAGS"];
  void clear_navflags();
  static const int kNavFlagsFieldNumber = 10;
  ::google::protobuf::int64 navflags() const;
  void set_navflags(::google::protobuf::int64 value);

  // int32 powerUps = 9 [(.Analytics.enumkey) = "POWERUP_ID", (.Analytics.enumflagsindexed) = true];
  void clear_powerups();
  static const int kPowerUpsFieldNumber = 9;
  ::google::protobuf::int32 powerups() const;
  void set_powerups(::google::protobuf::int32 value);

  // bool deleted = 1000 [(.Analytics.hidden) = true];
  void clear_deleted();
  static const int kDeletedFieldNumber = 1000;
  bool deleted() const;
  void set_deleted(bool value);

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo > ammo_;
  ::google::protobuf::internal::ArenaStringPtr entityname_;
  ::Analytics::Vec3* eulerrotation_;
  ::Analytics::Vec3* position_;
  ::Analytics::Vec3* eyeoffset_;
  ::Analytics::Vec3* eyedir_;
  ::Analytics::RangeI* health_;
  ::Analytics::RangeI* armor_;
  ::Analytics::Vec3* boundsmin_;
  ::Analytics::Vec3* boundsmax_;
  ::google::protobuf::int32 entityindex_;
  ::google::protobuf::int32 entityserial_;
  ::google::protobuf::int32 groupid_;
  ::google::protobuf::int32 classid_;
  ::google::protobuf::int64 entityflags_;
  ::google::protobuf::int32 team_;
  ::google::protobuf::int32 category_;
  ::google::protobuf::int64 navflags_;
  ::google::protobuf::int32 powerups_;
  bool deleted_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEntityPosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEntityPosition) */ {
 public:
  GameEntityPosition();
  virtual ~GameEntityPosition();

  GameEntityPosition(const GameEntityPosition& from);

  inline GameEntityPosition& operator=(const GameEntityPosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameEntityPosition(GameEntityPosition&& from) noexcept
    : GameEntityPosition() {
    *this = ::std::move(from);
  }

  inline GameEntityPosition& operator=(GameEntityPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameEntityPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEntityPosition* internal_default_instance() {
    return reinterpret_cast<const GameEntityPosition*>(
               &_GameEntityPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(GameEntityPosition* other);
  friend void swap(GameEntityPosition& a, GameEntityPosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameEntityPosition* New() const final {
    return CreateMaybeMessage<GameEntityPosition>(NULL);
  }

  GameEntityPosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameEntityPosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameEntityPosition& from);
  void MergeFrom(const GameEntityPosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEntityPosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // int32 team = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_team();
  static const int kTeamFieldNumber = 2;
  ::google::protobuf::int32 team() const;
  void set_team(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityPosition)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* position_;
  ::google::protobuf::int32 team_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameNode) */ {
 public:
  GameNode();
  virtual ~GameNode();

  GameNode(const GameNode& from);

  inline GameNode& operator=(const GameNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameNode(GameNode&& from) noexcept
    : GameNode() {
    *this = ::std::move(from);
  }

  inline GameNode& operator=(GameNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameNode* internal_default_instance() {
    return reinterpret_cast<const GameNode*>(
               &_GameNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(GameNode* other);
  friend void swap(GameNode& a, GameNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameNode* New() const final {
    return CreateMaybeMessage<GameNode>(NULL);
  }

  GameNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameNode& from);
  void MergeFrom(const GameNode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nodePath = 1 [(.Analytics.editable_key) = true];
  void clear_nodepath();
  static const int kNodePathFieldNumber = 1;
  const ::std::string& nodepath() const;
  void set_nodepath(const ::std::string& value);
  #if LANG_CXX11
  void set_nodepath(::std::string&& value);
  #endif
  void set_nodepath(const char* value);
  void set_nodepath(const char* value, size_t size);
  ::std::string* mutable_nodepath();
  ::std::string* release_nodepath();
  void set_allocated_nodepath(::std::string* nodepath);

  // string meshName = 4;
  void clear_meshname();
  static const int kMeshNameFieldNumber = 4;
  const ::std::string& meshname() const;
  void set_meshname(const ::std::string& value);
  #if LANG_CXX11
  void set_meshname(::std::string&& value);
  #endif
  void set_meshname(const char* value);
  void set_meshname(const char* value, size_t size);
  ::std::string* mutable_meshname();
  ::std::string* release_meshname();
  void set_allocated_meshname(::std::string* meshname);

  // string entityName = 11;
  void clear_entityname();
  static const int kEntityNameFieldNumber = 11;
  const ::std::string& entityname() const;
  void set_entityname(const ::std::string& value);
  #if LANG_CXX11
  void set_entityname(::std::string&& value);
  #endif
  void set_entityname(const char* value);
  void set_entityname(const char* value, size_t size);
  ::std::string* mutable_entityname();
  ::std::string* release_entityname();
  void set_allocated_entityname(::std::string* entityname);

  // .Analytics.Vec3 eulerRotation = 2;
  bool has_eulerrotation() const;
  void clear_eulerrotation();
  static const int kEulerRotationFieldNumber = 2;
  const ::Analytics::Vec3& eulerrotation() const;
  ::Analytics::Vec3* release_eulerrotation();
  ::Analytics::Vec3* mutable_eulerrotation();
  void set_allocated_eulerrotation(::Analytics::Vec3* eulerrotation);

  // .Analytics.Vec3 translation = 3;
  bool has_translation() const;
  void clear_translation();
  static const int kTranslationFieldNumber = 3;
  const ::Analytics::Vec3& translation() const;
  ::Analytics::Vec3* release_translation();
  ::Analytics::Vec3* mutable_translation();
  void set_allocated_translation(::Analytics::Vec3* translation);

  // int32 entityId = 10;
  void clear_entityid();
  static const int kEntityIdFieldNumber = 10;
  ::google::protobuf::int32 entityid() const;
  void set_entityid(::google::protobuf::int32 value);

  // int32 activeState = 12 [(.Analytics.enumkey) = "MODEL_STATE"];
  void clear_activestate();
  static const int kActiveStateFieldNumber = 12;
  ::google::protobuf::int32 activestate() const;
  void set_activestate(::google::protobuf::int32 value);

  // int32 shapeMode = 15 [(.Analytics.enumkey) = "SHAPEMODE", (.Analytics.editable) = true];
  void clear_shapemode();
  static const int kShapeModeFieldNumber = 15;
  ::google::protobuf::int32 shapemode() const;
  void set_shapemode(::google::protobuf::int32 value);

  // int64 navFlagsActive = 13 [(.Analytics.enumkey) = "NAV_FLAGS"];
  void clear_navflagsactive();
  static const int kNavFlagsActiveFieldNumber = 13;
  ::google::protobuf::int64 navflagsactive() const;
  void set_navflagsactive(::google::protobuf::int64 value);

  // int64 navFlagsOverride = 14 [(.Analytics.enumkey) = "NAV_FLAGS", (.Analytics.editable) = true];
  void clear_navflagsoverride();
  static const int kNavFlagsOverrideFieldNumber = 14;
  ::google::protobuf::int64 navflagsoverride() const;
  void set_navflagsoverride(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nodepath_;
  ::google::protobuf::internal::ArenaStringPtr meshname_;
  ::google::protobuf::internal::ArenaStringPtr entityname_;
  ::Analytics::Vec3* eulerrotation_;
  ::Analytics::Vec3* translation_;
  ::google::protobuf::int32 entityid_;
  ::google::protobuf::int32 activestate_;
  ::google::protobuf::int32 shapemode_;
  ::google::protobuf::int64 navflagsactive_;
  ::google::protobuf::int64 navflagsoverride_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameWeaponFired : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameWeaponFired) */ {
 public:
  GameWeaponFired();
  virtual ~GameWeaponFired();

  GameWeaponFired(const GameWeaponFired& from);

  inline GameWeaponFired& operator=(const GameWeaponFired& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameWeaponFired(GameWeaponFired&& from) noexcept
    : GameWeaponFired() {
    *this = ::std::move(from);
  }

  inline GameWeaponFired& operator=(GameWeaponFired&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameWeaponFired& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameWeaponFired* internal_default_instance() {
    return reinterpret_cast<const GameWeaponFired*>(
               &_GameWeaponFired_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(GameWeaponFired* other);
  friend void swap(GameWeaponFired& a, GameWeaponFired& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameWeaponFired* New() const final {
    return CreateMaybeMessage<GameWeaponFired>(NULL);
  }

  GameWeaponFired* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameWeaponFired>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameWeaponFired& from);
  void MergeFrom(const GameWeaponFired& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameWeaponFired* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // int32 attackTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  static const int kAttackTeamFieldNumber = 2;
  ::google::protobuf::int32 attackteam() const;
  void set_attackteam(::google::protobuf::int32 value);

  // int32 weaponId = 3 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  void clear_weaponid();
  static const int kWeaponIdFieldNumber = 3;
  ::google::protobuf::int32 weaponid() const;
  void set_weaponid(::google::protobuf::int32 value);

  // int32 firedByClass = 4 [(.Analytics.enumkey) = "CLASS_ID", (.Analytics.track_event) = true];
  void clear_firedbyclass();
  static const int kFiredByClassFieldNumber = 4;
  ::google::protobuf::int32 firedbyclass() const;
  void set_firedbyclass(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameWeaponFired)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* position_;
  ::google::protobuf::int32 attackteam_;
  ::google::protobuf::int32 weaponid_;
  ::google::protobuf::int32 firedbyclass_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameDeath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameDeath) */ {
 public:
  GameDeath();
  virtual ~GameDeath();

  GameDeath(const GameDeath& from);

  inline GameDeath& operator=(const GameDeath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameDeath(GameDeath&& from) noexcept
    : GameDeath() {
    *this = ::std::move(from);
  }

  inline GameDeath& operator=(GameDeath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameDeath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameDeath* internal_default_instance() {
    return reinterpret_cast<const GameDeath*>(
               &_GameDeath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(GameDeath* other);
  friend void swap(GameDeath& a, GameDeath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameDeath* New() const final {
    return CreateMaybeMessage<GameDeath>(NULL);
  }

  GameDeath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameDeath>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameDeath& from);
  void MergeFrom(const GameDeath& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameDeath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  void clear_meansofdeath();
  static const int kMeansOfDeathFieldNumber = 4;
  const ::std::string& meansofdeath() const;
  void set_meansofdeath(const ::std::string& value);
  #if LANG_CXX11
  void set_meansofdeath(::std::string&& value);
  #endif
  void set_meansofdeath(const char* value);
  void set_meansofdeath(const char* value, size_t size);
  ::std::string* mutable_meansofdeath();
  ::std::string* release_meansofdeath();
  void set_allocated_meansofdeath(::std::string* meansofdeath);

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_victimteam();
  static const int kVictimTeamFieldNumber = 2;
  ::google::protobuf::int32 victimteam() const;
  void set_victimteam(::google::protobuf::int32 value);

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  static const int kAttackTeamFieldNumber = 3;
  ::google::protobuf::int32 attackteam() const;
  void set_attackteam(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameDeath)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr meansofdeath_;
  ::Analytics::Vec3* position_;
  ::google::protobuf::int32 victimteam_;
  ::google::protobuf::int32 attackteam_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameKilledSomeone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameKilledSomeone) */ {
 public:
  GameKilledSomeone();
  virtual ~GameKilledSomeone();

  GameKilledSomeone(const GameKilledSomeone& from);

  inline GameKilledSomeone& operator=(const GameKilledSomeone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameKilledSomeone(GameKilledSomeone&& from) noexcept
    : GameKilledSomeone() {
    *this = ::std::move(from);
  }

  inline GameKilledSomeone& operator=(GameKilledSomeone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameKilledSomeone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameKilledSomeone* internal_default_instance() {
    return reinterpret_cast<const GameKilledSomeone*>(
               &_GameKilledSomeone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(GameKilledSomeone* other);
  friend void swap(GameKilledSomeone& a, GameKilledSomeone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameKilledSomeone* New() const final {
    return CreateMaybeMessage<GameKilledSomeone>(NULL);
  }

  GameKilledSomeone* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameKilledSomeone>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameKilledSomeone& from);
  void MergeFrom(const GameKilledSomeone& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameKilledSomeone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  void clear_meansofdeath();
  static const int kMeansOfDeathFieldNumber = 4;
  const ::std::string& meansofdeath() const;
  void set_meansofdeath(const ::std::string& value);
  #if LANG_CXX11
  void set_meansofdeath(::std::string&& value);
  #endif
  void set_meansofdeath(const char* value);
  void set_meansofdeath(const char* value, size_t size);
  ::std::string* mutable_meansofdeath();
  ::std::string* release_meansofdeath();
  void set_allocated_meansofdeath(::std::string* meansofdeath);

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_victimteam();
  static const int kVictimTeamFieldNumber = 2;
  ::google::protobuf::int32 victimteam() const;
  void set_victimteam(::google::protobuf::int32 value);

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  static const int kAttackTeamFieldNumber = 3;
  ::google::protobuf::int32 attackteam() const;
  void set_attackteam(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameKilledSomeone)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr meansofdeath_;
  ::Analytics::Vec3* position_;
  ::google::protobuf::int32 victimteam_;
  ::google::protobuf::int32 attackteam_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameRecieveDamage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameRecieveDamage) */ {
 public:
  GameRecieveDamage();
  virtual ~GameRecieveDamage();

  GameRecieveDamage(const GameRecieveDamage& from);

  inline GameRecieveDamage& operator=(const GameRecieveDamage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameRecieveDamage(GameRecieveDamage&& from) noexcept
    : GameRecieveDamage() {
    *this = ::std::move(from);
  }

  inline GameRecieveDamage& operator=(GameRecieveDamage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameRecieveDamage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameRecieveDamage* internal_default_instance() {
    return reinterpret_cast<const GameRecieveDamage*>(
               &_GameRecieveDamage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(GameRecieveDamage* other);
  friend void swap(GameRecieveDamage& a, GameRecieveDamage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameRecieveDamage* New() const final {
    return CreateMaybeMessage<GameRecieveDamage>(NULL);
  }

  GameRecieveDamage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameRecieveDamage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameRecieveDamage& from);
  void MergeFrom(const GameRecieveDamage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRecieveDamage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string damageType = 5 [(.Analytics.track_event) = true];
  void clear_damagetype();
  static const int kDamageTypeFieldNumber = 5;
  const ::std::string& damagetype() const;
  void set_damagetype(const ::std::string& value);
  #if LANG_CXX11
  void set_damagetype(::std::string&& value);
  #endif
  void set_damagetype(const char* value);
  void set_damagetype(const char* value, size_t size);
  ::std::string* mutable_damagetype();
  ::std::string* release_damagetype();
  void set_allocated_damagetype(::std::string* damagetype);

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_victimteam();
  static const int kVictimTeamFieldNumber = 2;
  ::google::protobuf::int32 victimteam() const;
  void set_victimteam(::google::protobuf::int32 value);

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  static const int kAttackTeamFieldNumber = 3;
  ::google::protobuf::int32 attackteam() const;
  void set_attackteam(::google::protobuf::int32 value);

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  void clear_weaponid();
  static const int kWeaponIdFieldNumber = 4;
  ::google::protobuf::int32 weaponid() const;
  void set_weaponid(::google::protobuf::int32 value);

  // float damageAmount = 6;
  void clear_damageamount();
  static const int kDamageAmountFieldNumber = 6;
  float damageamount() const;
  void set_damageamount(float value);

  // @@protoc_insertion_point(class_scope:Analytics.GameRecieveDamage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr damagetype_;
  ::Analytics::Vec3* position_;
  ::google::protobuf::int32 victimteam_;
  ::google::protobuf::int32 attackteam_;
  ::google::protobuf::int32 weaponid_;
  float damageamount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameInflictDamage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameInflictDamage) */ {
 public:
  GameInflictDamage();
  virtual ~GameInflictDamage();

  GameInflictDamage(const GameInflictDamage& from);

  inline GameInflictDamage& operator=(const GameInflictDamage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameInflictDamage(GameInflictDamage&& from) noexcept
    : GameInflictDamage() {
    *this = ::std::move(from);
  }

  inline GameInflictDamage& operator=(GameInflictDamage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameInflictDamage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInflictDamage* internal_default_instance() {
    return reinterpret_cast<const GameInflictDamage*>(
               &_GameInflictDamage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(GameInflictDamage* other);
  friend void swap(GameInflictDamage& a, GameInflictDamage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameInflictDamage* New() const final {
    return CreateMaybeMessage<GameInflictDamage>(NULL);
  }

  GameInflictDamage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameInflictDamage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameInflictDamage& from);
  void MergeFrom(const GameInflictDamage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInflictDamage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string damageType = 5 [(.Analytics.track_event) = true];
  void clear_damagetype();
  static const int kDamageTypeFieldNumber = 5;
  const ::std::string& damagetype() const;
  void set_damagetype(const ::std::string& value);
  #if LANG_CXX11
  void set_damagetype(::std::string&& value);
  #endif
  void set_damagetype(const char* value);
  void set_damagetype(const char* value, size_t size);
  ::std::string* mutable_damagetype();
  ::std::string* release_damagetype();
  void set_allocated_damagetype(::std::string* damagetype);

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_victimteam();
  static const int kVictimTeamFieldNumber = 2;
  ::google::protobuf::int32 victimteam() const;
  void set_victimteam(::google::protobuf::int32 value);

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  static const int kAttackTeamFieldNumber = 3;
  ::google::protobuf::int32 attackteam() const;
  void set_attackteam(::google::protobuf::int32 value);

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  void clear_weaponid();
  static const int kWeaponIdFieldNumber = 4;
  ::google::protobuf::int32 weaponid() const;
  void set_weaponid(::google::protobuf::int32 value);

  // float damageAmount = 6;
  void clear_damageamount();
  static const int kDamageAmountFieldNumber = 6;
  float damageamount() const;
  void set_damageamount(float value);

  // @@protoc_insertion_point(class_scope:Analytics.GameInflictDamage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr damagetype_;
  ::Analytics::Vec3* position_;
  ::google::protobuf::int32 victimteam_;
  ::google::protobuf::int32 attackteam_;
  ::google::protobuf::int32 weaponid_;
  float damageamount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameRadiusDamage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameRadiusDamage) */ {
 public:
  GameRadiusDamage();
  virtual ~GameRadiusDamage();

  GameRadiusDamage(const GameRadiusDamage& from);

  inline GameRadiusDamage& operator=(const GameRadiusDamage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameRadiusDamage(GameRadiusDamage&& from) noexcept
    : GameRadiusDamage() {
    *this = ::std::move(from);
  }

  inline GameRadiusDamage& operator=(GameRadiusDamage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameRadiusDamage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameRadiusDamage* internal_default_instance() {
    return reinterpret_cast<const GameRadiusDamage*>(
               &_GameRadiusDamage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(GameRadiusDamage* other);
  friend void swap(GameRadiusDamage& a, GameRadiusDamage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameRadiusDamage* New() const final {
    return CreateMaybeMessage<GameRadiusDamage>(NULL);
  }

  GameRadiusDamage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameRadiusDamage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameRadiusDamage& from);
  void MergeFrom(const GameRadiusDamage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRadiusDamage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string damageType = 2;
  void clear_damagetype();
  static const int kDamageTypeFieldNumber = 2;
  const ::std::string& damagetype() const;
  void set_damagetype(const ::std::string& value);
  #if LANG_CXX11
  void set_damagetype(::std::string&& value);
  #endif
  void set_damagetype(const char* value);
  void set_damagetype(const char* value, size_t size);
  ::std::string* mutable_damagetype();
  ::std::string* release_damagetype();
  void set_allocated_damagetype(::std::string* damagetype);

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // float damageAmount = 3;
  void clear_damageamount();
  static const int kDamageAmountFieldNumber = 3;
  float damageamount() const;
  void set_damageamount(float value);

  // float damageRadius = 4;
  void clear_damageradius();
  static const int kDamageRadiusFieldNumber = 4;
  float damageradius() const;
  void set_damageradius(float value);

  // @@protoc_insertion_point(class_scope:Analytics.GameRadiusDamage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr damagetype_;
  ::Analytics::Vec3* position_;
  float damageamount_;
  float damageradius_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameNavigationStuck : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameNavigationStuck) */ {
 public:
  GameNavigationStuck();
  virtual ~GameNavigationStuck();

  GameNavigationStuck(const GameNavigationStuck& from);

  inline GameNavigationStuck& operator=(const GameNavigationStuck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameNavigationStuck(GameNavigationStuck&& from) noexcept
    : GameNavigationStuck() {
    *this = ::std::move(from);
  }

  inline GameNavigationStuck& operator=(GameNavigationStuck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameNavigationStuck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameNavigationStuck* internal_default_instance() {
    return reinterpret_cast<const GameNavigationStuck*>(
               &_GameNavigationStuck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(GameNavigationStuck* other);
  friend void swap(GameNavigationStuck& a, GameNavigationStuck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameNavigationStuck* New() const final {
    return CreateMaybeMessage<GameNavigationStuck>(NULL);
  }

  GameNavigationStuck* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameNavigationStuck>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameNavigationStuck& from);
  void MergeFrom(const GameNavigationStuck& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameNavigationStuck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Analytics.Vec3 position = 2 [(.Analytics.point_event) = {
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // int32 entityId = 1;
  void clear_entityid();
  static const int kEntityIdFieldNumber = 1;
  ::google::protobuf::int32 entityid() const;
  void set_entityid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameNavigationStuck)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* position_;
  ::google::protobuf::int32 entityid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameVoiceMacro : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameVoiceMacro) */ {
 public:
  GameVoiceMacro();
  virtual ~GameVoiceMacro();

  GameVoiceMacro(const GameVoiceMacro& from);

  inline GameVoiceMacro& operator=(const GameVoiceMacro& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameVoiceMacro(GameVoiceMacro&& from) noexcept
    : GameVoiceMacro() {
    *this = ::std::move(from);
  }

  inline GameVoiceMacro& operator=(GameVoiceMacro&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameVoiceMacro& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameVoiceMacro* internal_default_instance() {
    return reinterpret_cast<const GameVoiceMacro*>(
               &_GameVoiceMacro_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(GameVoiceMacro* other);
  friend void swap(GameVoiceMacro& a, GameVoiceMacro& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameVoiceMacro* New() const final {
    return CreateMaybeMessage<GameVoiceMacro>(NULL);
  }

  GameVoiceMacro* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameVoiceMacro>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameVoiceMacro& from);
  void MergeFrom(const GameVoiceMacro& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameVoiceMacro* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Analytics.Vec3 position = 3 [(.Analytics.point_event) = {
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);

  // int32 entityId = 1;
  void clear_entityid();
  static const int kEntityIdFieldNumber = 1;
  ::google::protobuf::int32 entityid() const;
  void set_entityid(::google::protobuf::int32 value);

  // int32 voiceMacro = 2 [(.Analytics.enumkey) = "VOICE_MACRO", (.Analytics.track_event) = true];
  void clear_voicemacro();
  static const int kVoiceMacroFieldNumber = 2;
  ::google::protobuf::int32 voicemacro() const;
  void set_voicemacro(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Analytics.GameVoiceMacro)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* position_;
  ::google::protobuf::int32 entityid_;
  ::google::protobuf::int32 voicemacro_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameLogMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Analytics.GameLogMessage) */ {
 public:
  GameLogMessage();
  virtual ~GameLogMessage();

  GameLogMessage(const GameLogMessage& from);

  inline GameLogMessage& operator=(const GameLogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameLogMessage(GameLogMessage&& from) noexcept
    : GameLogMessage() {
    *this = ::std::move(from);
  }

  inline GameLogMessage& operator=(GameLogMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GameLogMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameLogMessage* internal_default_instance() {
    return reinterpret_cast<const GameLogMessage*>(
               &_GameLogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(GameLogMessage* other);
  friend void swap(GameLogMessage& a, GameLogMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameLogMessage* New() const final {
    return CreateMaybeMessage<GameLogMessage>(NULL);
  }

  GameLogMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameLogMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameLogMessage& from);
  void MergeFrom(const GameLogMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameLogMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string logMessage = 2;
  void clear_logmessage();
  static const int kLogMessageFieldNumber = 2;
  const ::std::string& logmessage() const;
  void set_logmessage(const ::std::string& value);
  #if LANG_CXX11
  void set_logmessage(::std::string&& value);
  #endif
  void set_logmessage(const char* value);
  void set_logmessage(const char* value, size_t size);
  ::std::string* mutable_logmessage();
  ::std::string* release_logmessage();
  void set_allocated_logmessage(::std::string* logmessage);

  // string logExtraInfo = 3;
  void clear_logextrainfo();
  static const int kLogExtraInfoFieldNumber = 3;
  const ::std::string& logextrainfo() const;
  void set_logextrainfo(const ::std::string& value);
  #if LANG_CXX11
  void set_logextrainfo(::std::string&& value);
  #endif
  void set_logextrainfo(const char* value);
  void set_logextrainfo(const char* value, size_t size);
  ::std::string* mutable_logextrainfo();
  ::std::string* release_logextrainfo();
  void set_allocated_logextrainfo(::std::string* logextrainfo);

  // .Analytics.LogType logType = 1;
  void clear_logtype();
  static const int kLogTypeFieldNumber = 1;
  ::Analytics::LogType logtype() const;
  void set_logtype(::Analytics::LogType value);

  // @@protoc_insertion_point(class_scope:Analytics.GameLogMessage)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr logmessage_;
  ::google::protobuf::internal::ArenaStringPtr logextrainfo_;
  int logtype_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// ===================================================================

static const int kRediskeytypeFieldNumber = 5000;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::EnumTypeTraits< ::Analytics::RedisKeyType, ::Analytics::RedisKeyType_IsValid>, 14, false >
  rediskeytype;
static const int kRedishmsetkeyFieldNumber = 5001;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  redishmsetkey;
static const int kRediskeysuffixFieldNumber = 5002;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  rediskeysuffix;
static const int kUseJsonEncodingFieldNumber = 5003;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  useJsonEncoding;
static const int kObjectnameFieldNumber = 5005;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  objectname;
static const int kEnumkeyFieldNumber = 4001;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::StringTypeTraits, 9, false >
  enumkey;
static const int kEditableFieldNumber = 4002;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  editable;
static const int kExpiresFieldNumber = 4003;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< ::google::protobuf::int32 >, 5, false >
  expires;
static const int kEnumflagsFieldNumber = 4004;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  enumflags;
static const int kTooltipFieldNumber = 4005;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  tooltip;
static const int kHiddenFieldNumber = 4006;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  hidden;
static const int kEnumflagsindexedFieldNumber = 4007;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  enumflagsindexed;
static const int kEditableKeyFieldNumber = 4008;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  editable_key;
static const int kTrackEventFieldNumber = 4009;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::PrimitiveTypeTraits< bool >, 8, false >
  track_event;
static const int kPointEventFieldNumber = 4012;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::Analytics::PointEvent >, 11, false >
  point_event;
static const int kLineEventFieldNumber = 4013;
extern ::google::protobuf::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::google::protobuf::internal::MessageTypeTraits< ::Analytics::LineEvent >, 11, false >
  line_event;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PointEvent

// string radius = 1;
inline void PointEvent::clear_radius() {
  radius_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PointEvent::radius() const {
  // @@protoc_insertion_point(field_get:Analytics.PointEvent.radius)
  return radius_.GetNoArena();
}
inline void PointEvent::set_radius(const ::std::string& value) {
  
  radius_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.PointEvent.radius)
}
#if LANG_CXX11
inline void PointEvent::set_radius(::std::string&& value) {
  
  radius_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.PointEvent.radius)
}
#endif
inline void PointEvent::set_radius(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  radius_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.PointEvent.radius)
}
inline void PointEvent::set_radius(const char* value, size_t size) {
  
  radius_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.PointEvent.radius)
}
inline ::std::string* PointEvent::mutable_radius() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.PointEvent.radius)
  return radius_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PointEvent::release_radius() {
  // @@protoc_insertion_point(field_release:Analytics.PointEvent.radius)
  
  return radius_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PointEvent::set_allocated_radius(::std::string* radius) {
  if (radius != NULL) {
    
  } else {
    
  }
  radius_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), radius);
  // @@protoc_insertion_point(field_set_allocated:Analytics.PointEvent.radius)
}

// string weight = 2;
inline void PointEvent::clear_weight() {
  weight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PointEvent::weight() const {
  // @@protoc_insertion_point(field_get:Analytics.PointEvent.weight)
  return weight_.GetNoArena();
}
inline void PointEvent::set_weight(const ::std::string& value) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.PointEvent.weight)
}
#if LANG_CXX11
inline void PointEvent::set_weight(::std::string&& value) {
  
  weight_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.PointEvent.weight)
}
#endif
inline void PointEvent::set_weight(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.PointEvent.weight)
}
inline void PointEvent::set_weight(const char* value, size_t size) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.PointEvent.weight)
}
inline ::std::string* PointEvent::mutable_weight() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.PointEvent.weight)
  return weight_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PointEvent::release_weight() {
  // @@protoc_insertion_point(field_release:Analytics.PointEvent.weight)
  
  return weight_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PointEvent::set_allocated_weight(::std::string* weight) {
  if (weight != NULL) {
    
  } else {
    
  }
  weight_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), weight);
  // @@protoc_insertion_point(field_set_allocated:Analytics.PointEvent.weight)
}

// -------------------------------------------------------------------

// LineEvent

// string radius = 1;
inline void LineEvent::clear_radius() {
  radius_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LineEvent::radius() const {
  // @@protoc_insertion_point(field_get:Analytics.LineEvent.radius)
  return radius_.GetNoArena();
}
inline void LineEvent::set_radius(const ::std::string& value) {
  
  radius_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.LineEvent.radius)
}
#if LANG_CXX11
inline void LineEvent::set_radius(::std::string&& value) {
  
  radius_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.LineEvent.radius)
}
#endif
inline void LineEvent::set_radius(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  radius_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.LineEvent.radius)
}
inline void LineEvent::set_radius(const char* value, size_t size) {
  
  radius_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.LineEvent.radius)
}
inline ::std::string* LineEvent::mutable_radius() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.LineEvent.radius)
  return radius_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LineEvent::release_radius() {
  // @@protoc_insertion_point(field_release:Analytics.LineEvent.radius)
  
  return radius_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LineEvent::set_allocated_radius(::std::string* radius) {
  if (radius != NULL) {
    
  } else {
    
  }
  radius_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), radius);
  // @@protoc_insertion_point(field_set_allocated:Analytics.LineEvent.radius)
}

// string weight = 2;
inline void LineEvent::clear_weight() {
  weight_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LineEvent::weight() const {
  // @@protoc_insertion_point(field_get:Analytics.LineEvent.weight)
  return weight_.GetNoArena();
}
inline void LineEvent::set_weight(const ::std::string& value) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.LineEvent.weight)
}
#if LANG_CXX11
inline void LineEvent::set_weight(::std::string&& value) {
  
  weight_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.LineEvent.weight)
}
#endif
inline void LineEvent::set_weight(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.LineEvent.weight)
}
inline void LineEvent::set_weight(const char* value, size_t size) {
  
  weight_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.LineEvent.weight)
}
inline ::std::string* LineEvent::mutable_weight() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.LineEvent.weight)
  return weight_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LineEvent::release_weight() {
  // @@protoc_insertion_point(field_release:Analytics.LineEvent.weight)
  
  return weight_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LineEvent::set_allocated_weight(::std::string* weight) {
  if (weight != NULL) {
    
  } else {
    
  }
  weight_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), weight);
  // @@protoc_insertion_point(field_set_allocated:Analytics.LineEvent.weight)
}

// -------------------------------------------------------------------

// EditorChangeValue

// string messageType = 1;
inline void EditorChangeValue::clear_messagetype() {
  messagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EditorChangeValue::messagetype() const {
  // @@protoc_insertion_point(field_get:Analytics.EditorChangeValue.messageType)
  return messagetype_.GetNoArena();
}
inline void EditorChangeValue::set_messagetype(const ::std::string& value) {
  
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.EditorChangeValue.messageType)
}
#if LANG_CXX11
inline void EditorChangeValue::set_messagetype(::std::string&& value) {
  
  messagetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.EditorChangeValue.messageType)
}
#endif
inline void EditorChangeValue::set_messagetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.EditorChangeValue.messageType)
}
inline void EditorChangeValue::set_messagetype(const char* value, size_t size) {
  
  messagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.EditorChangeValue.messageType)
}
inline ::std::string* EditorChangeValue::mutable_messagetype() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.EditorChangeValue.messageType)
  return messagetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EditorChangeValue::release_messagetype() {
  // @@protoc_insertion_point(field_release:Analytics.EditorChangeValue.messageType)
  
  return messagetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EditorChangeValue::set_allocated_messagetype(::std::string* messagetype) {
  if (messagetype != NULL) {
    
  } else {
    
  }
  messagetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), messagetype);
  // @@protoc_insertion_point(field_set_allocated:Analytics.EditorChangeValue.messageType)
}

// string fieldName = 2;
inline void EditorChangeValue::clear_fieldname() {
  fieldname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EditorChangeValue::fieldname() const {
  // @@protoc_insertion_point(field_get:Analytics.EditorChangeValue.fieldName)
  return fieldname_.GetNoArena();
}
inline void EditorChangeValue::set_fieldname(const ::std::string& value) {
  
  fieldname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.EditorChangeValue.fieldName)
}
#if LANG_CXX11
inline void EditorChangeValue::set_fieldname(::std::string&& value) {
  
  fieldname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.EditorChangeValue.fieldName)
}
#endif
inline void EditorChangeValue::set_fieldname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fieldname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.EditorChangeValue.fieldName)
}
inline void EditorChangeValue::set_fieldname(const char* value, size_t size) {
  
  fieldname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.EditorChangeValue.fieldName)
}
inline ::std::string* EditorChangeValue::mutable_fieldname() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.EditorChangeValue.fieldName)
  return fieldname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EditorChangeValue::release_fieldname() {
  // @@protoc_insertion_point(field_release:Analytics.EditorChangeValue.fieldName)
  
  return fieldname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EditorChangeValue::set_allocated_fieldname(::std::string* fieldname) {
  if (fieldname != NULL) {
    
  } else {
    
  }
  fieldname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fieldname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.EditorChangeValue.fieldName)
}

// string payload = 3;
inline void EditorChangeValue::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EditorChangeValue::payload() const {
  // @@protoc_insertion_point(field_get:Analytics.EditorChangeValue.payload)
  return payload_.GetNoArena();
}
inline void EditorChangeValue::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.EditorChangeValue.payload)
}
#if LANG_CXX11
inline void EditorChangeValue::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.EditorChangeValue.payload)
}
#endif
inline void EditorChangeValue::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.EditorChangeValue.payload)
}
inline void EditorChangeValue::set_payload(const char* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.EditorChangeValue.payload)
}
inline ::std::string* EditorChangeValue::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.EditorChangeValue.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EditorChangeValue::release_payload() {
  // @@protoc_insertion_point(field_release:Analytics.EditorChangeValue.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EditorChangeValue::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:Analytics.EditorChangeValue.payload)
}

// -------------------------------------------------------------------

// EditorChanges

// repeated .Analytics.EditorChangeValue changes = 1;
inline int EditorChanges::changes_size() const {
  return changes_.size();
}
inline void EditorChanges::clear_changes() {
  changes_.Clear();
}
inline ::Analytics::EditorChangeValue* EditorChanges::mutable_changes(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.EditorChanges.changes)
  return changes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::EditorChangeValue >*
EditorChanges::mutable_changes() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.EditorChanges.changes)
  return &changes_;
}
inline const ::Analytics::EditorChangeValue& EditorChanges::changes(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.EditorChanges.changes)
  return changes_.Get(index);
}
inline ::Analytics::EditorChangeValue* EditorChanges::add_changes() {
  // @@protoc_insertion_point(field_add:Analytics.EditorChanges.changes)
  return changes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::EditorChangeValue >&
EditorChanges::changes() const {
  // @@protoc_insertion_point(field_list:Analytics.EditorChanges.changes)
  return changes_;
}

// -------------------------------------------------------------------

// RangeF

// float min = 1;
inline void RangeF::clear_min() {
  min_ = 0;
}
inline float RangeF::min() const {
  // @@protoc_insertion_point(field_get:Analytics.RangeF.min)
  return min_;
}
inline void RangeF::set_min(float value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:Analytics.RangeF.min)
}

// float max = 2;
inline void RangeF::clear_max() {
  max_ = 0;
}
inline float RangeF::max() const {
  // @@protoc_insertion_point(field_get:Analytics.RangeF.max)
  return max_;
}
inline void RangeF::set_max(float value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:Analytics.RangeF.max)
}

// -------------------------------------------------------------------

// RangeI

// int32 min = 1;
inline void RangeI::clear_min() {
  min_ = 0;
}
inline ::google::protobuf::int32 RangeI::min() const {
  // @@protoc_insertion_point(field_get:Analytics.RangeI.min)
  return min_;
}
inline void RangeI::set_min(::google::protobuf::int32 value) {
  
  min_ = value;
  // @@protoc_insertion_point(field_set:Analytics.RangeI.min)
}

// int32 max = 2;
inline void RangeI::clear_max() {
  max_ = 0;
}
inline ::google::protobuf::int32 RangeI::max() const {
  // @@protoc_insertion_point(field_get:Analytics.RangeI.max)
  return max_;
}
inline void RangeI::set_max(::google::protobuf::int32 value) {
  
  max_ = value;
  // @@protoc_insertion_point(field_set:Analytics.RangeI.max)
}

// -------------------------------------------------------------------

// Vec3

// float x = 1;
inline void Vec3::clear_x() {
  x_ = 0;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3.x)
  return x_;
}
inline void Vec3::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec3.x)
}

// float y = 2;
inline void Vec3::clear_y() {
  y_ = 0;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3.y)
  return y_;
}
inline void Vec3::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec3.y)
}

// float z = 3;
inline void Vec3::clear_z() {
  z_ = 0;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3.z)
  return z_;
}
inline void Vec3::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec3.z)
}

// -------------------------------------------------------------------

// Vec3Color

// float x = 1;
inline void Vec3Color::clear_x() {
  x_ = 0;
}
inline float Vec3Color::x() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3Color.x)
  return x_;
}
inline void Vec3Color::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec3Color.x)
}

// float y = 2;
inline void Vec3Color::clear_y() {
  y_ = 0;
}
inline float Vec3Color::y() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3Color.y)
  return y_;
}
inline void Vec3Color::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec3Color.y)
}

// float z = 3;
inline void Vec3Color::clear_z() {
  z_ = 0;
}
inline float Vec3Color::z() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3Color.z)
  return z_;
}
inline void Vec3Color::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec3Color.z)
}

// uint32 color = 4;
inline void Vec3Color::clear_color() {
  color_ = 0u;
}
inline ::google::protobuf::uint32 Vec3Color::color() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3Color.color)
  return color_;
}
inline void Vec3Color::set_color(::google::protobuf::uint32 value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec3Color.color)
}

// -------------------------------------------------------------------

// Vec4

// float x = 1;
inline void Vec4::clear_x() {
  x_ = 0;
}
inline float Vec4::x() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec4.x)
  return x_;
}
inline void Vec4::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec4.x)
}

// float y = 2;
inline void Vec4::clear_y() {
  y_ = 0;
}
inline float Vec4::y() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec4.y)
  return y_;
}
inline void Vec4::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec4.y)
}

// float z = 3;
inline void Vec4::clear_z() {
  z_ = 0;
}
inline float Vec4::z() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec4.z)
  return z_;
}
inline void Vec4::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec4.z)
}

// float w = 4;
inline void Vec4::clear_w() {
  w_ = 0;
}
inline float Vec4::w() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec4.w)
  return w_;
}
inline void Vec4::set_w(float value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Vec4.w)
}

// -------------------------------------------------------------------

// Line

// .Analytics.Vec3 p0 = 1;
inline bool Line::has_p0() const {
  return this != internal_default_instance() && p0_ != NULL;
}
inline void Line::clear_p0() {
  if (GetArenaNoVirtual() == NULL && p0_ != NULL) {
    delete p0_;
  }
  p0_ = NULL;
}
inline const ::Analytics::Vec3& Line::p0() const {
  const ::Analytics::Vec3* p = p0_;
  // @@protoc_insertion_point(field_get:Analytics.Line.p0)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* Line::release_p0() {
  // @@protoc_insertion_point(field_release:Analytics.Line.p0)
  
  ::Analytics::Vec3* temp = p0_;
  p0_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* Line::mutable_p0() {
  
  if (p0_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    p0_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.Line.p0)
  return p0_;
}
inline void Line::set_allocated_p0(::Analytics::Vec3* p0) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete p0_;
  }
  if (p0) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      p0 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, p0, submessage_arena);
    }
    
  } else {
    
  }
  p0_ = p0;
  // @@protoc_insertion_point(field_set_allocated:Analytics.Line.p0)
}

// .Analytics.Vec3 p1 = 2;
inline bool Line::has_p1() const {
  return this != internal_default_instance() && p1_ != NULL;
}
inline void Line::clear_p1() {
  if (GetArenaNoVirtual() == NULL && p1_ != NULL) {
    delete p1_;
  }
  p1_ = NULL;
}
inline const ::Analytics::Vec3& Line::p1() const {
  const ::Analytics::Vec3* p = p1_;
  // @@protoc_insertion_point(field_get:Analytics.Line.p1)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* Line::release_p1() {
  // @@protoc_insertion_point(field_release:Analytics.Line.p1)
  
  ::Analytics::Vec3* temp = p1_;
  p1_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* Line::mutable_p1() {
  
  if (p1_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    p1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.Line.p1)
  return p1_;
}
inline void Line::set_allocated_p1(::Analytics::Vec3* p1) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete p1_;
  }
  if (p1) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      p1 = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, p1, submessage_arena);
    }
    
  } else {
    
  }
  p1_ = p1;
  // @@protoc_insertion_point(field_set_allocated:Analytics.Line.p1)
}

// -------------------------------------------------------------------

// Euler

// float heading = 1;
inline void Euler::clear_heading() {
  heading_ = 0;
}
inline float Euler::heading() const {
  // @@protoc_insertion_point(field_get:Analytics.Euler.heading)
  return heading_;
}
inline void Euler::set_heading(float value) {
  
  heading_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Euler.heading)
}

// float pitch = 2;
inline void Euler::clear_pitch() {
  pitch_ = 0;
}
inline float Euler::pitch() const {
  // @@protoc_insertion_point(field_get:Analytics.Euler.pitch)
  return pitch_;
}
inline void Euler::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Euler.pitch)
}

// float roll = 3;
inline void Euler::clear_roll() {
  roll_ = 0;
}
inline float Euler::roll() const {
  // @@protoc_insertion_point(field_get:Analytics.Euler.roll)
  return roll_;
}
inline void Euler::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Euler.roll)
}

// -------------------------------------------------------------------

// Material

// string name = 1;
inline void Material::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Material::name() const {
  // @@protoc_insertion_point(field_get:Analytics.Material.name)
  return name_.GetNoArena();
}
inline void Material::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.Material.name)
}
#if LANG_CXX11
inline void Material::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.Material.name)
}
#endif
inline void Material::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.Material.name)
}
inline void Material::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.Material.name)
}
inline ::std::string* Material::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.Material.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Material::release_name() {
  // @@protoc_insertion_point(field_release:Analytics.Material.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Material::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Analytics.Material.name)
}

// uint32 contents = 2 [(.Analytics.enumkey) = "CONTENT_FLAGS", (.Analytics.enumflags) = true];
inline void Material::clear_contents() {
  contents_ = 0u;
}
inline ::google::protobuf::uint32 Material::contents() const {
  // @@protoc_insertion_point(field_get:Analytics.Material.contents)
  return contents_;
}
inline void Material::set_contents(::google::protobuf::uint32 value) {
  
  contents_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Material.contents)
}

// uint32 surfaceFlags = 3 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.enumflags) = true];
inline void Material::clear_surfaceflags() {
  surfaceflags_ = 0u;
}
inline ::google::protobuf::uint32 Material::surfaceflags() const {
  // @@protoc_insertion_point(field_get:Analytics.Material.surfaceFlags)
  return surfaceflags_;
}
inline void Material::set_surfaceflags(::google::protobuf::uint32 value) {
  
  surfaceflags_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Material.surfaceFlags)
}

// bool renderEvents = 4;
inline void Material::clear_renderevents() {
  renderevents_ = false;
}
inline bool Material::renderevents() const {
  // @@protoc_insertion_point(field_get:Analytics.Material.renderEvents)
  return renderevents_;
}
inline void Material::set_renderevents(bool value) {
  
  renderevents_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Material.renderEvents)
}

// -------------------------------------------------------------------

// PrimitiveOptions

// uint32 partIndex = 1 [(.Analytics.editable_key) = true];
inline void PrimitiveOptions::clear_partindex() {
  partindex_ = 0u;
}
inline ::google::protobuf::uint32 PrimitiveOptions::partindex() const {
  // @@protoc_insertion_point(field_get:Analytics.PrimitiveOptions.partIndex)
  return partindex_;
}
inline void PrimitiveOptions::set_partindex(::google::protobuf::uint32 value) {
  
  partindex_ = value;
  // @@protoc_insertion_point(field_set:Analytics.PrimitiveOptions.partIndex)
}

// uint32 overrideSurfaceFlags = 2 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.editable) = true, (.Analytics.enumflags) = true];
inline void PrimitiveOptions::clear_overridesurfaceflags() {
  overridesurfaceflags_ = 0u;
}
inline ::google::protobuf::uint32 PrimitiveOptions::overridesurfaceflags() const {
  // @@protoc_insertion_point(field_get:Analytics.PrimitiveOptions.overrideSurfaceFlags)
  return overridesurfaceflags_;
}
inline void PrimitiveOptions::set_overridesurfaceflags(::google::protobuf::uint32 value) {
  
  overridesurfaceflags_ = value;
  // @@protoc_insertion_point(field_set:Analytics.PrimitiveOptions.overrideSurfaceFlags)
}

// -------------------------------------------------------------------

// Primitive

// .Analytics.PrimitiveType type = 1;
inline void Primitive::clear_type() {
  type_ = 0;
}
inline ::Analytics::PrimitiveType Primitive::type() const {
  // @@protoc_insertion_point(field_get:Analytics.Primitive.type)
  return static_cast< ::Analytics::PrimitiveType >(type_);
}
inline void Primitive::set_type(::Analytics::PrimitiveType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Primitive.type)
}

// uint32 materialIndex = 2;
inline void Primitive::clear_materialindex() {
  materialindex_ = 0u;
}
inline ::google::protobuf::uint32 Primitive::materialindex() const {
  // @@protoc_insertion_point(field_get:Analytics.Primitive.materialIndex)
  return materialindex_;
}
inline void Primitive::set_materialindex(::google::protobuf::uint32 value) {
  
  materialindex_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Primitive.materialIndex)
}

// .Analytics.PrimitiveOptions options = 3;
inline bool Primitive::has_options() const {
  return this != internal_default_instance() && options_ != NULL;
}
inline void Primitive::clear_options() {
  if (GetArenaNoVirtual() == NULL && options_ != NULL) {
    delete options_;
  }
  options_ = NULL;
}
inline const ::Analytics::PrimitiveOptions& Primitive::options() const {
  const ::Analytics::PrimitiveOptions* p = options_;
  // @@protoc_insertion_point(field_get:Analytics.Primitive.options)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::PrimitiveOptions*>(
      &::Analytics::_PrimitiveOptions_default_instance_);
}
inline ::Analytics::PrimitiveOptions* Primitive::release_options() {
  // @@protoc_insertion_point(field_release:Analytics.Primitive.options)
  
  ::Analytics::PrimitiveOptions* temp = options_;
  options_ = NULL;
  return temp;
}
inline ::Analytics::PrimitiveOptions* Primitive::mutable_options() {
  
  if (options_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::PrimitiveOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.Primitive.options)
  return options_;
}
inline void Primitive::set_allocated_options(::Analytics::PrimitiveOptions* options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete options_;
  }
  if (options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:Analytics.Primitive.options)
}

// float size = 4;
inline void Primitive::clear_size() {
  size_ = 0;
}
inline float Primitive::size() const {
  // @@protoc_insertion_point(field_get:Analytics.Primitive.size)
  return size_;
}
inline void Primitive::set_size(float value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:Analytics.Primitive.size)
}

// repeated .Analytics.Vec3Color vertices = 5;
inline int Primitive::vertices_size() const {
  return vertices_.size();
}
inline void Primitive::clear_vertices() {
  vertices_.Clear();
}
inline ::Analytics::Vec3Color* Primitive::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.Primitive.vertices)
  return vertices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::Vec3Color >*
Primitive::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.Primitive.vertices)
  return &vertices_;
}
inline const ::Analytics::Vec3Color& Primitive::vertices(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.Primitive.vertices)
  return vertices_.Get(index);
}
inline ::Analytics::Vec3Color* Primitive::add_vertices() {
  // @@protoc_insertion_point(field_add:Analytics.Primitive.vertices)
  return vertices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::Vec3Color >&
Primitive::vertices() const {
  // @@protoc_insertion_point(field_list:Analytics.Primitive.vertices)
  return vertices_;
}

// -------------------------------------------------------------------

// Mesh

// repeated .Analytics.Primitive primitives = 1;
inline int Mesh::primitives_size() const {
  return primitives_.size();
}
inline void Mesh::clear_primitives() {
  primitives_.Clear();
}
inline ::Analytics::Primitive* Mesh::mutable_primitives(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.Mesh.primitives)
  return primitives_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::Primitive >*
Mesh::mutable_primitives() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.Mesh.primitives)
  return &primitives_;
}
inline const ::Analytics::Primitive& Mesh::primitives(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.Mesh.primitives)
  return primitives_.Get(index);
}
inline ::Analytics::Primitive* Mesh::add_primitives() {
  // @@protoc_insertion_point(field_add:Analytics.Mesh.primitives)
  return primitives_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::Primitive >&
Mesh::primitives() const {
  // @@protoc_insertion_point(field_list:Analytics.Mesh.primitives)
  return primitives_;
}

// repeated .Analytics.Material materials = 2;
inline int Mesh::materials_size() const {
  return materials_.size();
}
inline void Mesh::clear_materials() {
  materials_.Clear();
}
inline ::Analytics::Material* Mesh::mutable_materials(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.Mesh.materials)
  return materials_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::Material >*
Mesh::mutable_materials() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.Mesh.materials)
  return &materials_;
}
inline const ::Analytics::Material& Mesh::materials(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.Mesh.materials)
  return materials_.Get(index);
}
inline ::Analytics::Material* Mesh::add_materials() {
  // @@protoc_insertion_point(field_add:Analytics.Mesh.materials)
  return materials_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::Material >&
Mesh::materials() const {
  // @@protoc_insertion_point(field_list:Analytics.Mesh.materials)
  return materials_;
}

// string name = 3;
inline void Mesh::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Mesh::name() const {
  // @@protoc_insertion_point(field_get:Analytics.Mesh.name)
  return name_.GetNoArena();
}
inline void Mesh::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.Mesh.name)
}
#if LANG_CXX11
inline void Mesh::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.Mesh.name)
}
#endif
inline void Mesh::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.Mesh.name)
}
inline void Mesh::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.Mesh.name)
}
inline ::std::string* Mesh::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.Mesh.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Mesh::release_name() {
  // @@protoc_insertion_point(field_release:Analytics.Mesh.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Analytics.Mesh.name)
}

// -------------------------------------------------------------------

// UTCTime

// int32 hour = 1;
inline void UTCTime::clear_hour() {
  hour_ = 0;
}
inline ::google::protobuf::int32 UTCTime::hour() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.hour)
  return hour_;
}
inline void UTCTime::set_hour(::google::protobuf::int32 value) {
  
  hour_ = value;
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.hour)
}

// int32 minute = 2;
inline void UTCTime::clear_minute() {
  minute_ = 0;
}
inline ::google::protobuf::int32 UTCTime::minute() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.minute)
  return minute_;
}
inline void UTCTime::set_minute(::google::protobuf::int32 value) {
  
  minute_ = value;
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.minute)
}

// int32 second = 3;
inline void UTCTime::clear_second() {
  second_ = 0;
}
inline ::google::protobuf::int32 UTCTime::second() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.second)
  return second_;
}
inline void UTCTime::set_second(::google::protobuf::int32 value) {
  
  second_ = value;
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.second)
}

// int32 day = 4;
inline void UTCTime::clear_day() {
  day_ = 0;
}
inline ::google::protobuf::int32 UTCTime::day() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.day)
  return day_;
}
inline void UTCTime::set_day(::google::protobuf::int32 value) {
  
  day_ = value;
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.day)
}

// int32 month = 5;
inline void UTCTime::clear_month() {
  month_ = 0;
}
inline ::google::protobuf::int32 UTCTime::month() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.month)
  return month_;
}
inline void UTCTime::set_month(::google::protobuf::int32 value) {
  
  month_ = value;
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.month)
}

// int32 year = 6;
inline void UTCTime::clear_year() {
  year_ = 0;
}
inline ::google::protobuf::int32 UTCTime::year() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.year)
  return year_;
}
inline void UTCTime::set_year(::google::protobuf::int32 value) {
  
  year_ = value;
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.year)
}

// -------------------------------------------------------------------

// GameInfo

// .Analytics.UTCTime timeStamp = 1;
inline bool GameInfo::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void GameInfo::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) {
    delete timestamp_;
  }
  timestamp_ = NULL;
}
inline const ::Analytics::UTCTime& GameInfo::timestamp() const {
  const ::Analytics::UTCTime* p = timestamp_;
  // @@protoc_insertion_point(field_get:Analytics.GameInfo.timeStamp)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::UTCTime*>(
      &::Analytics::_UTCTime_default_instance_);
}
inline ::Analytics::UTCTime* GameInfo::release_timestamp() {
  // @@protoc_insertion_point(field_release:Analytics.GameInfo.timeStamp)
  
  ::Analytics::UTCTime* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline ::Analytics::UTCTime* GameInfo::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::UTCTime>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameInfo.timeStamp)
  return timestamp_;
}
inline void GameInfo::set_allocated_timestamp(::Analytics::UTCTime* timestamp) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete timestamp_;
  }
  if (timestamp) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timestamp = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInfo.timeStamp)
}

// string mapName = 2;
inline void GameInfo::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInfo::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInfo.mapName)
  return mapname_.GetNoArena();
}
inline void GameInfo::set_mapname(const ::std::string& value) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameInfo.mapName)
}
#if LANG_CXX11
inline void GameInfo::set_mapname(::std::string&& value) {
  
  mapname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameInfo.mapName)
}
#endif
inline void GameInfo::set_mapname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameInfo.mapName)
}
inline void GameInfo::set_mapname(const char* value, size_t size) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameInfo.mapName)
}
inline ::std::string* GameInfo::mutable_mapname() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameInfo.mapName)
  return mapname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInfo::release_mapname() {
  // @@protoc_insertion_point(field_release:Analytics.GameInfo.mapName)
  
  return mapname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo::set_allocated_mapname(::std::string* mapname) {
  if (mapname != NULL) {
    
  } else {
    
  }
  mapname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInfo.mapName)
}

// string gameName = 3;
inline void GameInfo::clear_gamename() {
  gamename_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInfo::gamename() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInfo.gameName)
  return gamename_.GetNoArena();
}
inline void GameInfo::set_gamename(const ::std::string& value) {
  
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameInfo.gameName)
}
#if LANG_CXX11
inline void GameInfo::set_gamename(::std::string&& value) {
  
  gamename_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameInfo.gameName)
}
#endif
inline void GameInfo::set_gamename(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameInfo.gameName)
}
inline void GameInfo::set_gamename(const char* value, size_t size) {
  
  gamename_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameInfo.gameName)
}
inline ::std::string* GameInfo::mutable_gamename() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameInfo.gameName)
  return gamename_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInfo::release_gamename() {
  // @@protoc_insertion_point(field_release:Analytics.GameInfo.gameName)
  
  return gamename_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo::set_allocated_gamename(::std::string* gamename) {
  if (gamename != NULL) {
    
  } else {
    
  }
  gamename_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gamename);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInfo.gameName)
}

// string gameVersion = 4;
inline void GameInfo::clear_gameversion() {
  gameversion_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInfo::gameversion() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInfo.gameVersion)
  return gameversion_.GetNoArena();
}
inline void GameInfo::set_gameversion(const ::std::string& value) {
  
  gameversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameInfo.gameVersion)
}
#if LANG_CXX11
inline void GameInfo::set_gameversion(::std::string&& value) {
  
  gameversion_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameInfo.gameVersion)
}
#endif
inline void GameInfo::set_gameversion(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  gameversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameInfo.gameVersion)
}
inline void GameInfo::set_gameversion(const char* value, size_t size) {
  
  gameversion_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameInfo.gameVersion)
}
inline ::std::string* GameInfo::mutable_gameversion() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameInfo.gameVersion)
  return gameversion_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInfo::release_gameversion() {
  // @@protoc_insertion_point(field_release:Analytics.GameInfo.gameVersion)
  
  return gameversion_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo::set_allocated_gameversion(::std::string* gameversion) {
  if (gameversion != NULL) {
    
  } else {
    
  }
  gameversion_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gameversion);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInfo.gameVersion)
}

// -------------------------------------------------------------------

// GameEnum_EnumPair

// string name = 1;
inline void GameEnum_EnumPair::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameEnum_EnumPair::name() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.EnumPair.name)
  return name_.GetNoArena();
}
inline void GameEnum_EnumPair::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameEnum.EnumPair.name)
}
#if LANG_CXX11
inline void GameEnum_EnumPair::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameEnum.EnumPair.name)
}
#endif
inline void GameEnum_EnumPair::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameEnum.EnumPair.name)
}
inline void GameEnum_EnumPair::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameEnum.EnumPair.name)
}
inline ::std::string* GameEnum_EnumPair::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameEnum.EnumPair.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameEnum_EnumPair::release_name() {
  // @@protoc_insertion_point(field_release:Analytics.GameEnum.EnumPair.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameEnum_EnumPair::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEnum.EnumPair.name)
}

// int64 value = 2;
inline void GameEnum_EnumPair::clear_value() {
  value_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GameEnum_EnumPair::value() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.EnumPair.value)
  return value_;
}
inline void GameEnum_EnumPair::set_value(::google::protobuf::int64 value) {
  
  value_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEnum.EnumPair.value)
}

// -------------------------------------------------------------------

// GameEnum

// repeated .Analytics.GameEnum.EnumPair values = 1;
inline int GameEnum::values_size() const {
  return values_.size();
}
inline void GameEnum::clear_values() {
  values_.Clear();
}
inline ::Analytics::GameEnum_EnumPair* GameEnum::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEnum.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEnum_EnumPair >*
GameEnum::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.GameEnum.values)
  return &values_;
}
inline const ::Analytics::GameEnum_EnumPair& GameEnum::values(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.values)
  return values_.Get(index);
}
inline ::Analytics::GameEnum_EnumPair* GameEnum::add_values() {
  // @@protoc_insertion_point(field_add:Analytics.GameEnum.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEnum_EnumPair >&
GameEnum::values() const {
  // @@protoc_insertion_point(field_list:Analytics.GameEnum.values)
  return values_;
}

// string enumname = 2;
inline void GameEnum::clear_enumname() {
  enumname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameEnum::enumname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.enumname)
  return enumname_.GetNoArena();
}
inline void GameEnum::set_enumname(const ::std::string& value) {
  
  enumname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameEnum.enumname)
}
#if LANG_CXX11
inline void GameEnum::set_enumname(::std::string&& value) {
  
  enumname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameEnum.enumname)
}
#endif
inline void GameEnum::set_enumname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  enumname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameEnum.enumname)
}
inline void GameEnum::set_enumname(const char* value, size_t size) {
  
  enumname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameEnum.enumname)
}
inline ::std::string* GameEnum::mutable_enumname() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameEnum.enumname)
  return enumname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameEnum::release_enumname() {
  // @@protoc_insertion_point(field_release:Analytics.GameEnum.enumname)
  
  return enumname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameEnum::set_allocated_enumname(::std::string* enumname) {
  if (enumname != NULL) {
    
  } else {
    
  }
  enumname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), enumname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEnum.enumname)
}

// bool isbitfield = 3;
inline void GameEnum::clear_isbitfield() {
  isbitfield_ = false;
}
inline bool GameEnum::isbitfield() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.isbitfield)
  return isbitfield_;
}
inline void GameEnum::set_isbitfield(bool value) {
  
  isbitfield_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEnum.isbitfield)
}

// -------------------------------------------------------------------

// GameNavNotFound

// string mapName = 1;
inline void GameNavNotFound::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameNavNotFound::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavNotFound.mapName)
  return mapname_.GetNoArena();
}
inline void GameNavNotFound::set_mapname(const ::std::string& value) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameNavNotFound.mapName)
}
#if LANG_CXX11
inline void GameNavNotFound::set_mapname(::std::string&& value) {
  
  mapname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNavNotFound.mapName)
}
#endif
inline void GameNavNotFound::set_mapname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNavNotFound.mapName)
}
inline void GameNavNotFound::set_mapname(const char* value, size_t size) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNavNotFound.mapName)
}
inline ::std::string* GameNavNotFound::mutable_mapname() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameNavNotFound.mapName)
  return mapname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameNavNotFound::release_mapname() {
  // @@protoc_insertion_point(field_release:Analytics.GameNavNotFound.mapName)
  
  return mapname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameNavNotFound::set_allocated_mapname(::std::string* mapname) {
  if (mapname != NULL) {
    
  } else {
    
  }
  mapname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNavNotFound.mapName)
}

// -------------------------------------------------------------------

// GameNavAutoDownloaded

// string mapName = 1;
inline void GameNavAutoDownloaded::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameNavAutoDownloaded::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavAutoDownloaded.mapName)
  return mapname_.GetNoArena();
}
inline void GameNavAutoDownloaded::set_mapname(const ::std::string& value) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameNavAutoDownloaded.mapName)
}
#if LANG_CXX11
inline void GameNavAutoDownloaded::set_mapname(::std::string&& value) {
  
  mapname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNavAutoDownloaded.mapName)
}
#endif
inline void GameNavAutoDownloaded::set_mapname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNavAutoDownloaded.mapName)
}
inline void GameNavAutoDownloaded::set_mapname(const char* value, size_t size) {
  
  mapname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNavAutoDownloaded.mapName)
}
inline ::std::string* GameNavAutoDownloaded::mutable_mapname() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameNavAutoDownloaded.mapName)
  return mapname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameNavAutoDownloaded::release_mapname() {
  // @@protoc_insertion_point(field_release:Analytics.GameNavAutoDownloaded.mapName)
  
  return mapname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameNavAutoDownloaded::set_allocated_mapname(::std::string* mapname) {
  if (mapname != NULL) {
    
  } else {
    
  }
  mapname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNavAutoDownloaded.mapName)
}

// -------------------------------------------------------------------

// GameAssert

// string condition = 1;
inline void GameAssert::clear_condition() {
  condition_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameAssert::condition() const {
  // @@protoc_insertion_point(field_get:Analytics.GameAssert.condition)
  return condition_.GetNoArena();
}
inline void GameAssert::set_condition(const ::std::string& value) {
  
  condition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameAssert.condition)
}
#if LANG_CXX11
inline void GameAssert::set_condition(::std::string&& value) {
  
  condition_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameAssert.condition)
}
#endif
inline void GameAssert::set_condition(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  condition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameAssert.condition)
}
inline void GameAssert::set_condition(const char* value, size_t size) {
  
  condition_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameAssert.condition)
}
inline ::std::string* GameAssert::mutable_condition() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameAssert.condition)
  return condition_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameAssert::release_condition() {
  // @@protoc_insertion_point(field_release:Analytics.GameAssert.condition)
  
  return condition_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameAssert::set_allocated_condition(::std::string* condition) {
  if (condition != NULL) {
    
  } else {
    
  }
  condition_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), condition);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameAssert.condition)
}

// string file = 2;
inline void GameAssert::clear_file() {
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameAssert::file() const {
  // @@protoc_insertion_point(field_get:Analytics.GameAssert.file)
  return file_.GetNoArena();
}
inline void GameAssert::set_file(const ::std::string& value) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameAssert.file)
}
#if LANG_CXX11
inline void GameAssert::set_file(::std::string&& value) {
  
  file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameAssert.file)
}
#endif
inline void GameAssert::set_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameAssert.file)
}
inline void GameAssert::set_file(const char* value, size_t size) {
  
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameAssert.file)
}
inline ::std::string* GameAssert::mutable_file() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameAssert.file)
  return file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameAssert::release_file() {
  // @@protoc_insertion_point(field_release:Analytics.GameAssert.file)
  
  return file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameAssert::set_allocated_file(::std::string* file) {
  if (file != NULL) {
    
  } else {
    
  }
  file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameAssert.file)
}

// int32 line = 3;
inline void GameAssert::clear_line() {
  line_ = 0;
}
inline ::google::protobuf::int32 GameAssert::line() const {
  // @@protoc_insertion_point(field_get:Analytics.GameAssert.line)
  return line_;
}
inline void GameAssert::set_line(::google::protobuf::int32 value) {
  
  line_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameAssert.line)
}

// -------------------------------------------------------------------

// GameCrash

// string info = 1;
inline void GameCrash::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameCrash::info() const {
  // @@protoc_insertion_point(field_get:Analytics.GameCrash.info)
  return info_.GetNoArena();
}
inline void GameCrash::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameCrash.info)
}
#if LANG_CXX11
inline void GameCrash::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameCrash.info)
}
#endif
inline void GameCrash::set_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameCrash.info)
}
inline void GameCrash::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameCrash.info)
}
inline ::std::string* GameCrash::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameCrash.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameCrash::release_info() {
  // @@protoc_insertion_point(field_release:Analytics.GameCrash.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameCrash::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameCrash.info)
}

// -------------------------------------------------------------------

// GameMeshData

// .Analytics.Compression compressionType = 1;
inline void GameMeshData::clear_compressiontype() {
  compressiontype_ = 0;
}
inline ::Analytics::Compression GameMeshData::compressiontype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameMeshData.compressionType)
  return static_cast< ::Analytics::Compression >(compressiontype_);
}
inline void GameMeshData::set_compressiontype(::Analytics::Compression value) {
  
  compressiontype_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameMeshData.compressionType)
}

// string modelName = 2;
inline void GameMeshData::clear_modelname() {
  modelname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameMeshData::modelname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameMeshData.modelName)
  return modelname_.GetNoArena();
}
inline void GameMeshData::set_modelname(const ::std::string& value) {
  
  modelname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameMeshData.modelName)
}
#if LANG_CXX11
inline void GameMeshData::set_modelname(::std::string&& value) {
  
  modelname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameMeshData.modelName)
}
#endif
inline void GameMeshData::set_modelname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  modelname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameMeshData.modelName)
}
inline void GameMeshData::set_modelname(const char* value, size_t size) {
  
  modelname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameMeshData.modelName)
}
inline ::std::string* GameMeshData::mutable_modelname() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameMeshData.modelName)
  return modelname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameMeshData::release_modelname() {
  // @@protoc_insertion_point(field_release:Analytics.GameMeshData.modelName)
  
  return modelname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameMeshData::set_allocated_modelname(::std::string* modelname) {
  if (modelname != NULL) {
    
  } else {
    
  }
  modelname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameMeshData.modelName)
}

// bytes modelBytes = 3;
inline void GameMeshData::clear_modelbytes() {
  modelbytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameMeshData::modelbytes() const {
  // @@protoc_insertion_point(field_get:Analytics.GameMeshData.modelBytes)
  return modelbytes_.GetNoArena();
}
inline void GameMeshData::set_modelbytes(const ::std::string& value) {
  
  modelbytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameMeshData.modelBytes)
}
#if LANG_CXX11
inline void GameMeshData::set_modelbytes(::std::string&& value) {
  
  modelbytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameMeshData.modelBytes)
}
#endif
inline void GameMeshData::set_modelbytes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  modelbytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameMeshData.modelBytes)
}
inline void GameMeshData::set_modelbytes(const void* value, size_t size) {
  
  modelbytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameMeshData.modelBytes)
}
inline ::std::string* GameMeshData::mutable_modelbytes() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameMeshData.modelBytes)
  return modelbytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameMeshData::release_modelbytes() {
  // @@protoc_insertion_point(field_release:Analytics.GameMeshData.modelBytes)
  
  return modelbytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameMeshData::set_allocated_modelbytes(::std::string* modelbytes) {
  if (modelbytes != NULL) {
    
  } else {
    
  }
  modelbytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), modelbytes);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameMeshData.modelBytes)
}

// uint32 modelBytesUncompressed = 4;
inline void GameMeshData::clear_modelbytesuncompressed() {
  modelbytesuncompressed_ = 0u;
}
inline ::google::protobuf::uint32 GameMeshData::modelbytesuncompressed() const {
  // @@protoc_insertion_point(field_get:Analytics.GameMeshData.modelBytesUncompressed)
  return modelbytesuncompressed_;
}
inline void GameMeshData::set_modelbytesuncompressed(::google::protobuf::uint32 value) {
  
  modelbytesuncompressed_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameMeshData.modelBytesUncompressed)
}

// -------------------------------------------------------------------

// GameEntityInfo_Ammo

// uint32 ammoType = 1 [(.Analytics.enumkey) = "AMMO_TYPE"];
inline void GameEntityInfo_Ammo::clear_ammotype() {
  ammotype_ = 0u;
}
inline ::google::protobuf::uint32 GameEntityInfo_Ammo::ammotype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.Ammo.ammoType)
  return ammotype_;
}
inline void GameEntityInfo_Ammo::set_ammotype(::google::protobuf::uint32 value) {
  
  ammotype_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.Ammo.ammoType)
}

// uint32 ammoCount = 2;
inline void GameEntityInfo_Ammo::clear_ammocount() {
  ammocount_ = 0u;
}
inline ::google::protobuf::uint32 GameEntityInfo_Ammo::ammocount() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.Ammo.ammoCount)
  return ammocount_;
}
inline void GameEntityInfo_Ammo::set_ammocount(::google::protobuf::uint32 value) {
  
  ammocount_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.Ammo.ammoCount)
}

// -------------------------------------------------------------------

// GameEntityInfo

// string entityName = 1;
inline void GameEntityInfo::clear_entityname() {
  entityname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameEntityInfo::entityname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entityName)
  return entityname_.GetNoArena();
}
inline void GameEntityInfo::set_entityname(const ::std::string& value) {
  
  entityname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entityName)
}
#if LANG_CXX11
inline void GameEntityInfo::set_entityname(::std::string&& value) {
  
  entityname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameEntityInfo.entityName)
}
#endif
inline void GameEntityInfo::set_entityname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  entityname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameEntityInfo.entityName)
}
inline void GameEntityInfo::set_entityname(const char* value, size_t size) {
  
  entityname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameEntityInfo.entityName)
}
inline ::std::string* GameEntityInfo::mutable_entityname() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.entityName)
  return entityname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameEntityInfo::release_entityname() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.entityName)
  
  return entityname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameEntityInfo::set_allocated_entityname(::std::string* entityname) {
  if (entityname != NULL) {
    
  } else {
    
  }
  entityname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entityname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.entityName)
}

// int32 entityIndex = 2;
inline void GameEntityInfo::clear_entityindex() {
  entityindex_ = 0;
}
inline ::google::protobuf::int32 GameEntityInfo::entityindex() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entityIndex)
  return entityindex_;
}
inline void GameEntityInfo::set_entityindex(::google::protobuf::int32 value) {
  
  entityindex_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entityIndex)
}

// int32 entitySerial = 3;
inline void GameEntityInfo::clear_entityserial() {
  entityserial_ = 0;
}
inline ::google::protobuf::int32 GameEntityInfo::entityserial() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entitySerial)
  return entityserial_;
}
inline void GameEntityInfo::set_entityserial(::google::protobuf::int32 value) {
  
  entityserial_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entitySerial)
}

// int32 groupId = 4 [(.Analytics.enumkey) = "GROUP_ID"];
inline void GameEntityInfo::clear_groupid() {
  groupid_ = 0;
}
inline ::google::protobuf::int32 GameEntityInfo::groupid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.groupId)
  return groupid_;
}
inline void GameEntityInfo::set_groupid(::google::protobuf::int32 value) {
  
  groupid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.groupId)
}

// int32 classId = 5 [(.Analytics.enumkey) = "CLASS_ID"];
inline void GameEntityInfo::clear_classid() {
  classid_ = 0;
}
inline ::google::protobuf::int32 GameEntityInfo::classid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.classId)
  return classid_;
}
inline void GameEntityInfo::set_classid(::google::protobuf::int32 value) {
  
  classid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.classId)
}

// int32 team = 6 [(.Analytics.enumkey) = "TEAM_ID"];
inline void GameEntityInfo::clear_team() {
  team_ = 0;
}
inline ::google::protobuf::int32 GameEntityInfo::team() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.team)
  return team_;
}
inline void GameEntityInfo::set_team(::google::protobuf::int32 value) {
  
  team_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.team)
}

// int64 entityFlags = 7 [(.Analytics.enumkey) = "ENTITY_FLAGS", (.Analytics.enumflagsindexed) = true];
inline void GameEntityInfo::clear_entityflags() {
  entityflags_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GameEntityInfo::entityflags() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entityFlags)
  return entityflags_;
}
inline void GameEntityInfo::set_entityflags(::google::protobuf::int64 value) {
  
  entityflags_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entityFlags)
}

// int32 category = 8 [(.Analytics.enumkey) = "CATEGORY_ID", (.Analytics.enumflagsindexed) = true];
inline void GameEntityInfo::clear_category() {
  category_ = 0;
}
inline ::google::protobuf::int32 GameEntityInfo::category() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.category)
  return category_;
}
inline void GameEntityInfo::set_category(::google::protobuf::int32 value) {
  
  category_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.category)
}

// int32 powerUps = 9 [(.Analytics.enumkey) = "POWERUP_ID", (.Analytics.enumflagsindexed) = true];
inline void GameEntityInfo::clear_powerups() {
  powerups_ = 0;
}
inline ::google::protobuf::int32 GameEntityInfo::powerups() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.powerUps)
  return powerups_;
}
inline void GameEntityInfo::set_powerups(::google::protobuf::int32 value) {
  
  powerups_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.powerUps)
}

// int64 navFlags = 10 [(.Analytics.enumkey) = "NAV_FLAGS"];
inline void GameEntityInfo::clear_navflags() {
  navflags_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GameEntityInfo::navflags() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.navFlags)
  return navflags_;
}
inline void GameEntityInfo::set_navflags(::google::protobuf::int64 value) {
  
  navflags_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.navFlags)
}

// .Analytics.Vec3 eulerRotation = 11 [(.Analytics.hidden) = true];
inline bool GameEntityInfo::has_eulerrotation() const {
  return this != internal_default_instance() && eulerrotation_ != NULL;
}
inline void GameEntityInfo::clear_eulerrotation() {
  if (GetArenaNoVirtual() == NULL && eulerrotation_ != NULL) {
    delete eulerrotation_;
  }
  eulerrotation_ = NULL;
}
inline const ::Analytics::Vec3& GameEntityInfo::eulerrotation() const {
  const ::Analytics::Vec3* p = eulerrotation_;
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.eulerRotation)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameEntityInfo::release_eulerrotation() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.eulerRotation)
  
  ::Analytics::Vec3* temp = eulerrotation_;
  eulerrotation_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_eulerrotation() {
  
  if (eulerrotation_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    eulerrotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.eulerRotation)
  return eulerrotation_;
}
inline void GameEntityInfo::set_allocated_eulerrotation(::Analytics::Vec3* eulerrotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete eulerrotation_;
  }
  if (eulerrotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eulerrotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eulerrotation, submessage_arena);
    }
    
  } else {
    
  }
  eulerrotation_ = eulerrotation;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.eulerRotation)
}

// .Analytics.Vec3 position = 12 [(.Analytics.hidden) = true];
inline bool GameEntityInfo::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameEntityInfo::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameEntityInfo::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameEntityInfo::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.position)
  return position_;
}
inline void GameEntityInfo::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.position)
}

// .Analytics.Vec3 eyeOffset = 13 [(.Analytics.hidden) = true];
inline bool GameEntityInfo::has_eyeoffset() const {
  return this != internal_default_instance() && eyeoffset_ != NULL;
}
inline void GameEntityInfo::clear_eyeoffset() {
  if (GetArenaNoVirtual() == NULL && eyeoffset_ != NULL) {
    delete eyeoffset_;
  }
  eyeoffset_ = NULL;
}
inline const ::Analytics::Vec3& GameEntityInfo::eyeoffset() const {
  const ::Analytics::Vec3* p = eyeoffset_;
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.eyeOffset)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameEntityInfo::release_eyeoffset() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.eyeOffset)
  
  ::Analytics::Vec3* temp = eyeoffset_;
  eyeoffset_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_eyeoffset() {
  
  if (eyeoffset_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    eyeoffset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.eyeOffset)
  return eyeoffset_;
}
inline void GameEntityInfo::set_allocated_eyeoffset(::Analytics::Vec3* eyeoffset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete eyeoffset_;
  }
  if (eyeoffset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eyeoffset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eyeoffset, submessage_arena);
    }
    
  } else {
    
  }
  eyeoffset_ = eyeoffset;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.eyeOffset)
}

// .Analytics.Vec3 eyeDir = 14 [(.Analytics.hidden) = true];
inline bool GameEntityInfo::has_eyedir() const {
  return this != internal_default_instance() && eyedir_ != NULL;
}
inline void GameEntityInfo::clear_eyedir() {
  if (GetArenaNoVirtual() == NULL && eyedir_ != NULL) {
    delete eyedir_;
  }
  eyedir_ = NULL;
}
inline const ::Analytics::Vec3& GameEntityInfo::eyedir() const {
  const ::Analytics::Vec3* p = eyedir_;
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.eyeDir)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameEntityInfo::release_eyedir() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.eyeDir)
  
  ::Analytics::Vec3* temp = eyedir_;
  eyedir_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_eyedir() {
  
  if (eyedir_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    eyedir_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.eyeDir)
  return eyedir_;
}
inline void GameEntityInfo::set_allocated_eyedir(::Analytics::Vec3* eyedir) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete eyedir_;
  }
  if (eyedir) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eyedir = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eyedir, submessage_arena);
    }
    
  } else {
    
  }
  eyedir_ = eyedir;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.eyeDir)
}

// .Analytics.RangeI health = 15;
inline bool GameEntityInfo::has_health() const {
  return this != internal_default_instance() && health_ != NULL;
}
inline void GameEntityInfo::clear_health() {
  if (GetArenaNoVirtual() == NULL && health_ != NULL) {
    delete health_;
  }
  health_ = NULL;
}
inline const ::Analytics::RangeI& GameEntityInfo::health() const {
  const ::Analytics::RangeI* p = health_;
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.health)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::RangeI*>(
      &::Analytics::_RangeI_default_instance_);
}
inline ::Analytics::RangeI* GameEntityInfo::release_health() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.health)
  
  ::Analytics::RangeI* temp = health_;
  health_ = NULL;
  return temp;
}
inline ::Analytics::RangeI* GameEntityInfo::mutable_health() {
  
  if (health_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::RangeI>(GetArenaNoVirtual());
    health_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.health)
  return health_;
}
inline void GameEntityInfo::set_allocated_health(::Analytics::RangeI* health) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete health_;
  }
  if (health) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      health = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, health, submessage_arena);
    }
    
  } else {
    
  }
  health_ = health;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.health)
}

// .Analytics.RangeI armor = 16;
inline bool GameEntityInfo::has_armor() const {
  return this != internal_default_instance() && armor_ != NULL;
}
inline void GameEntityInfo::clear_armor() {
  if (GetArenaNoVirtual() == NULL && armor_ != NULL) {
    delete armor_;
  }
  armor_ = NULL;
}
inline const ::Analytics::RangeI& GameEntityInfo::armor() const {
  const ::Analytics::RangeI* p = armor_;
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.armor)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::RangeI*>(
      &::Analytics::_RangeI_default_instance_);
}
inline ::Analytics::RangeI* GameEntityInfo::release_armor() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.armor)
  
  ::Analytics::RangeI* temp = armor_;
  armor_ = NULL;
  return temp;
}
inline ::Analytics::RangeI* GameEntityInfo::mutable_armor() {
  
  if (armor_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::RangeI>(GetArenaNoVirtual());
    armor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.armor)
  return armor_;
}
inline void GameEntityInfo::set_allocated_armor(::Analytics::RangeI* armor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete armor_;
  }
  if (armor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      armor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, armor, submessage_arena);
    }
    
  } else {
    
  }
  armor_ = armor;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.armor)
}

// .Analytics.Vec3 boundsMin = 17;
inline bool GameEntityInfo::has_boundsmin() const {
  return this != internal_default_instance() && boundsmin_ != NULL;
}
inline void GameEntityInfo::clear_boundsmin() {
  if (GetArenaNoVirtual() == NULL && boundsmin_ != NULL) {
    delete boundsmin_;
  }
  boundsmin_ = NULL;
}
inline const ::Analytics::Vec3& GameEntityInfo::boundsmin() const {
  const ::Analytics::Vec3* p = boundsmin_;
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.boundsMin)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameEntityInfo::release_boundsmin() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.boundsMin)
  
  ::Analytics::Vec3* temp = boundsmin_;
  boundsmin_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_boundsmin() {
  
  if (boundsmin_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    boundsmin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.boundsMin)
  return boundsmin_;
}
inline void GameEntityInfo::set_allocated_boundsmin(::Analytics::Vec3* boundsmin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete boundsmin_;
  }
  if (boundsmin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      boundsmin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, boundsmin, submessage_arena);
    }
    
  } else {
    
  }
  boundsmin_ = boundsmin;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.boundsMin)
}

// .Analytics.Vec3 boundsMax = 18;
inline bool GameEntityInfo::has_boundsmax() const {
  return this != internal_default_instance() && boundsmax_ != NULL;
}
inline void GameEntityInfo::clear_boundsmax() {
  if (GetArenaNoVirtual() == NULL && boundsmax_ != NULL) {
    delete boundsmax_;
  }
  boundsmax_ = NULL;
}
inline const ::Analytics::Vec3& GameEntityInfo::boundsmax() const {
  const ::Analytics::Vec3* p = boundsmax_;
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.boundsMax)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameEntityInfo::release_boundsmax() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.boundsMax)
  
  ::Analytics::Vec3* temp = boundsmax_;
  boundsmax_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_boundsmax() {
  
  if (boundsmax_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    boundsmax_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.boundsMax)
  return boundsmax_;
}
inline void GameEntityInfo::set_allocated_boundsmax(::Analytics::Vec3* boundsmax) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete boundsmax_;
  }
  if (boundsmax) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      boundsmax = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, boundsmax, submessage_arena);
    }
    
  } else {
    
  }
  boundsmax_ = boundsmax;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.boundsMax)
}

// repeated .Analytics.GameEntityInfo.Ammo ammo = 19;
inline int GameEntityInfo::ammo_size() const {
  return ammo_.size();
}
inline void GameEntityInfo::clear_ammo() {
  ammo_.Clear();
}
inline ::Analytics::GameEntityInfo_Ammo* GameEntityInfo::mutable_ammo(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.ammo)
  return ammo_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >*
GameEntityInfo::mutable_ammo() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.GameEntityInfo.ammo)
  return &ammo_;
}
inline const ::Analytics::GameEntityInfo_Ammo& GameEntityInfo::ammo(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo)
  return ammo_.Get(index);
}
inline ::Analytics::GameEntityInfo_Ammo* GameEntityInfo::add_ammo() {
  // @@protoc_insertion_point(field_add:Analytics.GameEntityInfo.ammo)
  return ammo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >&
GameEntityInfo::ammo() const {
  // @@protoc_insertion_point(field_list:Analytics.GameEntityInfo.ammo)
  return ammo_;
}

// bool deleted = 1000 [(.Analytics.hidden) = true];
inline void GameEntityInfo::clear_deleted() {
  deleted_ = false;
}
inline bool GameEntityInfo::deleted() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.deleted)
  return deleted_;
}
inline void GameEntityInfo::set_deleted(bool value) {
  
  deleted_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.deleted)
}

// -------------------------------------------------------------------

// GameEntityPosition

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameEntityPosition::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameEntityPosition::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameEntityPosition::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameEntityPosition.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameEntityPosition::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityPosition.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameEntityPosition::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityPosition.position)
  return position_;
}
inline void GameEntityPosition::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityPosition.position)
}

// int32 team = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameEntityPosition::clear_team() {
  team_ = 0;
}
inline ::google::protobuf::int32 GameEntityPosition::team() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityPosition.team)
  return team_;
}
inline void GameEntityPosition::set_team(::google::protobuf::int32 value) {
  
  team_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameEntityPosition.team)
}

// -------------------------------------------------------------------

// GameNode

// string nodePath = 1 [(.Analytics.editable_key) = true];
inline void GameNode::clear_nodepath() {
  nodepath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameNode::nodepath() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.nodePath)
  return nodepath_.GetNoArena();
}
inline void GameNode::set_nodepath(const ::std::string& value) {
  
  nodepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.nodePath)
}
#if LANG_CXX11
inline void GameNode::set_nodepath(::std::string&& value) {
  
  nodepath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNode.nodePath)
}
#endif
inline void GameNode::set_nodepath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNode.nodePath)
}
inline void GameNode::set_nodepath(const char* value, size_t size) {
  
  nodepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNode.nodePath)
}
inline ::std::string* GameNode::mutable_nodepath() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.nodePath)
  return nodepath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameNode::release_nodepath() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.nodePath)
  
  return nodepath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameNode::set_allocated_nodepath(::std::string* nodepath) {
  if (nodepath != NULL) {
    
  } else {
    
  }
  nodepath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodepath);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.nodePath)
}

// .Analytics.Vec3 eulerRotation = 2;
inline bool GameNode::has_eulerrotation() const {
  return this != internal_default_instance() && eulerrotation_ != NULL;
}
inline void GameNode::clear_eulerrotation() {
  if (GetArenaNoVirtual() == NULL && eulerrotation_ != NULL) {
    delete eulerrotation_;
  }
  eulerrotation_ = NULL;
}
inline const ::Analytics::Vec3& GameNode::eulerrotation() const {
  const ::Analytics::Vec3* p = eulerrotation_;
  // @@protoc_insertion_point(field_get:Analytics.GameNode.eulerRotation)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameNode::release_eulerrotation() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.eulerRotation)
  
  ::Analytics::Vec3* temp = eulerrotation_;
  eulerrotation_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameNode::mutable_eulerrotation() {
  
  if (eulerrotation_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    eulerrotation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.eulerRotation)
  return eulerrotation_;
}
inline void GameNode::set_allocated_eulerrotation(::Analytics::Vec3* eulerrotation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete eulerrotation_;
  }
  if (eulerrotation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      eulerrotation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, eulerrotation, submessage_arena);
    }
    
  } else {
    
  }
  eulerrotation_ = eulerrotation;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.eulerRotation)
}

// .Analytics.Vec3 translation = 3;
inline bool GameNode::has_translation() const {
  return this != internal_default_instance() && translation_ != NULL;
}
inline void GameNode::clear_translation() {
  if (GetArenaNoVirtual() == NULL && translation_ != NULL) {
    delete translation_;
  }
  translation_ = NULL;
}
inline const ::Analytics::Vec3& GameNode::translation() const {
  const ::Analytics::Vec3* p = translation_;
  // @@protoc_insertion_point(field_get:Analytics.GameNode.translation)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameNode::release_translation() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.translation)
  
  ::Analytics::Vec3* temp = translation_;
  translation_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameNode::mutable_translation() {
  
  if (translation_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    translation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.translation)
  return translation_;
}
inline void GameNode::set_allocated_translation(::Analytics::Vec3* translation) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete translation_;
  }
  if (translation) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      translation = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, translation, submessage_arena);
    }
    
  } else {
    
  }
  translation_ = translation;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.translation)
}

// string meshName = 4;
inline void GameNode::clear_meshname() {
  meshname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameNode::meshname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.meshName)
  return meshname_.GetNoArena();
}
inline void GameNode::set_meshname(const ::std::string& value) {
  
  meshname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.meshName)
}
#if LANG_CXX11
inline void GameNode::set_meshname(::std::string&& value) {
  
  meshname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNode.meshName)
}
#endif
inline void GameNode::set_meshname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  meshname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNode.meshName)
}
inline void GameNode::set_meshname(const char* value, size_t size) {
  
  meshname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNode.meshName)
}
inline ::std::string* GameNode::mutable_meshname() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.meshName)
  return meshname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameNode::release_meshname() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.meshName)
  
  return meshname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameNode::set_allocated_meshname(::std::string* meshname) {
  if (meshname != NULL) {
    
  } else {
    
  }
  meshname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meshname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.meshName)
}

// int32 entityId = 10;
inline void GameNode::clear_entityid() {
  entityid_ = 0;
}
inline ::google::protobuf::int32 GameNode::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.entityId)
  return entityid_;
}
inline void GameNode::set_entityid(::google::protobuf::int32 value) {
  
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNode.entityId)
}

// string entityName = 11;
inline void GameNode::clear_entityname() {
  entityname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameNode::entityname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.entityName)
  return entityname_.GetNoArena();
}
inline void GameNode::set_entityname(const ::std::string& value) {
  
  entityname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.entityName)
}
#if LANG_CXX11
inline void GameNode::set_entityname(::std::string&& value) {
  
  entityname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNode.entityName)
}
#endif
inline void GameNode::set_entityname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  entityname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNode.entityName)
}
inline void GameNode::set_entityname(const char* value, size_t size) {
  
  entityname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNode.entityName)
}
inline ::std::string* GameNode::mutable_entityname() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.entityName)
  return entityname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameNode::release_entityname() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.entityName)
  
  return entityname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameNode::set_allocated_entityname(::std::string* entityname) {
  if (entityname != NULL) {
    
  } else {
    
  }
  entityname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entityname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.entityName)
}

// int32 activeState = 12 [(.Analytics.enumkey) = "MODEL_STATE"];
inline void GameNode::clear_activestate() {
  activestate_ = 0;
}
inline ::google::protobuf::int32 GameNode::activestate() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.activeState)
  return activestate_;
}
inline void GameNode::set_activestate(::google::protobuf::int32 value) {
  
  activestate_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNode.activeState)
}

// int64 navFlagsActive = 13 [(.Analytics.enumkey) = "NAV_FLAGS"];
inline void GameNode::clear_navflagsactive() {
  navflagsactive_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GameNode::navflagsactive() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.navFlagsActive)
  return navflagsactive_;
}
inline void GameNode::set_navflagsactive(::google::protobuf::int64 value) {
  
  navflagsactive_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNode.navFlagsActive)
}

// int64 navFlagsOverride = 14 [(.Analytics.enumkey) = "NAV_FLAGS", (.Analytics.editable) = true];
inline void GameNode::clear_navflagsoverride() {
  navflagsoverride_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 GameNode::navflagsoverride() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.navFlagsOverride)
  return navflagsoverride_;
}
inline void GameNode::set_navflagsoverride(::google::protobuf::int64 value) {
  
  navflagsoverride_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNode.navFlagsOverride)
}

// int32 shapeMode = 15 [(.Analytics.enumkey) = "SHAPEMODE", (.Analytics.editable) = true];
inline void GameNode::clear_shapemode() {
  shapemode_ = 0;
}
inline ::google::protobuf::int32 GameNode::shapemode() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.shapeMode)
  return shapemode_;
}
inline void GameNode::set_shapemode(::google::protobuf::int32 value) {
  
  shapemode_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNode.shapeMode)
}

// -------------------------------------------------------------------

// GameWeaponFired

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameWeaponFired::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameWeaponFired::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameWeaponFired::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameWeaponFired::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameWeaponFired.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameWeaponFired::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameWeaponFired.position)
  return position_;
}
inline void GameWeaponFired::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameWeaponFired.position)
}

// int32 attackTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameWeaponFired::clear_attackteam() {
  attackteam_ = 0;
}
inline ::google::protobuf::int32 GameWeaponFired::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.attackTeam)
  return attackteam_;
}
inline void GameWeaponFired::set_attackteam(::google::protobuf::int32 value) {
  
  attackteam_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.attackTeam)
}

// int32 weaponId = 3 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
inline void GameWeaponFired::clear_weaponid() {
  weaponid_ = 0;
}
inline ::google::protobuf::int32 GameWeaponFired::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.weaponId)
  return weaponid_;
}
inline void GameWeaponFired::set_weaponid(::google::protobuf::int32 value) {
  
  weaponid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.weaponId)
}

// int32 firedByClass = 4 [(.Analytics.enumkey) = "CLASS_ID", (.Analytics.track_event) = true];
inline void GameWeaponFired::clear_firedbyclass() {
  firedbyclass_ = 0;
}
inline ::google::protobuf::int32 GameWeaponFired::firedbyclass() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.firedByClass)
  return firedbyclass_;
}
inline void GameWeaponFired::set_firedbyclass(::google::protobuf::int32 value) {
  
  firedbyclass_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.firedByClass)
}

// -------------------------------------------------------------------

// GameDeath

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameDeath::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameDeath::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameDeath::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameDeath::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameDeath.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameDeath::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameDeath.position)
  return position_;
}
inline void GameDeath::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameDeath.position)
}

// int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameDeath::clear_victimteam() {
  victimteam_ = 0;
}
inline ::google::protobuf::int32 GameDeath::victimteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.victimTeam)
  return victimteam_;
}
inline void GameDeath::set_victimteam(::google::protobuf::int32 value) {
  
  victimteam_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.victimTeam)
}

// int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameDeath::clear_attackteam() {
  attackteam_ = 0;
}
inline ::google::protobuf::int32 GameDeath::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.attackTeam)
  return attackteam_;
}
inline void GameDeath::set_attackteam(::google::protobuf::int32 value) {
  
  attackteam_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.attackTeam)
}

// string meansOfDeath = 4 [(.Analytics.track_event) = true];
inline void GameDeath::clear_meansofdeath() {
  meansofdeath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameDeath::meansofdeath() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.meansOfDeath)
  return meansofdeath_.GetNoArena();
}
inline void GameDeath::set_meansofdeath(const ::std::string& value) {
  
  meansofdeath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.meansOfDeath)
}
#if LANG_CXX11
inline void GameDeath::set_meansofdeath(::std::string&& value) {
  
  meansofdeath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameDeath.meansOfDeath)
}
#endif
inline void GameDeath::set_meansofdeath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  meansofdeath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameDeath.meansOfDeath)
}
inline void GameDeath::set_meansofdeath(const char* value, size_t size) {
  
  meansofdeath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameDeath.meansOfDeath)
}
inline ::std::string* GameDeath::mutable_meansofdeath() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameDeath.meansOfDeath)
  return meansofdeath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameDeath::release_meansofdeath() {
  // @@protoc_insertion_point(field_release:Analytics.GameDeath.meansOfDeath)
  
  return meansofdeath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameDeath::set_allocated_meansofdeath(::std::string* meansofdeath) {
  if (meansofdeath != NULL) {
    
  } else {
    
  }
  meansofdeath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meansofdeath);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameDeath.meansOfDeath)
}

// -------------------------------------------------------------------

// GameKilledSomeone

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameKilledSomeone::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameKilledSomeone::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameKilledSomeone::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameKilledSomeone.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameKilledSomeone::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameKilledSomeone.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameKilledSomeone::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameKilledSomeone.position)
  return position_;
}
inline void GameKilledSomeone::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameKilledSomeone.position)
}

// int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameKilledSomeone::clear_victimteam() {
  victimteam_ = 0;
}
inline ::google::protobuf::int32 GameKilledSomeone::victimteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameKilledSomeone.victimTeam)
  return victimteam_;
}
inline void GameKilledSomeone::set_victimteam(::google::protobuf::int32 value) {
  
  victimteam_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameKilledSomeone.victimTeam)
}

// int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameKilledSomeone::clear_attackteam() {
  attackteam_ = 0;
}
inline ::google::protobuf::int32 GameKilledSomeone::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameKilledSomeone.attackTeam)
  return attackteam_;
}
inline void GameKilledSomeone::set_attackteam(::google::protobuf::int32 value) {
  
  attackteam_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameKilledSomeone.attackTeam)
}

// string meansOfDeath = 4 [(.Analytics.track_event) = true];
inline void GameKilledSomeone::clear_meansofdeath() {
  meansofdeath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameKilledSomeone::meansofdeath() const {
  // @@protoc_insertion_point(field_get:Analytics.GameKilledSomeone.meansOfDeath)
  return meansofdeath_.GetNoArena();
}
inline void GameKilledSomeone::set_meansofdeath(const ::std::string& value) {
  
  meansofdeath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameKilledSomeone.meansOfDeath)
}
#if LANG_CXX11
inline void GameKilledSomeone::set_meansofdeath(::std::string&& value) {
  
  meansofdeath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameKilledSomeone.meansOfDeath)
}
#endif
inline void GameKilledSomeone::set_meansofdeath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  meansofdeath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameKilledSomeone.meansOfDeath)
}
inline void GameKilledSomeone::set_meansofdeath(const char* value, size_t size) {
  
  meansofdeath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameKilledSomeone.meansOfDeath)
}
inline ::std::string* GameKilledSomeone::mutable_meansofdeath() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameKilledSomeone.meansOfDeath)
  return meansofdeath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameKilledSomeone::release_meansofdeath() {
  // @@protoc_insertion_point(field_release:Analytics.GameKilledSomeone.meansOfDeath)
  
  return meansofdeath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameKilledSomeone::set_allocated_meansofdeath(::std::string* meansofdeath) {
  if (meansofdeath != NULL) {
    
  } else {
    
  }
  meansofdeath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), meansofdeath);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameKilledSomeone.meansOfDeath)
}

// -------------------------------------------------------------------

// GameRecieveDamage

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameRecieveDamage::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameRecieveDamage::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameRecieveDamage::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameRecieveDamage::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameRecieveDamage.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameRecieveDamage::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameRecieveDamage.position)
  return position_;
}
inline void GameRecieveDamage::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameRecieveDamage.position)
}

// int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameRecieveDamage::clear_victimteam() {
  victimteam_ = 0;
}
inline ::google::protobuf::int32 GameRecieveDamage::victimteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.victimTeam)
  return victimteam_;
}
inline void GameRecieveDamage::set_victimteam(::google::protobuf::int32 value) {
  
  victimteam_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.victimTeam)
}

// int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameRecieveDamage::clear_attackteam() {
  attackteam_ = 0;
}
inline ::google::protobuf::int32 GameRecieveDamage::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.attackTeam)
  return attackteam_;
}
inline void GameRecieveDamage::set_attackteam(::google::protobuf::int32 value) {
  
  attackteam_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.attackTeam)
}

// int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
inline void GameRecieveDamage::clear_weaponid() {
  weaponid_ = 0;
}
inline ::google::protobuf::int32 GameRecieveDamage::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.weaponId)
  return weaponid_;
}
inline void GameRecieveDamage::set_weaponid(::google::protobuf::int32 value) {
  
  weaponid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.weaponId)
}

// string damageType = 5 [(.Analytics.track_event) = true];
inline void GameRecieveDamage::clear_damagetype() {
  damagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameRecieveDamage::damagetype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.damageType)
  return damagetype_.GetNoArena();
}
inline void GameRecieveDamage::set_damagetype(const ::std::string& value) {
  
  damagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.damageType)
}
#if LANG_CXX11
inline void GameRecieveDamage::set_damagetype(::std::string&& value) {
  
  damagetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameRecieveDamage.damageType)
}
#endif
inline void GameRecieveDamage::set_damagetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  damagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameRecieveDamage.damageType)
}
inline void GameRecieveDamage::set_damagetype(const char* value, size_t size) {
  
  damagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameRecieveDamage.damageType)
}
inline ::std::string* GameRecieveDamage::mutable_damagetype() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameRecieveDamage.damageType)
  return damagetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameRecieveDamage::release_damagetype() {
  // @@protoc_insertion_point(field_release:Analytics.GameRecieveDamage.damageType)
  
  return damagetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameRecieveDamage::set_allocated_damagetype(::std::string* damagetype) {
  if (damagetype != NULL) {
    
  } else {
    
  }
  damagetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), damagetype);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameRecieveDamage.damageType)
}

// float damageAmount = 6;
inline void GameRecieveDamage::clear_damageamount() {
  damageamount_ = 0;
}
inline float GameRecieveDamage::damageamount() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.damageAmount)
  return damageamount_;
}
inline void GameRecieveDamage::set_damageamount(float value) {
  
  damageamount_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.damageAmount)
}

// -------------------------------------------------------------------

// GameInflictDamage

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameInflictDamage::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameInflictDamage::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameInflictDamage::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameInflictDamage::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameInflictDamage.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameInflictDamage::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameInflictDamage.position)
  return position_;
}
inline void GameInflictDamage::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInflictDamage.position)
}

// int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameInflictDamage::clear_victimteam() {
  victimteam_ = 0;
}
inline ::google::protobuf::int32 GameInflictDamage::victimteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.victimTeam)
  return victimteam_;
}
inline void GameInflictDamage::set_victimteam(::google::protobuf::int32 value) {
  
  victimteam_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.victimTeam)
}

// int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameInflictDamage::clear_attackteam() {
  attackteam_ = 0;
}
inline ::google::protobuf::int32 GameInflictDamage::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.attackTeam)
  return attackteam_;
}
inline void GameInflictDamage::set_attackteam(::google::protobuf::int32 value) {
  
  attackteam_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.attackTeam)
}

// int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
inline void GameInflictDamage::clear_weaponid() {
  weaponid_ = 0;
}
inline ::google::protobuf::int32 GameInflictDamage::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.weaponId)
  return weaponid_;
}
inline void GameInflictDamage::set_weaponid(::google::protobuf::int32 value) {
  
  weaponid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.weaponId)
}

// string damageType = 5 [(.Analytics.track_event) = true];
inline void GameInflictDamage::clear_damagetype() {
  damagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameInflictDamage::damagetype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.damageType)
  return damagetype_.GetNoArena();
}
inline void GameInflictDamage::set_damagetype(const ::std::string& value) {
  
  damagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.damageType)
}
#if LANG_CXX11
inline void GameInflictDamage::set_damagetype(::std::string&& value) {
  
  damagetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameInflictDamage.damageType)
}
#endif
inline void GameInflictDamage::set_damagetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  damagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameInflictDamage.damageType)
}
inline void GameInflictDamage::set_damagetype(const char* value, size_t size) {
  
  damagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameInflictDamage.damageType)
}
inline ::std::string* GameInflictDamage::mutable_damagetype() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameInflictDamage.damageType)
  return damagetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameInflictDamage::release_damagetype() {
  // @@protoc_insertion_point(field_release:Analytics.GameInflictDamage.damageType)
  
  return damagetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameInflictDamage::set_allocated_damagetype(::std::string* damagetype) {
  if (damagetype != NULL) {
    
  } else {
    
  }
  damagetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), damagetype);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInflictDamage.damageType)
}

// float damageAmount = 6;
inline void GameInflictDamage::clear_damageamount() {
  damageamount_ = 0;
}
inline float GameInflictDamage::damageamount() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.damageAmount)
  return damageamount_;
}
inline void GameInflictDamage::set_damageamount(float value) {
  
  damageamount_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.damageAmount)
}

// -------------------------------------------------------------------

// GameRadiusDamage

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameRadiusDamage::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameRadiusDamage::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameRadiusDamage::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameRadiusDamage.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameRadiusDamage::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameRadiusDamage.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameRadiusDamage::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameRadiusDamage.position)
  return position_;
}
inline void GameRadiusDamage::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameRadiusDamage.position)
}

// string damageType = 2;
inline void GameRadiusDamage::clear_damagetype() {
  damagetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameRadiusDamage::damagetype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRadiusDamage.damageType)
  return damagetype_.GetNoArena();
}
inline void GameRadiusDamage::set_damagetype(const ::std::string& value) {
  
  damagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameRadiusDamage.damageType)
}
#if LANG_CXX11
inline void GameRadiusDamage::set_damagetype(::std::string&& value) {
  
  damagetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameRadiusDamage.damageType)
}
#endif
inline void GameRadiusDamage::set_damagetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  damagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameRadiusDamage.damageType)
}
inline void GameRadiusDamage::set_damagetype(const char* value, size_t size) {
  
  damagetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameRadiusDamage.damageType)
}
inline ::std::string* GameRadiusDamage::mutable_damagetype() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameRadiusDamage.damageType)
  return damagetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameRadiusDamage::release_damagetype() {
  // @@protoc_insertion_point(field_release:Analytics.GameRadiusDamage.damageType)
  
  return damagetype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameRadiusDamage::set_allocated_damagetype(::std::string* damagetype) {
  if (damagetype != NULL) {
    
  } else {
    
  }
  damagetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), damagetype);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameRadiusDamage.damageType)
}

// float damageAmount = 3;
inline void GameRadiusDamage::clear_damageamount() {
  damageamount_ = 0;
}
inline float GameRadiusDamage::damageamount() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRadiusDamage.damageAmount)
  return damageamount_;
}
inline void GameRadiusDamage::set_damageamount(float value) {
  
  damageamount_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameRadiusDamage.damageAmount)
}

// float damageRadius = 4;
inline void GameRadiusDamage::clear_damageradius() {
  damageradius_ = 0;
}
inline float GameRadiusDamage::damageradius() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRadiusDamage.damageRadius)
  return damageradius_;
}
inline void GameRadiusDamage::set_damageradius(float value) {
  
  damageradius_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameRadiusDamage.damageRadius)
}

// -------------------------------------------------------------------

// GameNavigationStuck

// int32 entityId = 1;
inline void GameNavigationStuck::clear_entityid() {
  entityid_ = 0;
}
inline ::google::protobuf::int32 GameNavigationStuck::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.entityId)
  return entityid_;
}
inline void GameNavigationStuck::set_entityid(::google::protobuf::int32 value) {
  
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.entityId)
}

// .Analytics.Vec3 position = 2 [(.Analytics.point_event) = {
inline bool GameNavigationStuck::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameNavigationStuck::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameNavigationStuck::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameNavigationStuck::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameNavigationStuck.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameNavigationStuck::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameNavigationStuck.position)
  return position_;
}
inline void GameNavigationStuck::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNavigationStuck.position)
}

// -------------------------------------------------------------------

// GameVoiceMacro

// int32 entityId = 1;
inline void GameVoiceMacro::clear_entityid() {
  entityid_ = 0;
}
inline ::google::protobuf::int32 GameVoiceMacro::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameVoiceMacro.entityId)
  return entityid_;
}
inline void GameVoiceMacro::set_entityid(::google::protobuf::int32 value) {
  
  entityid_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameVoiceMacro.entityId)
}

// int32 voiceMacro = 2 [(.Analytics.enumkey) = "VOICE_MACRO", (.Analytics.track_event) = true];
inline void GameVoiceMacro::clear_voicemacro() {
  voicemacro_ = 0;
}
inline ::google::protobuf::int32 GameVoiceMacro::voicemacro() const {
  // @@protoc_insertion_point(field_get:Analytics.GameVoiceMacro.voiceMacro)
  return voicemacro_;
}
inline void GameVoiceMacro::set_voicemacro(::google::protobuf::int32 value) {
  
  voicemacro_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameVoiceMacro.voiceMacro)
}

// .Analytics.Vec3 position = 3 [(.Analytics.point_event) = {
inline bool GameVoiceMacro::has_position() const {
  return this != internal_default_instance() && position_ != NULL;
}
inline void GameVoiceMacro::clear_position() {
  if (GetArenaNoVirtual() == NULL && position_ != NULL) {
    delete position_;
  }
  position_ = NULL;
}
inline const ::Analytics::Vec3& GameVoiceMacro::position() const {
  const ::Analytics::Vec3* p = position_;
  // @@protoc_insertion_point(field_get:Analytics.GameVoiceMacro.position)
  return p != NULL ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline ::Analytics::Vec3* GameVoiceMacro::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameVoiceMacro.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::Analytics::Vec3* GameVoiceMacro::mutable_position() {
  
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Analytics.GameVoiceMacro.position)
  return position_;
}
inline void GameVoiceMacro::set_allocated_position(::Analytics::Vec3* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameVoiceMacro.position)
}

// -------------------------------------------------------------------

// GameLogMessage

// .Analytics.LogType logType = 1;
inline void GameLogMessage::clear_logtype() {
  logtype_ = 0;
}
inline ::Analytics::LogType GameLogMessage::logtype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameLogMessage.logType)
  return static_cast< ::Analytics::LogType >(logtype_);
}
inline void GameLogMessage::set_logtype(::Analytics::LogType value) {
  
  logtype_ = value;
  // @@protoc_insertion_point(field_set:Analytics.GameLogMessage.logType)
}

// string logMessage = 2;
inline void GameLogMessage::clear_logmessage() {
  logmessage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameLogMessage::logmessage() const {
  // @@protoc_insertion_point(field_get:Analytics.GameLogMessage.logMessage)
  return logmessage_.GetNoArena();
}
inline void GameLogMessage::set_logmessage(const ::std::string& value) {
  
  logmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameLogMessage.logMessage)
}
#if LANG_CXX11
inline void GameLogMessage::set_logmessage(::std::string&& value) {
  
  logmessage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameLogMessage.logMessage)
}
#endif
inline void GameLogMessage::set_logmessage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  logmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameLogMessage.logMessage)
}
inline void GameLogMessage::set_logmessage(const char* value, size_t size) {
  
  logmessage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameLogMessage.logMessage)
}
inline ::std::string* GameLogMessage::mutable_logmessage() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameLogMessage.logMessage)
  return logmessage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameLogMessage::release_logmessage() {
  // @@protoc_insertion_point(field_release:Analytics.GameLogMessage.logMessage)
  
  return logmessage_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameLogMessage::set_allocated_logmessage(::std::string* logmessage) {
  if (logmessage != NULL) {
    
  } else {
    
  }
  logmessage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), logmessage);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameLogMessage.logMessage)
}

// string logExtraInfo = 3;
inline void GameLogMessage::clear_logextrainfo() {
  logextrainfo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GameLogMessage::logextrainfo() const {
  // @@protoc_insertion_point(field_get:Analytics.GameLogMessage.logExtraInfo)
  return logextrainfo_.GetNoArena();
}
inline void GameLogMessage::set_logextrainfo(const ::std::string& value) {
  
  logextrainfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Analytics.GameLogMessage.logExtraInfo)
}
#if LANG_CXX11
inline void GameLogMessage::set_logextrainfo(::std::string&& value) {
  
  logextrainfo_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameLogMessage.logExtraInfo)
}
#endif
inline void GameLogMessage::set_logextrainfo(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  logextrainfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameLogMessage.logExtraInfo)
}
inline void GameLogMessage::set_logextrainfo(const char* value, size_t size) {
  
  logextrainfo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameLogMessage.logExtraInfo)
}
inline ::std::string* GameLogMessage::mutable_logextrainfo() {
  
  // @@protoc_insertion_point(field_mutable:Analytics.GameLogMessage.logExtraInfo)
  return logextrainfo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameLogMessage::release_logextrainfo() {
  // @@protoc_insertion_point(field_release:Analytics.GameLogMessage.logExtraInfo)
  
  return logextrainfo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameLogMessage::set_allocated_logextrainfo(::std::string* logextrainfo) {
  if (logextrainfo != NULL) {
    
  } else {
    
  }
  logextrainfo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), logextrainfo);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameLogMessage.logExtraInfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Analytics

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Analytics::RedisKeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::RedisKeyType>() {
  return ::Analytics::RedisKeyType_descriptor();
}
template <> struct is_proto_enum< ::Analytics::PrimitiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::PrimitiveType>() {
  return ::Analytics::PrimitiveType_descriptor();
}
template <> struct is_proto_enum< ::Analytics::Compression> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::Compression>() {
  return ::Analytics::Compression_descriptor();
}
template <> struct is_proto_enum< ::Analytics::LogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::LogType>() {
  return ::Analytics::LogType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_analytics_2eproto
