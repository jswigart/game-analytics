// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: analytics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_analytics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_analytics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_analytics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_analytics_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[37]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_analytics_2eproto;
namespace Analytics {
class EditorChangeValue;
class EditorChangeValueDefaultTypeInternal;
extern EditorChangeValueDefaultTypeInternal _EditorChangeValue_default_instance_;
class EditorChanges;
class EditorChangesDefaultTypeInternal;
extern EditorChangesDefaultTypeInternal _EditorChanges_default_instance_;
class Euler;
class EulerDefaultTypeInternal;
extern EulerDefaultTypeInternal _Euler_default_instance_;
class GameAssert;
class GameAssertDefaultTypeInternal;
extern GameAssertDefaultTypeInternal _GameAssert_default_instance_;
class GameCrash;
class GameCrashDefaultTypeInternal;
extern GameCrashDefaultTypeInternal _GameCrash_default_instance_;
class GameDeath;
class GameDeathDefaultTypeInternal;
extern GameDeathDefaultTypeInternal _GameDeath_default_instance_;
class GameEntityInfo;
class GameEntityInfoDefaultTypeInternal;
extern GameEntityInfoDefaultTypeInternal _GameEntityInfo_default_instance_;
class GameEntityInfo_Ammo;
class GameEntityInfo_AmmoDefaultTypeInternal;
extern GameEntityInfo_AmmoDefaultTypeInternal _GameEntityInfo_Ammo_default_instance_;
class GameEntityPosition;
class GameEntityPositionDefaultTypeInternal;
extern GameEntityPositionDefaultTypeInternal _GameEntityPosition_default_instance_;
class GameEnum;
class GameEnumDefaultTypeInternal;
extern GameEnumDefaultTypeInternal _GameEnum_default_instance_;
class GameEnum_EnumPair;
class GameEnum_EnumPairDefaultTypeInternal;
extern GameEnum_EnumPairDefaultTypeInternal _GameEnum_EnumPair_default_instance_;
class GameInflictDamage;
class GameInflictDamageDefaultTypeInternal;
extern GameInflictDamageDefaultTypeInternal _GameInflictDamage_default_instance_;
class GameInfo;
class GameInfoDefaultTypeInternal;
extern GameInfoDefaultTypeInternal _GameInfo_default_instance_;
class GameKilledSomeone;
class GameKilledSomeoneDefaultTypeInternal;
extern GameKilledSomeoneDefaultTypeInternal _GameKilledSomeone_default_instance_;
class GameLogMessage;
class GameLogMessageDefaultTypeInternal;
extern GameLogMessageDefaultTypeInternal _GameLogMessage_default_instance_;
class GameMeshData;
class GameMeshDataDefaultTypeInternal;
extern GameMeshDataDefaultTypeInternal _GameMeshData_default_instance_;
class GameNavAutoDownloaded;
class GameNavAutoDownloadedDefaultTypeInternal;
extern GameNavAutoDownloadedDefaultTypeInternal _GameNavAutoDownloaded_default_instance_;
class GameNavNotFound;
class GameNavNotFoundDefaultTypeInternal;
extern GameNavNotFoundDefaultTypeInternal _GameNavNotFound_default_instance_;
class GameNavigationStuck;
class GameNavigationStuckDefaultTypeInternal;
extern GameNavigationStuckDefaultTypeInternal _GameNavigationStuck_default_instance_;
class GameNode;
class GameNodeDefaultTypeInternal;
extern GameNodeDefaultTypeInternal _GameNode_default_instance_;
class GameRadiusDamage;
class GameRadiusDamageDefaultTypeInternal;
extern GameRadiusDamageDefaultTypeInternal _GameRadiusDamage_default_instance_;
class GameRecieveDamage;
class GameRecieveDamageDefaultTypeInternal;
extern GameRecieveDamageDefaultTypeInternal _GameRecieveDamage_default_instance_;
class GameVoiceMacro;
class GameVoiceMacroDefaultTypeInternal;
extern GameVoiceMacroDefaultTypeInternal _GameVoiceMacro_default_instance_;
class GameWeaponFired;
class GameWeaponFiredDefaultTypeInternal;
extern GameWeaponFiredDefaultTypeInternal _GameWeaponFired_default_instance_;
class Line;
class LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class LineEvent;
class LineEventDefaultTypeInternal;
extern LineEventDefaultTypeInternal _LineEvent_default_instance_;
class Material;
class MaterialDefaultTypeInternal;
extern MaterialDefaultTypeInternal _Material_default_instance_;
class Mesh;
class MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class PointEvent;
class PointEventDefaultTypeInternal;
extern PointEventDefaultTypeInternal _PointEvent_default_instance_;
class Primitive;
class PrimitiveDefaultTypeInternal;
extern PrimitiveDefaultTypeInternal _Primitive_default_instance_;
class PrimitiveOptions;
class PrimitiveOptionsDefaultTypeInternal;
extern PrimitiveOptionsDefaultTypeInternal _PrimitiveOptions_default_instance_;
class RangeF;
class RangeFDefaultTypeInternal;
extern RangeFDefaultTypeInternal _RangeF_default_instance_;
class RangeI;
class RangeIDefaultTypeInternal;
extern RangeIDefaultTypeInternal _RangeI_default_instance_;
class UTCTime;
class UTCTimeDefaultTypeInternal;
extern UTCTimeDefaultTypeInternal _UTCTime_default_instance_;
class Vec3;
class Vec3DefaultTypeInternal;
extern Vec3DefaultTypeInternal _Vec3_default_instance_;
class Vec3Color;
class Vec3ColorDefaultTypeInternal;
extern Vec3ColorDefaultTypeInternal _Vec3Color_default_instance_;
class Vec4;
class Vec4DefaultTypeInternal;
extern Vec4DefaultTypeInternal _Vec4_default_instance_;
}  // namespace Analytics
PROTOBUF_NAMESPACE_OPEN
template<> ::Analytics::EditorChangeValue* Arena::CreateMaybeMessage<::Analytics::EditorChangeValue>(Arena*);
template<> ::Analytics::EditorChanges* Arena::CreateMaybeMessage<::Analytics::EditorChanges>(Arena*);
template<> ::Analytics::Euler* Arena::CreateMaybeMessage<::Analytics::Euler>(Arena*);
template<> ::Analytics::GameAssert* Arena::CreateMaybeMessage<::Analytics::GameAssert>(Arena*);
template<> ::Analytics::GameCrash* Arena::CreateMaybeMessage<::Analytics::GameCrash>(Arena*);
template<> ::Analytics::GameDeath* Arena::CreateMaybeMessage<::Analytics::GameDeath>(Arena*);
template<> ::Analytics::GameEntityInfo* Arena::CreateMaybeMessage<::Analytics::GameEntityInfo>(Arena*);
template<> ::Analytics::GameEntityInfo_Ammo* Arena::CreateMaybeMessage<::Analytics::GameEntityInfo_Ammo>(Arena*);
template<> ::Analytics::GameEntityPosition* Arena::CreateMaybeMessage<::Analytics::GameEntityPosition>(Arena*);
template<> ::Analytics::GameEnum* Arena::CreateMaybeMessage<::Analytics::GameEnum>(Arena*);
template<> ::Analytics::GameEnum_EnumPair* Arena::CreateMaybeMessage<::Analytics::GameEnum_EnumPair>(Arena*);
template<> ::Analytics::GameInflictDamage* Arena::CreateMaybeMessage<::Analytics::GameInflictDamage>(Arena*);
template<> ::Analytics::GameInfo* Arena::CreateMaybeMessage<::Analytics::GameInfo>(Arena*);
template<> ::Analytics::GameKilledSomeone* Arena::CreateMaybeMessage<::Analytics::GameKilledSomeone>(Arena*);
template<> ::Analytics::GameLogMessage* Arena::CreateMaybeMessage<::Analytics::GameLogMessage>(Arena*);
template<> ::Analytics::GameMeshData* Arena::CreateMaybeMessage<::Analytics::GameMeshData>(Arena*);
template<> ::Analytics::GameNavAutoDownloaded* Arena::CreateMaybeMessage<::Analytics::GameNavAutoDownloaded>(Arena*);
template<> ::Analytics::GameNavNotFound* Arena::CreateMaybeMessage<::Analytics::GameNavNotFound>(Arena*);
template<> ::Analytics::GameNavigationStuck* Arena::CreateMaybeMessage<::Analytics::GameNavigationStuck>(Arena*);
template<> ::Analytics::GameNode* Arena::CreateMaybeMessage<::Analytics::GameNode>(Arena*);
template<> ::Analytics::GameRadiusDamage* Arena::CreateMaybeMessage<::Analytics::GameRadiusDamage>(Arena*);
template<> ::Analytics::GameRecieveDamage* Arena::CreateMaybeMessage<::Analytics::GameRecieveDamage>(Arena*);
template<> ::Analytics::GameVoiceMacro* Arena::CreateMaybeMessage<::Analytics::GameVoiceMacro>(Arena*);
template<> ::Analytics::GameWeaponFired* Arena::CreateMaybeMessage<::Analytics::GameWeaponFired>(Arena*);
template<> ::Analytics::Line* Arena::CreateMaybeMessage<::Analytics::Line>(Arena*);
template<> ::Analytics::LineEvent* Arena::CreateMaybeMessage<::Analytics::LineEvent>(Arena*);
template<> ::Analytics::Material* Arena::CreateMaybeMessage<::Analytics::Material>(Arena*);
template<> ::Analytics::Mesh* Arena::CreateMaybeMessage<::Analytics::Mesh>(Arena*);
template<> ::Analytics::PointEvent* Arena::CreateMaybeMessage<::Analytics::PointEvent>(Arena*);
template<> ::Analytics::Primitive* Arena::CreateMaybeMessage<::Analytics::Primitive>(Arena*);
template<> ::Analytics::PrimitiveOptions* Arena::CreateMaybeMessage<::Analytics::PrimitiveOptions>(Arena*);
template<> ::Analytics::RangeF* Arena::CreateMaybeMessage<::Analytics::RangeF>(Arena*);
template<> ::Analytics::RangeI* Arena::CreateMaybeMessage<::Analytics::RangeI>(Arena*);
template<> ::Analytics::UTCTime* Arena::CreateMaybeMessage<::Analytics::UTCTime>(Arena*);
template<> ::Analytics::Vec3* Arena::CreateMaybeMessage<::Analytics::Vec3>(Arena*);
template<> ::Analytics::Vec3Color* Arena::CreateMaybeMessage<::Analytics::Vec3Color>(Arena*);
template<> ::Analytics::Vec4* Arena::CreateMaybeMessage<::Analytics::Vec4>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Analytics {

enum RedisKeyType : int {
  UNKNOWN = 0,
  SET = 1,
  RPUSH = 2,
  HMSET = 3,
  RedisKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  RedisKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool RedisKeyType_IsValid(int value);
constexpr RedisKeyType RedisKeyType_MIN = UNKNOWN;
constexpr RedisKeyType RedisKeyType_MAX = HMSET;
constexpr int RedisKeyType_ARRAYSIZE = RedisKeyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RedisKeyType_descriptor();
template<typename T>
inline const std::string& RedisKeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RedisKeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RedisKeyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RedisKeyType_descriptor(), enum_t_value);
}
inline bool RedisKeyType_Parse(
    const std::string& name, RedisKeyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RedisKeyType>(
    RedisKeyType_descriptor(), name, value);
}
enum PrimitiveType : int {
  Triangles = 0,
  Lines = 1,
  Points = 2,
  Quad = 3,
  PrimitiveType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PrimitiveType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PrimitiveType_IsValid(int value);
constexpr PrimitiveType PrimitiveType_MIN = Triangles;
constexpr PrimitiveType PrimitiveType_MAX = Quad;
constexpr int PrimitiveType_ARRAYSIZE = PrimitiveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrimitiveType_descriptor();
template<typename T>
inline const std::string& PrimitiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrimitiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrimitiveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrimitiveType_descriptor(), enum_t_value);
}
inline bool PrimitiveType_Parse(
    const std::string& name, PrimitiveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrimitiveType>(
    PrimitiveType_descriptor(), name, value);
}
enum Compression : int {
  Compression_None = 0,
  Compression_FastLZ = 1,
  Compression_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Compression_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Compression_IsValid(int value);
constexpr Compression Compression_MIN = Compression_None;
constexpr Compression Compression_MAX = Compression_FastLZ;
constexpr int Compression_ARRAYSIZE = Compression_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Compression_descriptor();
template<typename T>
inline const std::string& Compression_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Compression>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Compression_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Compression_descriptor(), enum_t_value);
}
inline bool Compression_Parse(
    const std::string& name, Compression* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Compression>(
    Compression_descriptor(), name, value);
}
enum LogType : int {
  Log = 0,
  Warning = 1,
  Error = 3,
  LogType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  LogType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool LogType_IsValid(int value);
constexpr LogType LogType_MIN = Log;
constexpr LogType LogType_MAX = Error;
constexpr int LogType_ARRAYSIZE = LogType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LogType_descriptor();
template<typename T>
inline const std::string& LogType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LogType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LogType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LogType_descriptor(), enum_t_value);
}
inline bool LogType_Parse(
    const std::string& name, LogType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LogType>(
    LogType_descriptor(), name, value);
}
// ===================================================================

class PointEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.PointEvent) */ {
 public:
  PointEvent();
  virtual ~PointEvent();

  PointEvent(const PointEvent& from);
  PointEvent(PointEvent&& from) noexcept
    : PointEvent() {
    *this = ::std::move(from);
  }

  inline PointEvent& operator=(const PointEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PointEvent& operator=(PointEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PointEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointEvent* internal_default_instance() {
    return reinterpret_cast<const PointEvent*>(
               &_PointEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PointEvent& a, PointEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PointEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PointEvent* New() const final {
    return CreateMaybeMessage<PointEvent>(nullptr);
  }

  PointEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PointEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PointEvent& from);
  void MergeFrom(const PointEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.PointEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // string radius = 1;
  void clear_radius();
  const std::string& radius() const;
  void set_radius(const std::string& value);
  void set_radius(std::string&& value);
  void set_radius(const char* value);
  void set_radius(const char* value, size_t size);
  std::string* mutable_radius();
  std::string* release_radius();
  void set_allocated_radius(std::string* radius);
  private:
  const std::string& _internal_radius() const;
  void _internal_set_radius(const std::string& value);
  std::string* _internal_mutable_radius();
  public:

  // string weight = 2;
  void clear_weight();
  const std::string& weight() const;
  void set_weight(const std::string& value);
  void set_weight(std::string&& value);
  void set_weight(const char* value);
  void set_weight(const char* value, size_t size);
  std::string* mutable_weight();
  std::string* release_weight();
  void set_allocated_weight(std::string* weight);
  private:
  const std::string& _internal_weight() const;
  void _internal_set_weight(const std::string& value);
  std::string* _internal_mutable_weight();
  public:

  // @@protoc_insertion_point(class_scope:Analytics.PointEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr radius_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weight_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class LineEvent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.LineEvent) */ {
 public:
  LineEvent();
  virtual ~LineEvent();

  LineEvent(const LineEvent& from);
  LineEvent(LineEvent&& from) noexcept
    : LineEvent() {
    *this = ::std::move(from);
  }

  inline LineEvent& operator=(const LineEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline LineEvent& operator=(LineEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LineEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LineEvent* internal_default_instance() {
    return reinterpret_cast<const LineEvent*>(
               &_LineEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LineEvent& a, LineEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(LineEvent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LineEvent* New() const final {
    return CreateMaybeMessage<LineEvent>(nullptr);
  }

  LineEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LineEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LineEvent& from);
  void MergeFrom(const LineEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.LineEvent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRadiusFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // string radius = 1;
  void clear_radius();
  const std::string& radius() const;
  void set_radius(const std::string& value);
  void set_radius(std::string&& value);
  void set_radius(const char* value);
  void set_radius(const char* value, size_t size);
  std::string* mutable_radius();
  std::string* release_radius();
  void set_allocated_radius(std::string* radius);
  private:
  const std::string& _internal_radius() const;
  void _internal_set_radius(const std::string& value);
  std::string* _internal_mutable_radius();
  public:

  // string weight = 2;
  void clear_weight();
  const std::string& weight() const;
  void set_weight(const std::string& value);
  void set_weight(std::string&& value);
  void set_weight(const char* value);
  void set_weight(const char* value, size_t size);
  std::string* mutable_weight();
  std::string* release_weight();
  void set_allocated_weight(std::string* weight);
  private:
  const std::string& _internal_weight() const;
  void _internal_set_weight(const std::string& value);
  std::string* _internal_mutable_weight();
  public:

  // @@protoc_insertion_point(class_scope:Analytics.LineEvent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr radius_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weight_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class EditorChangeValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.EditorChangeValue) */ {
 public:
  EditorChangeValue();
  virtual ~EditorChangeValue();

  EditorChangeValue(const EditorChangeValue& from);
  EditorChangeValue(EditorChangeValue&& from) noexcept
    : EditorChangeValue() {
    *this = ::std::move(from);
  }

  inline EditorChangeValue& operator=(const EditorChangeValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditorChangeValue& operator=(EditorChangeValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EditorChangeValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EditorChangeValue* internal_default_instance() {
    return reinterpret_cast<const EditorChangeValue*>(
               &_EditorChangeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EditorChangeValue& a, EditorChangeValue& b) {
    a.Swap(&b);
  }
  inline void Swap(EditorChangeValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditorChangeValue* New() const final {
    return CreateMaybeMessage<EditorChangeValue>(nullptr);
  }

  EditorChangeValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditorChangeValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EditorChangeValue& from);
  void MergeFrom(const EditorChangeValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditorChangeValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.EditorChangeValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageTypeFieldNumber = 1,
    kFieldNameFieldNumber = 2,
    kPayloadFieldNumber = 3,
  };
  // string messageType = 1;
  void clear_messagetype();
  const std::string& messagetype() const;
  void set_messagetype(const std::string& value);
  void set_messagetype(std::string&& value);
  void set_messagetype(const char* value);
  void set_messagetype(const char* value, size_t size);
  std::string* mutable_messagetype();
  std::string* release_messagetype();
  void set_allocated_messagetype(std::string* messagetype);
  private:
  const std::string& _internal_messagetype() const;
  void _internal_set_messagetype(const std::string& value);
  std::string* _internal_mutable_messagetype();
  public:

  // string fieldName = 2;
  void clear_fieldname();
  const std::string& fieldname() const;
  void set_fieldname(const std::string& value);
  void set_fieldname(std::string&& value);
  void set_fieldname(const char* value);
  void set_fieldname(const char* value, size_t size);
  std::string* mutable_fieldname();
  std::string* release_fieldname();
  void set_allocated_fieldname(std::string* fieldname);
  private:
  const std::string& _internal_fieldname() const;
  void _internal_set_fieldname(const std::string& value);
  std::string* _internal_mutable_fieldname();
  public:

  // string payload = 3;
  void clear_payload();
  const std::string& payload() const;
  void set_payload(const std::string& value);
  void set_payload(std::string&& value);
  void set_payload(const char* value);
  void set_payload(const char* value, size_t size);
  std::string* mutable_payload();
  std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:Analytics.EditorChangeValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr messagetype_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fieldname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class EditorChanges :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.EditorChanges) */ {
 public:
  EditorChanges();
  virtual ~EditorChanges();

  EditorChanges(const EditorChanges& from);
  EditorChanges(EditorChanges&& from) noexcept
    : EditorChanges() {
    *this = ::std::move(from);
  }

  inline EditorChanges& operator=(const EditorChanges& from) {
    CopyFrom(from);
    return *this;
  }
  inline EditorChanges& operator=(EditorChanges&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EditorChanges& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EditorChanges* internal_default_instance() {
    return reinterpret_cast<const EditorChanges*>(
               &_EditorChanges_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EditorChanges& a, EditorChanges& b) {
    a.Swap(&b);
  }
  inline void Swap(EditorChanges* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EditorChanges* New() const final {
    return CreateMaybeMessage<EditorChanges>(nullptr);
  }

  EditorChanges* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EditorChanges>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EditorChanges& from);
  void MergeFrom(const EditorChanges& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EditorChanges* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.EditorChanges";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangesFieldNumber = 1,
  };
  // repeated .Analytics.EditorChangeValue changes = 1;
  int changes_size() const;
  private:
  int _internal_changes_size() const;
  public:
  void clear_changes();
  ::Analytics::EditorChangeValue* mutable_changes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::EditorChangeValue >*
      mutable_changes();
  private:
  const ::Analytics::EditorChangeValue& _internal_changes(int index) const;
  ::Analytics::EditorChangeValue* _internal_add_changes();
  public:
  const ::Analytics::EditorChangeValue& changes(int index) const;
  ::Analytics::EditorChangeValue* add_changes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::EditorChangeValue >&
      changes() const;

  // @@protoc_insertion_point(class_scope:Analytics.EditorChanges)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::EditorChangeValue > changes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class RangeF :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.RangeF) */ {
 public:
  RangeF();
  virtual ~RangeF();

  RangeF(const RangeF& from);
  RangeF(RangeF&& from) noexcept
    : RangeF() {
    *this = ::std::move(from);
  }

  inline RangeF& operator=(const RangeF& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeF& operator=(RangeF&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RangeF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeF* internal_default_instance() {
    return reinterpret_cast<const RangeF*>(
               &_RangeF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RangeF& a, RangeF& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeF* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RangeF* New() const final {
    return CreateMaybeMessage<RangeF>(nullptr);
  }

  RangeF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RangeF>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RangeF& from);
  void MergeFrom(const RangeF& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.RangeF";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // float min = 1;
  void clear_min();
  float min() const;
  void set_min(float value);
  private:
  float _internal_min() const;
  void _internal_set_min(float value);
  public:

  // float max = 2;
  void clear_max();
  float max() const;
  void set_max(float value);
  private:
  float _internal_max() const;
  void _internal_set_max(float value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.RangeF)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float min_;
  float max_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class RangeI :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.RangeI) */ {
 public:
  RangeI();
  virtual ~RangeI();

  RangeI(const RangeI& from);
  RangeI(RangeI&& from) noexcept
    : RangeI() {
    *this = ::std::move(from);
  }

  inline RangeI& operator=(const RangeI& from) {
    CopyFrom(from);
    return *this;
  }
  inline RangeI& operator=(RangeI&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RangeI& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RangeI* internal_default_instance() {
    return reinterpret_cast<const RangeI*>(
               &_RangeI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RangeI& a, RangeI& b) {
    a.Swap(&b);
  }
  inline void Swap(RangeI* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RangeI* New() const final {
    return CreateMaybeMessage<RangeI>(nullptr);
  }

  RangeI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RangeI>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RangeI& from);
  void MergeFrom(const RangeI& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RangeI* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.RangeI";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
  };
  // int32 min = 1;
  void clear_min();
  ::PROTOBUF_NAMESPACE_ID::int32 min() const;
  void set_min(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_min() const;
  void _internal_set_min(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 max = 2;
  void clear_max();
  ::PROTOBUF_NAMESPACE_ID::int32 max() const;
  void set_max(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max() const;
  void _internal_set_max(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.RangeI)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 min_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Vec3 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.Vec3) */ {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);
  Vec3(Vec3&& from) noexcept
    : Vec3() {
    *this = ::std::move(from);
  }

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3& operator=(Vec3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec3& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec3* internal_default_instance() {
    return reinterpret_cast<const Vec3*>(
               &_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Vec3& a, Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec3* New() const final {
    return CreateMaybeMessage<Vec3>(nullptr);
  }

  Vec3* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec3>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.Vec3";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.Vec3)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Vec3Color :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.Vec3Color) */ {
 public:
  Vec3Color();
  virtual ~Vec3Color();

  Vec3Color(const Vec3Color& from);
  Vec3Color(Vec3Color&& from) noexcept
    : Vec3Color() {
    *this = ::std::move(from);
  }

  inline Vec3Color& operator=(const Vec3Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec3Color& operator=(Vec3Color&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec3Color& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec3Color* internal_default_instance() {
    return reinterpret_cast<const Vec3Color*>(
               &_Vec3Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Vec3Color& a, Vec3Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec3Color* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec3Color* New() const final {
    return CreateMaybeMessage<Vec3Color>(nullptr);
  }

  Vec3Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec3Color>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec3Color& from);
  void MergeFrom(const Vec3Color& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec3Color* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.Vec3Color";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kColorFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // uint32 color = 4;
  void clear_color();
  ::PROTOBUF_NAMESPACE_ID::uint32 color() const;
  void set_color(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_color() const;
  void _internal_set_color(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.Vec3Color)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  ::PROTOBUF_NAMESPACE_ID::uint32 color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Vec4 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.Vec4) */ {
 public:
  Vec4();
  virtual ~Vec4();

  Vec4(const Vec4& from);
  Vec4(Vec4&& from) noexcept
    : Vec4() {
    *this = ::std::move(from);
  }

  inline Vec4& operator=(const Vec4& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vec4& operator=(Vec4&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Vec4& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vec4* internal_default_instance() {
    return reinterpret_cast<const Vec4*>(
               &_Vec4_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Vec4& a, Vec4& b) {
    a.Swap(&b);
  }
  inline void Swap(Vec4* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Vec4* New() const final {
    return CreateMaybeMessage<Vec4>(nullptr);
  }

  Vec4* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Vec4>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Vec4& from);
  void MergeFrom(const Vec4& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vec4* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.Vec4";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
    kWFieldNumber = 4,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float w = 4;
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.Vec4)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  float w_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Line :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.Line) */ {
 public:
  Line();
  virtual ~Line();

  Line(const Line& from);
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line& operator=(Line&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Line& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }
  inline void Swap(Line* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Line* New() const final {
    return CreateMaybeMessage<Line>(nullptr);
  }

  Line* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.Line";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kP0FieldNumber = 1,
    kP1FieldNumber = 2,
  };
  // .Analytics.Vec3 p0 = 1;
  bool has_p0() const;
  private:
  bool _internal_has_p0() const;
  public:
  void clear_p0();
  const ::Analytics::Vec3& p0() const;
  ::Analytics::Vec3* release_p0();
  ::Analytics::Vec3* mutable_p0();
  void set_allocated_p0(::Analytics::Vec3* p0);
  private:
  const ::Analytics::Vec3& _internal_p0() const;
  ::Analytics::Vec3* _internal_mutable_p0();
  public:

  // .Analytics.Vec3 p1 = 2;
  bool has_p1() const;
  private:
  bool _internal_has_p1() const;
  public:
  void clear_p1();
  const ::Analytics::Vec3& p1() const;
  ::Analytics::Vec3* release_p1();
  ::Analytics::Vec3* mutable_p1();
  void set_allocated_p1(::Analytics::Vec3* p1);
  private:
  const ::Analytics::Vec3& _internal_p1() const;
  ::Analytics::Vec3* _internal_mutable_p1();
  public:

  // @@protoc_insertion_point(class_scope:Analytics.Line)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* p0_;
  ::Analytics::Vec3* p1_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Euler :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.Euler) */ {
 public:
  Euler();
  virtual ~Euler();

  Euler(const Euler& from);
  Euler(Euler&& from) noexcept
    : Euler() {
    *this = ::std::move(from);
  }

  inline Euler& operator=(const Euler& from) {
    CopyFrom(from);
    return *this;
  }
  inline Euler& operator=(Euler&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Euler& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Euler* internal_default_instance() {
    return reinterpret_cast<const Euler*>(
               &_Euler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Euler& a, Euler& b) {
    a.Swap(&b);
  }
  inline void Swap(Euler* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Euler* New() const final {
    return CreateMaybeMessage<Euler>(nullptr);
  }

  Euler* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Euler>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Euler& from);
  void MergeFrom(const Euler& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Euler* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.Euler";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadingFieldNumber = 1,
    kPitchFieldNumber = 2,
    kRollFieldNumber = 3,
  };
  // float heading = 1;
  void clear_heading();
  float heading() const;
  void set_heading(float value);
  private:
  float _internal_heading() const;
  void _internal_set_heading(float value);
  public:

  // float pitch = 2;
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float roll = 3;
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.Euler)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float heading_;
  float pitch_;
  float roll_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Material :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.Material) */ {
 public:
  Material();
  virtual ~Material();

  Material(const Material& from);
  Material(Material&& from) noexcept
    : Material() {
    *this = ::std::move(from);
  }

  inline Material& operator=(const Material& from) {
    CopyFrom(from);
    return *this;
  }
  inline Material& operator=(Material&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Material& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Material* internal_default_instance() {
    return reinterpret_cast<const Material*>(
               &_Material_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Material& a, Material& b) {
    a.Swap(&b);
  }
  inline void Swap(Material* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Material* New() const final {
    return CreateMaybeMessage<Material>(nullptr);
  }

  Material* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Material>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Material& from);
  void MergeFrom(const Material& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Material* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.Material";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContentsFieldNumber = 2,
    kSurfaceFlagsFieldNumber = 3,
    kRenderEventsFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // uint32 contents = 2 [(.Analytics.enumkey) = "CONTENT_FLAGS", (.Analytics.enumflags) = true];
  void clear_contents();
  ::PROTOBUF_NAMESPACE_ID::uint32 contents() const;
  void set_contents(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_contents() const;
  void _internal_set_contents(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 surfaceFlags = 3 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.enumflags) = true];
  void clear_surfaceflags();
  ::PROTOBUF_NAMESPACE_ID::uint32 surfaceflags() const;
  void set_surfaceflags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_surfaceflags() const;
  void _internal_set_surfaceflags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool renderEvents = 4;
  void clear_renderevents();
  bool renderevents() const;
  void set_renderevents(bool value);
  private:
  bool _internal_renderevents() const;
  void _internal_set_renderevents(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.Material)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::uint32 contents_;
  ::PROTOBUF_NAMESPACE_ID::uint32 surfaceflags_;
  bool renderevents_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class PrimitiveOptions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.PrimitiveOptions) */ {
 public:
  PrimitiveOptions();
  virtual ~PrimitiveOptions();

  PrimitiveOptions(const PrimitiveOptions& from);
  PrimitiveOptions(PrimitiveOptions&& from) noexcept
    : PrimitiveOptions() {
    *this = ::std::move(from);
  }

  inline PrimitiveOptions& operator=(const PrimitiveOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrimitiveOptions& operator=(PrimitiveOptions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PrimitiveOptions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrimitiveOptions* internal_default_instance() {
    return reinterpret_cast<const PrimitiveOptions*>(
               &_PrimitiveOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PrimitiveOptions& a, PrimitiveOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(PrimitiveOptions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrimitiveOptions* New() const final {
    return CreateMaybeMessage<PrimitiveOptions>(nullptr);
  }

  PrimitiveOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrimitiveOptions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PrimitiveOptions& from);
  void MergeFrom(const PrimitiveOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrimitiveOptions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.PrimitiveOptions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPartIndexFieldNumber = 1,
    kOverrideSurfaceFlagsFieldNumber = 2,
  };
  // uint32 partIndex = 1 [(.Analytics.editable_key) = true];
  void clear_partindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 partindex() const;
  void set_partindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_partindex() const;
  void _internal_set_partindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 overrideSurfaceFlags = 2 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.editable) = true, (.Analytics.enumflags) = true];
  void clear_overridesurfaceflags();
  ::PROTOBUF_NAMESPACE_ID::uint32 overridesurfaceflags() const;
  void set_overridesurfaceflags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_overridesurfaceflags() const;
  void _internal_set_overridesurfaceflags(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.PrimitiveOptions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 partindex_;
  ::PROTOBUF_NAMESPACE_ID::uint32 overridesurfaceflags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Primitive :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.Primitive) */ {
 public:
  Primitive();
  virtual ~Primitive();

  Primitive(const Primitive& from);
  Primitive(Primitive&& from) noexcept
    : Primitive() {
    *this = ::std::move(from);
  }

  inline Primitive& operator=(const Primitive& from) {
    CopyFrom(from);
    return *this;
  }
  inline Primitive& operator=(Primitive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Primitive& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Primitive* internal_default_instance() {
    return reinterpret_cast<const Primitive*>(
               &_Primitive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Primitive& a, Primitive& b) {
    a.Swap(&b);
  }
  inline void Swap(Primitive* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Primitive* New() const final {
    return CreateMaybeMessage<Primitive>(nullptr);
  }

  Primitive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Primitive>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Primitive& from);
  void MergeFrom(const Primitive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Primitive* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.Primitive";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 5,
    kOptionsFieldNumber = 3,
    kTypeFieldNumber = 1,
    kMaterialIndexFieldNumber = 2,
    kSizeFieldNumber = 4,
  };
  // repeated .Analytics.Vec3Color vertices = 5;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;
  public:
  void clear_vertices();
  ::Analytics::Vec3Color* mutable_vertices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Vec3Color >*
      mutable_vertices();
  private:
  const ::Analytics::Vec3Color& _internal_vertices(int index) const;
  ::Analytics::Vec3Color* _internal_add_vertices();
  public:
  const ::Analytics::Vec3Color& vertices(int index) const;
  ::Analytics::Vec3Color* add_vertices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Vec3Color >&
      vertices() const;

  // .Analytics.PrimitiveOptions options = 3;
  bool has_options() const;
  private:
  bool _internal_has_options() const;
  public:
  void clear_options();
  const ::Analytics::PrimitiveOptions& options() const;
  ::Analytics::PrimitiveOptions* release_options();
  ::Analytics::PrimitiveOptions* mutable_options();
  void set_allocated_options(::Analytics::PrimitiveOptions* options);
  private:
  const ::Analytics::PrimitiveOptions& _internal_options() const;
  ::Analytics::PrimitiveOptions* _internal_mutable_options();
  public:

  // .Analytics.PrimitiveType type = 1;
  void clear_type();
  ::Analytics::PrimitiveType type() const;
  void set_type(::Analytics::PrimitiveType value);
  private:
  ::Analytics::PrimitiveType _internal_type() const;
  void _internal_set_type(::Analytics::PrimitiveType value);
  public:

  // uint32 materialIndex = 2;
  void clear_materialindex();
  ::PROTOBUF_NAMESPACE_ID::uint32 materialindex() const;
  void set_materialindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_materialindex() const;
  void _internal_set_materialindex(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float size = 4;
  void clear_size();
  float size() const;
  void set_size(float value);
  private:
  float _internal_size() const;
  void _internal_set_size(float value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.Primitive)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Vec3Color > vertices_;
  ::Analytics::PrimitiveOptions* options_;
  int type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 materialindex_;
  float size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class Mesh :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.Mesh) */ {
 public:
  Mesh();
  virtual ~Mesh();

  Mesh(const Mesh& from);
  Mesh(Mesh&& from) noexcept
    : Mesh() {
    *this = ::std::move(from);
  }

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh& operator=(Mesh&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Mesh& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
               &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Mesh& a, Mesh& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Mesh* New() const final {
    return CreateMaybeMessage<Mesh>(nullptr);
  }

  Mesh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Mesh>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Mesh& from);
  void MergeFrom(const Mesh& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mesh* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.Mesh";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrimitivesFieldNumber = 1,
    kMaterialsFieldNumber = 2,
    kNameFieldNumber = 3,
  };
  // repeated .Analytics.Primitive primitives = 1;
  int primitives_size() const;
  private:
  int _internal_primitives_size() const;
  public:
  void clear_primitives();
  ::Analytics::Primitive* mutable_primitives(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Primitive >*
      mutable_primitives();
  private:
  const ::Analytics::Primitive& _internal_primitives(int index) const;
  ::Analytics::Primitive* _internal_add_primitives();
  public:
  const ::Analytics::Primitive& primitives(int index) const;
  ::Analytics::Primitive* add_primitives();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Primitive >&
      primitives() const;

  // repeated .Analytics.Material materials = 2;
  int materials_size() const;
  private:
  int _internal_materials_size() const;
  public:
  void clear_materials();
  ::Analytics::Material* mutable_materials(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Material >*
      mutable_materials();
  private:
  const ::Analytics::Material& _internal_materials(int index) const;
  ::Analytics::Material* _internal_add_materials();
  public:
  const ::Analytics::Material& materials(int index) const;
  ::Analytics::Material* add_materials();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Material >&
      materials() const;

  // string name = 3;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Analytics.Mesh)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Primitive > primitives_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Material > materials_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class UTCTime :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.UTCTime) */ {
 public:
  UTCTime();
  virtual ~UTCTime();

  UTCTime(const UTCTime& from);
  UTCTime(UTCTime&& from) noexcept
    : UTCTime() {
    *this = ::std::move(from);
  }

  inline UTCTime& operator=(const UTCTime& from) {
    CopyFrom(from);
    return *this;
  }
  inline UTCTime& operator=(UTCTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UTCTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UTCTime* internal_default_instance() {
    return reinterpret_cast<const UTCTime*>(
               &_UTCTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(UTCTime& a, UTCTime& b) {
    a.Swap(&b);
  }
  inline void Swap(UTCTime* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UTCTime* New() const final {
    return CreateMaybeMessage<UTCTime>(nullptr);
  }

  UTCTime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UTCTime>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UTCTime& from);
  void MergeFrom(const UTCTime& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UTCTime* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.UTCTime";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHourFieldNumber = 1,
    kMinuteFieldNumber = 2,
    kSecondFieldNumber = 3,
    kDayFieldNumber = 4,
    kMonthFieldNumber = 5,
    kYearFieldNumber = 6,
  };
  // int32 hour = 1;
  void clear_hour();
  ::PROTOBUF_NAMESPACE_ID::int32 hour() const;
  void set_hour(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hour() const;
  void _internal_set_hour(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 minute = 2;
  void clear_minute();
  ::PROTOBUF_NAMESPACE_ID::int32 minute() const;
  void set_minute(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minute() const;
  void _internal_set_minute(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 second = 3;
  void clear_second();
  ::PROTOBUF_NAMESPACE_ID::int32 second() const;
  void set_second(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_second() const;
  void _internal_set_second(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 day = 4;
  void clear_day();
  ::PROTOBUF_NAMESPACE_ID::int32 day() const;
  void set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_day() const;
  void _internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 month = 5;
  void clear_month();
  ::PROTOBUF_NAMESPACE_ID::int32 month() const;
  void set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_month() const;
  void _internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 year = 6;
  void clear_year();
  ::PROTOBUF_NAMESPACE_ID::int32 year() const;
  void set_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_year() const;
  void _internal_set_year(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.UTCTime)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 hour_;
  ::PROTOBUF_NAMESPACE_ID::int32 minute_;
  ::PROTOBUF_NAMESPACE_ID::int32 second_;
  ::PROTOBUF_NAMESPACE_ID::int32 day_;
  ::PROTOBUF_NAMESPACE_ID::int32 month_;
  ::PROTOBUF_NAMESPACE_ID::int32 year_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameInfo) */ {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);
  GameInfo(GameInfo&& from) noexcept
    : GameInfo() {
    *this = ::std::move(from);
  }

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameInfo& operator=(GameInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInfo* internal_default_instance() {
    return reinterpret_cast<const GameInfo*>(
               &_GameInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(GameInfo& a, GameInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GameInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameInfo* New() const final {
    return CreateMaybeMessage<GameInfo>(nullptr);
  }

  GameInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameInfo& from);
  void MergeFrom(const GameInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapNameFieldNumber = 2,
    kGameNameFieldNumber = 3,
    kGameVersionFieldNumber = 4,
    kTimeStampFieldNumber = 1,
  };
  // string mapName = 2;
  void clear_mapname();
  const std::string& mapname() const;
  void set_mapname(const std::string& value);
  void set_mapname(std::string&& value);
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  std::string* mutable_mapname();
  std::string* release_mapname();
  void set_allocated_mapname(std::string* mapname);
  private:
  const std::string& _internal_mapname() const;
  void _internal_set_mapname(const std::string& value);
  std::string* _internal_mutable_mapname();
  public:

  // string gameName = 3;
  void clear_gamename();
  const std::string& gamename() const;
  void set_gamename(const std::string& value);
  void set_gamename(std::string&& value);
  void set_gamename(const char* value);
  void set_gamename(const char* value, size_t size);
  std::string* mutable_gamename();
  std::string* release_gamename();
  void set_allocated_gamename(std::string* gamename);
  private:
  const std::string& _internal_gamename() const;
  void _internal_set_gamename(const std::string& value);
  std::string* _internal_mutable_gamename();
  public:

  // string gameVersion = 4;
  void clear_gameversion();
  const std::string& gameversion() const;
  void set_gameversion(const std::string& value);
  void set_gameversion(std::string&& value);
  void set_gameversion(const char* value);
  void set_gameversion(const char* value, size_t size);
  std::string* mutable_gameversion();
  std::string* release_gameversion();
  void set_allocated_gameversion(std::string* gameversion);
  private:
  const std::string& _internal_gameversion() const;
  void _internal_set_gameversion(const std::string& value);
  std::string* _internal_mutable_gameversion();
  public:

  // .Analytics.UTCTime timeStamp = 1;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::Analytics::UTCTime& timestamp() const;
  ::Analytics::UTCTime* release_timestamp();
  ::Analytics::UTCTime* mutable_timestamp();
  void set_allocated_timestamp(::Analytics::UTCTime* timestamp);
  private:
  const ::Analytics::UTCTime& _internal_timestamp() const;
  ::Analytics::UTCTime* _internal_mutable_timestamp();
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gameversion_;
  ::Analytics::UTCTime* timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEnum_EnumPair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEnum.EnumPair) */ {
 public:
  GameEnum_EnumPair();
  virtual ~GameEnum_EnumPair();

  GameEnum_EnumPair(const GameEnum_EnumPair& from);
  GameEnum_EnumPair(GameEnum_EnumPair&& from) noexcept
    : GameEnum_EnumPair() {
    *this = ::std::move(from);
  }

  inline GameEnum_EnumPair& operator=(const GameEnum_EnumPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEnum_EnumPair& operator=(GameEnum_EnumPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameEnum_EnumPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEnum_EnumPair* internal_default_instance() {
    return reinterpret_cast<const GameEnum_EnumPair*>(
               &_GameEnum_EnumPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(GameEnum_EnumPair& a, GameEnum_EnumPair& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEnum_EnumPair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameEnum_EnumPair* New() const final {
    return CreateMaybeMessage<GameEnum_EnumPair>(nullptr);
  }

  GameEnum_EnumPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameEnum_EnumPair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameEnum_EnumPair& from);
  void MergeFrom(const GameEnum_EnumPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEnum_EnumPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameEnum.EnumPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int64 value = 2;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameEnum.EnumPair)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEnum :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEnum) */ {
 public:
  GameEnum();
  virtual ~GameEnum();

  GameEnum(const GameEnum& from);
  GameEnum(GameEnum&& from) noexcept
    : GameEnum() {
    *this = ::std::move(from);
  }

  inline GameEnum& operator=(const GameEnum& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEnum& operator=(GameEnum&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameEnum& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEnum* internal_default_instance() {
    return reinterpret_cast<const GameEnum*>(
               &_GameEnum_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GameEnum& a, GameEnum& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEnum* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameEnum* New() const final {
    return CreateMaybeMessage<GameEnum>(nullptr);
  }

  GameEnum* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameEnum>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameEnum& from);
  void MergeFrom(const GameEnum& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEnum* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameEnum";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GameEnum_EnumPair EnumPair;

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 1,
    kEnumnameFieldNumber = 2,
    kIsbitfieldFieldNumber = 3,
  };
  // repeated .Analytics.GameEnum.EnumPair values = 1;
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  ::Analytics::GameEnum_EnumPair* mutable_values(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEnum_EnumPair >*
      mutable_values();
  private:
  const ::Analytics::GameEnum_EnumPair& _internal_values(int index) const;
  ::Analytics::GameEnum_EnumPair* _internal_add_values();
  public:
  const ::Analytics::GameEnum_EnumPair& values(int index) const;
  ::Analytics::GameEnum_EnumPair* add_values();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEnum_EnumPair >&
      values() const;

  // string enumname = 2;
  void clear_enumname();
  const std::string& enumname() const;
  void set_enumname(const std::string& value);
  void set_enumname(std::string&& value);
  void set_enumname(const char* value);
  void set_enumname(const char* value, size_t size);
  std::string* mutable_enumname();
  std::string* release_enumname();
  void set_allocated_enumname(std::string* enumname);
  private:
  const std::string& _internal_enumname() const;
  void _internal_set_enumname(const std::string& value);
  std::string* _internal_mutable_enumname();
  public:

  // bool isbitfield = 3;
  void clear_isbitfield();
  bool isbitfield() const;
  void set_isbitfield(bool value);
  private:
  bool _internal_isbitfield() const;
  void _internal_set_isbitfield(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameEnum)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEnum_EnumPair > values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr enumname_;
  bool isbitfield_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameNavNotFound :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameNavNotFound) */ {
 public:
  GameNavNotFound();
  virtual ~GameNavNotFound();

  GameNavNotFound(const GameNavNotFound& from);
  GameNavNotFound(GameNavNotFound&& from) noexcept
    : GameNavNotFound() {
    *this = ::std::move(from);
  }

  inline GameNavNotFound& operator=(const GameNavNotFound& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameNavNotFound& operator=(GameNavNotFound&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameNavNotFound& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameNavNotFound* internal_default_instance() {
    return reinterpret_cast<const GameNavNotFound*>(
               &_GameNavNotFound_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GameNavNotFound& a, GameNavNotFound& b) {
    a.Swap(&b);
  }
  inline void Swap(GameNavNotFound* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameNavNotFound* New() const final {
    return CreateMaybeMessage<GameNavNotFound>(nullptr);
  }

  GameNavNotFound* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameNavNotFound>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameNavNotFound& from);
  void MergeFrom(const GameNavNotFound& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameNavNotFound* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameNavNotFound";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapNameFieldNumber = 1,
  };
  // string mapName = 1;
  void clear_mapname();
  const std::string& mapname() const;
  void set_mapname(const std::string& value);
  void set_mapname(std::string&& value);
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  std::string* mutable_mapname();
  std::string* release_mapname();
  void set_allocated_mapname(std::string* mapname);
  private:
  const std::string& _internal_mapname() const;
  void _internal_set_mapname(const std::string& value);
  std::string* _internal_mutable_mapname();
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameNavNotFound)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameNavAutoDownloaded :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameNavAutoDownloaded) */ {
 public:
  GameNavAutoDownloaded();
  virtual ~GameNavAutoDownloaded();

  GameNavAutoDownloaded(const GameNavAutoDownloaded& from);
  GameNavAutoDownloaded(GameNavAutoDownloaded&& from) noexcept
    : GameNavAutoDownloaded() {
    *this = ::std::move(from);
  }

  inline GameNavAutoDownloaded& operator=(const GameNavAutoDownloaded& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameNavAutoDownloaded& operator=(GameNavAutoDownloaded&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameNavAutoDownloaded& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameNavAutoDownloaded* internal_default_instance() {
    return reinterpret_cast<const GameNavAutoDownloaded*>(
               &_GameNavAutoDownloaded_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(GameNavAutoDownloaded& a, GameNavAutoDownloaded& b) {
    a.Swap(&b);
  }
  inline void Swap(GameNavAutoDownloaded* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameNavAutoDownloaded* New() const final {
    return CreateMaybeMessage<GameNavAutoDownloaded>(nullptr);
  }

  GameNavAutoDownloaded* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameNavAutoDownloaded>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameNavAutoDownloaded& from);
  void MergeFrom(const GameNavAutoDownloaded& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameNavAutoDownloaded* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameNavAutoDownloaded";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMapNameFieldNumber = 1,
  };
  // string mapName = 1;
  void clear_mapname();
  const std::string& mapname() const;
  void set_mapname(const std::string& value);
  void set_mapname(std::string&& value);
  void set_mapname(const char* value);
  void set_mapname(const char* value, size_t size);
  std::string* mutable_mapname();
  std::string* release_mapname();
  void set_allocated_mapname(std::string* mapname);
  private:
  const std::string& _internal_mapname() const;
  void _internal_set_mapname(const std::string& value);
  std::string* _internal_mutable_mapname();
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameNavAutoDownloaded)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mapname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameAssert :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameAssert) */ {
 public:
  GameAssert();
  virtual ~GameAssert();

  GameAssert(const GameAssert& from);
  GameAssert(GameAssert&& from) noexcept
    : GameAssert() {
    *this = ::std::move(from);
  }

  inline GameAssert& operator=(const GameAssert& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameAssert& operator=(GameAssert&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameAssert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameAssert* internal_default_instance() {
    return reinterpret_cast<const GameAssert*>(
               &_GameAssert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(GameAssert& a, GameAssert& b) {
    a.Swap(&b);
  }
  inline void Swap(GameAssert* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameAssert* New() const final {
    return CreateMaybeMessage<GameAssert>(nullptr);
  }

  GameAssert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameAssert>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameAssert& from);
  void MergeFrom(const GameAssert& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameAssert* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameAssert";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionFieldNumber = 1,
    kFileFieldNumber = 2,
    kLineFieldNumber = 3,
  };
  // string condition = 1;
  void clear_condition();
  const std::string& condition() const;
  void set_condition(const std::string& value);
  void set_condition(std::string&& value);
  void set_condition(const char* value);
  void set_condition(const char* value, size_t size);
  std::string* mutable_condition();
  std::string* release_condition();
  void set_allocated_condition(std::string* condition);
  private:
  const std::string& _internal_condition() const;
  void _internal_set_condition(const std::string& value);
  std::string* _internal_mutable_condition();
  public:

  // string file = 2;
  void clear_file();
  const std::string& file() const;
  void set_file(const std::string& value);
  void set_file(std::string&& value);
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  std::string* mutable_file();
  std::string* release_file();
  void set_allocated_file(std::string* file);
  private:
  const std::string& _internal_file() const;
  void _internal_set_file(const std::string& value);
  std::string* _internal_mutable_file();
  public:

  // int32 line = 3;
  void clear_line();
  ::PROTOBUF_NAMESPACE_ID::int32 line() const;
  void set_line(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_line() const;
  void _internal_set_line(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameAssert)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr condition_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_;
  ::PROTOBUF_NAMESPACE_ID::int32 line_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameCrash :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameCrash) */ {
 public:
  GameCrash();
  virtual ~GameCrash();

  GameCrash(const GameCrash& from);
  GameCrash(GameCrash&& from) noexcept
    : GameCrash() {
    *this = ::std::move(from);
  }

  inline GameCrash& operator=(const GameCrash& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameCrash& operator=(GameCrash&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameCrash& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameCrash* internal_default_instance() {
    return reinterpret_cast<const GameCrash*>(
               &_GameCrash_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(GameCrash& a, GameCrash& b) {
    a.Swap(&b);
  }
  inline void Swap(GameCrash* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameCrash* New() const final {
    return CreateMaybeMessage<GameCrash>(nullptr);
  }

  GameCrash* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameCrash>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameCrash& from);
  void MergeFrom(const GameCrash& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameCrash* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameCrash";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // string info = 1;
  void clear_info();
  const std::string& info() const;
  void set_info(const std::string& value);
  void set_info(std::string&& value);
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  std::string* mutable_info();
  std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameCrash)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameMeshData :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameMeshData) */ {
 public:
  GameMeshData();
  virtual ~GameMeshData();

  GameMeshData(const GameMeshData& from);
  GameMeshData(GameMeshData&& from) noexcept
    : GameMeshData() {
    *this = ::std::move(from);
  }

  inline GameMeshData& operator=(const GameMeshData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameMeshData& operator=(GameMeshData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameMeshData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameMeshData* internal_default_instance() {
    return reinterpret_cast<const GameMeshData*>(
               &_GameMeshData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GameMeshData& a, GameMeshData& b) {
    a.Swap(&b);
  }
  inline void Swap(GameMeshData* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameMeshData* New() const final {
    return CreateMaybeMessage<GameMeshData>(nullptr);
  }

  GameMeshData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameMeshData>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameMeshData& from);
  void MergeFrom(const GameMeshData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameMeshData* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameMeshData";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNameFieldNumber = 2,
    kModelBytesFieldNumber = 3,
    kCompressionTypeFieldNumber = 1,
    kModelBytesUncompressedFieldNumber = 4,
  };
  // string modelName = 2;
  void clear_modelname();
  const std::string& modelname() const;
  void set_modelname(const std::string& value);
  void set_modelname(std::string&& value);
  void set_modelname(const char* value);
  void set_modelname(const char* value, size_t size);
  std::string* mutable_modelname();
  std::string* release_modelname();
  void set_allocated_modelname(std::string* modelname);
  private:
  const std::string& _internal_modelname() const;
  void _internal_set_modelname(const std::string& value);
  std::string* _internal_mutable_modelname();
  public:

  // bytes modelBytes = 3;
  void clear_modelbytes();
  const std::string& modelbytes() const;
  void set_modelbytes(const std::string& value);
  void set_modelbytes(std::string&& value);
  void set_modelbytes(const char* value);
  void set_modelbytes(const void* value, size_t size);
  std::string* mutable_modelbytes();
  std::string* release_modelbytes();
  void set_allocated_modelbytes(std::string* modelbytes);
  private:
  const std::string& _internal_modelbytes() const;
  void _internal_set_modelbytes(const std::string& value);
  std::string* _internal_mutable_modelbytes();
  public:

  // .Analytics.Compression compressionType = 1;
  void clear_compressiontype();
  ::Analytics::Compression compressiontype() const;
  void set_compressiontype(::Analytics::Compression value);
  private:
  ::Analytics::Compression _internal_compressiontype() const;
  void _internal_set_compressiontype(::Analytics::Compression value);
  public:

  // uint32 modelBytesUncompressed = 4;
  void clear_modelbytesuncompressed();
  ::PROTOBUF_NAMESPACE_ID::uint32 modelbytesuncompressed() const;
  void set_modelbytesuncompressed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_modelbytesuncompressed() const;
  void _internal_set_modelbytesuncompressed(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameMeshData)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modelbytes_;
  int compressiontype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 modelbytesuncompressed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEntityInfo_Ammo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEntityInfo.Ammo) */ {
 public:
  GameEntityInfo_Ammo();
  virtual ~GameEntityInfo_Ammo();

  GameEntityInfo_Ammo(const GameEntityInfo_Ammo& from);
  GameEntityInfo_Ammo(GameEntityInfo_Ammo&& from) noexcept
    : GameEntityInfo_Ammo() {
    *this = ::std::move(from);
  }

  inline GameEntityInfo_Ammo& operator=(const GameEntityInfo_Ammo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEntityInfo_Ammo& operator=(GameEntityInfo_Ammo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameEntityInfo_Ammo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEntityInfo_Ammo* internal_default_instance() {
    return reinterpret_cast<const GameEntityInfo_Ammo*>(
               &_GameEntityInfo_Ammo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(GameEntityInfo_Ammo& a, GameEntityInfo_Ammo& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEntityInfo_Ammo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameEntityInfo_Ammo* New() const final {
    return CreateMaybeMessage<GameEntityInfo_Ammo>(nullptr);
  }

  GameEntityInfo_Ammo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameEntityInfo_Ammo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameEntityInfo_Ammo& from);
  void MergeFrom(const GameEntityInfo_Ammo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEntityInfo_Ammo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameEntityInfo.Ammo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAmmoTypeFieldNumber = 1,
    kAmmoCountFieldNumber = 2,
  };
  // uint32 ammoType = 1 [(.Analytics.enumkey) = "AMMO_TYPE"];
  void clear_ammotype();
  ::PROTOBUF_NAMESPACE_ID::uint32 ammotype() const;
  void set_ammotype(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ammotype() const;
  void _internal_set_ammotype(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 ammoCount = 2;
  void clear_ammocount();
  ::PROTOBUF_NAMESPACE_ID::uint32 ammocount() const;
  void set_ammocount(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_ammocount() const;
  void _internal_set_ammocount(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityInfo.Ammo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ammotype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ammocount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEntityInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEntityInfo) */ {
 public:
  GameEntityInfo();
  virtual ~GameEntityInfo();

  GameEntityInfo(const GameEntityInfo& from);
  GameEntityInfo(GameEntityInfo&& from) noexcept
    : GameEntityInfo() {
    *this = ::std::move(from);
  }

  inline GameEntityInfo& operator=(const GameEntityInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEntityInfo& operator=(GameEntityInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameEntityInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEntityInfo* internal_default_instance() {
    return reinterpret_cast<const GameEntityInfo*>(
               &_GameEntityInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(GameEntityInfo& a, GameEntityInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEntityInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameEntityInfo* New() const final {
    return CreateMaybeMessage<GameEntityInfo>(nullptr);
  }

  GameEntityInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameEntityInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameEntityInfo& from);
  void MergeFrom(const GameEntityInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEntityInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameEntityInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef GameEntityInfo_Ammo Ammo;

  // accessors -------------------------------------------------------

  enum : int {
    kAmmoFieldNumber = 19,
    kEntityNameFieldNumber = 1,
    kEulerRotationFieldNumber = 11,
    kPositionFieldNumber = 12,
    kEyeOffsetFieldNumber = 13,
    kEyeDirFieldNumber = 14,
    kHealthFieldNumber = 15,
    kArmorFieldNumber = 16,
    kBoundsMinFieldNumber = 17,
    kBoundsMaxFieldNumber = 18,
    kEntityIndexFieldNumber = 2,
    kEntitySerialFieldNumber = 3,
    kGroupIdFieldNumber = 4,
    kClassIdFieldNumber = 5,
    kEntityFlagsFieldNumber = 7,
    kTeamFieldNumber = 6,
    kCategoryFieldNumber = 8,
    kNavFlagsFieldNumber = 10,
    kPowerUpsFieldNumber = 9,
    kDeletedFieldNumber = 1000,
  };
  // repeated .Analytics.GameEntityInfo.Ammo ammo = 19;
  int ammo_size() const;
  private:
  int _internal_ammo_size() const;
  public:
  void clear_ammo();
  ::Analytics::GameEntityInfo_Ammo* mutable_ammo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >*
      mutable_ammo();
  private:
  const ::Analytics::GameEntityInfo_Ammo& _internal_ammo(int index) const;
  ::Analytics::GameEntityInfo_Ammo* _internal_add_ammo();
  public:
  const ::Analytics::GameEntityInfo_Ammo& ammo(int index) const;
  ::Analytics::GameEntityInfo_Ammo* add_ammo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >&
      ammo() const;

  // string entityName = 1;
  void clear_entityname();
  const std::string& entityname() const;
  void set_entityname(const std::string& value);
  void set_entityname(std::string&& value);
  void set_entityname(const char* value);
  void set_entityname(const char* value, size_t size);
  std::string* mutable_entityname();
  std::string* release_entityname();
  void set_allocated_entityname(std::string* entityname);
  private:
  const std::string& _internal_entityname() const;
  void _internal_set_entityname(const std::string& value);
  std::string* _internal_mutable_entityname();
  public:

  // .Analytics.Vec3 eulerRotation = 11 [(.Analytics.hidden) = true];
  bool has_eulerrotation() const;
  private:
  bool _internal_has_eulerrotation() const;
  public:
  void clear_eulerrotation();
  const ::Analytics::Vec3& eulerrotation() const;
  ::Analytics::Vec3* release_eulerrotation();
  ::Analytics::Vec3* mutable_eulerrotation();
  void set_allocated_eulerrotation(::Analytics::Vec3* eulerrotation);
  private:
  const ::Analytics::Vec3& _internal_eulerrotation() const;
  ::Analytics::Vec3* _internal_mutable_eulerrotation();
  public:

  // .Analytics.Vec3 position = 12 [(.Analytics.hidden) = true];
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // .Analytics.Vec3 eyeOffset = 13 [(.Analytics.hidden) = true];
  bool has_eyeoffset() const;
  private:
  bool _internal_has_eyeoffset() const;
  public:
  void clear_eyeoffset();
  const ::Analytics::Vec3& eyeoffset() const;
  ::Analytics::Vec3* release_eyeoffset();
  ::Analytics::Vec3* mutable_eyeoffset();
  void set_allocated_eyeoffset(::Analytics::Vec3* eyeoffset);
  private:
  const ::Analytics::Vec3& _internal_eyeoffset() const;
  ::Analytics::Vec3* _internal_mutable_eyeoffset();
  public:

  // .Analytics.Vec3 eyeDir = 14 [(.Analytics.hidden) = true];
  bool has_eyedir() const;
  private:
  bool _internal_has_eyedir() const;
  public:
  void clear_eyedir();
  const ::Analytics::Vec3& eyedir() const;
  ::Analytics::Vec3* release_eyedir();
  ::Analytics::Vec3* mutable_eyedir();
  void set_allocated_eyedir(::Analytics::Vec3* eyedir);
  private:
  const ::Analytics::Vec3& _internal_eyedir() const;
  ::Analytics::Vec3* _internal_mutable_eyedir();
  public:

  // .Analytics.RangeI health = 15;
  bool has_health() const;
  private:
  bool _internal_has_health() const;
  public:
  void clear_health();
  const ::Analytics::RangeI& health() const;
  ::Analytics::RangeI* release_health();
  ::Analytics::RangeI* mutable_health();
  void set_allocated_health(::Analytics::RangeI* health);
  private:
  const ::Analytics::RangeI& _internal_health() const;
  ::Analytics::RangeI* _internal_mutable_health();
  public:

  // .Analytics.RangeI armor = 16;
  bool has_armor() const;
  private:
  bool _internal_has_armor() const;
  public:
  void clear_armor();
  const ::Analytics::RangeI& armor() const;
  ::Analytics::RangeI* release_armor();
  ::Analytics::RangeI* mutable_armor();
  void set_allocated_armor(::Analytics::RangeI* armor);
  private:
  const ::Analytics::RangeI& _internal_armor() const;
  ::Analytics::RangeI* _internal_mutable_armor();
  public:

  // .Analytics.Vec3 boundsMin = 17;
  bool has_boundsmin() const;
  private:
  bool _internal_has_boundsmin() const;
  public:
  void clear_boundsmin();
  const ::Analytics::Vec3& boundsmin() const;
  ::Analytics::Vec3* release_boundsmin();
  ::Analytics::Vec3* mutable_boundsmin();
  void set_allocated_boundsmin(::Analytics::Vec3* boundsmin);
  private:
  const ::Analytics::Vec3& _internal_boundsmin() const;
  ::Analytics::Vec3* _internal_mutable_boundsmin();
  public:

  // .Analytics.Vec3 boundsMax = 18;
  bool has_boundsmax() const;
  private:
  bool _internal_has_boundsmax() const;
  public:
  void clear_boundsmax();
  const ::Analytics::Vec3& boundsmax() const;
  ::Analytics::Vec3* release_boundsmax();
  ::Analytics::Vec3* mutable_boundsmax();
  void set_allocated_boundsmax(::Analytics::Vec3* boundsmax);
  private:
  const ::Analytics::Vec3& _internal_boundsmax() const;
  ::Analytics::Vec3* _internal_mutable_boundsmax();
  public:

  // int32 entityIndex = 2;
  void clear_entityindex();
  ::PROTOBUF_NAMESPACE_ID::int32 entityindex() const;
  void set_entityindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_entityindex() const;
  void _internal_set_entityindex(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 entitySerial = 3;
  void clear_entityserial();
  ::PROTOBUF_NAMESPACE_ID::int32 entityserial() const;
  void set_entityserial(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_entityserial() const;
  void _internal_set_entityserial(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 groupId = 4 [(.Analytics.enumkey) = "GROUP_ID"];
  void clear_groupid();
  ::PROTOBUF_NAMESPACE_ID::int32 groupid() const;
  void set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_groupid() const;
  void _internal_set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 classId = 5 [(.Analytics.enumkey) = "CLASS_ID"];
  void clear_classid();
  ::PROTOBUF_NAMESPACE_ID::int32 classid() const;
  void set_classid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_classid() const;
  void _internal_set_classid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 entityFlags = 7 [(.Analytics.enumkey) = "ENTITY_FLAGS", (.Analytics.enumflagsindexed) = true];
  void clear_entityflags();
  ::PROTOBUF_NAMESPACE_ID::int64 entityflags() const;
  void set_entityflags(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_entityflags() const;
  void _internal_set_entityflags(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 team = 6 [(.Analytics.enumkey) = "TEAM_ID"];
  void clear_team();
  ::PROTOBUF_NAMESPACE_ID::int32 team() const;
  void set_team(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_team() const;
  void _internal_set_team(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 category = 8 [(.Analytics.enumkey) = "CATEGORY_ID", (.Analytics.enumflagsindexed) = true];
  void clear_category();
  ::PROTOBUF_NAMESPACE_ID::int32 category() const;
  void set_category(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_category() const;
  void _internal_set_category(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 navFlags = 10 [(.Analytics.enumkey) = "NAV_FLAGS"];
  void clear_navflags();
  ::PROTOBUF_NAMESPACE_ID::int64 navflags() const;
  void set_navflags(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_navflags() const;
  void _internal_set_navflags(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 powerUps = 9 [(.Analytics.enumkey) = "POWERUP_ID", (.Analytics.enumflagsindexed) = true];
  void clear_powerups();
  ::PROTOBUF_NAMESPACE_ID::int32 powerups() const;
  void set_powerups(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_powerups() const;
  void _internal_set_powerups(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool deleted = 1000 [(.Analytics.hidden) = true];
  void clear_deleted();
  bool deleted() const;
  void set_deleted(bool value);
  private:
  bool _internal_deleted() const;
  void _internal_set_deleted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo > ammo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entityname_;
  ::Analytics::Vec3* eulerrotation_;
  ::Analytics::Vec3* position_;
  ::Analytics::Vec3* eyeoffset_;
  ::Analytics::Vec3* eyedir_;
  ::Analytics::RangeI* health_;
  ::Analytics::RangeI* armor_;
  ::Analytics::Vec3* boundsmin_;
  ::Analytics::Vec3* boundsmax_;
  ::PROTOBUF_NAMESPACE_ID::int32 entityindex_;
  ::PROTOBUF_NAMESPACE_ID::int32 entityserial_;
  ::PROTOBUF_NAMESPACE_ID::int32 groupid_;
  ::PROTOBUF_NAMESPACE_ID::int32 classid_;
  ::PROTOBUF_NAMESPACE_ID::int64 entityflags_;
  ::PROTOBUF_NAMESPACE_ID::int32 team_;
  ::PROTOBUF_NAMESPACE_ID::int32 category_;
  ::PROTOBUF_NAMESPACE_ID::int64 navflags_;
  ::PROTOBUF_NAMESPACE_ID::int32 powerups_;
  bool deleted_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameEntityPosition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameEntityPosition) */ {
 public:
  GameEntityPosition();
  virtual ~GameEntityPosition();

  GameEntityPosition(const GameEntityPosition& from);
  GameEntityPosition(GameEntityPosition&& from) noexcept
    : GameEntityPosition() {
    *this = ::std::move(from);
  }

  inline GameEntityPosition& operator=(const GameEntityPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameEntityPosition& operator=(GameEntityPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameEntityPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameEntityPosition* internal_default_instance() {
    return reinterpret_cast<const GameEntityPosition*>(
               &_GameEntityPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GameEntityPosition& a, GameEntityPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(GameEntityPosition* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameEntityPosition* New() const final {
    return CreateMaybeMessage<GameEntityPosition>(nullptr);
  }

  GameEntityPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameEntityPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameEntityPosition& from);
  void MergeFrom(const GameEntityPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameEntityPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameEntityPosition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kTeamFieldNumber = 2,
  };
  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // int32 team = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_team();
  ::PROTOBUF_NAMESPACE_ID::int32 team() const;
  void set_team(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_team() const;
  void _internal_set_team(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameEntityPosition)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 team_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameNode :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameNode) */ {
 public:
  GameNode();
  virtual ~GameNode();

  GameNode(const GameNode& from);
  GameNode(GameNode&& from) noexcept
    : GameNode() {
    *this = ::std::move(from);
  }

  inline GameNode& operator=(const GameNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameNode& operator=(GameNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameNode* internal_default_instance() {
    return reinterpret_cast<const GameNode*>(
               &_GameNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GameNode& a, GameNode& b) {
    a.Swap(&b);
  }
  inline void Swap(GameNode* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameNode* New() const final {
    return CreateMaybeMessage<GameNode>(nullptr);
  }

  GameNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameNode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameNode& from);
  void MergeFrom(const GameNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameNode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameNode";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodePathFieldNumber = 1,
    kMeshNameFieldNumber = 4,
    kEntityNameFieldNumber = 11,
    kEulerRotationFieldNumber = 2,
    kTranslationFieldNumber = 3,
    kEntityIdFieldNumber = 10,
    kActiveStateFieldNumber = 12,
    kShapeModeFieldNumber = 15,
    kNavFlagsActiveFieldNumber = 13,
    kNavFlagsOverrideFieldNumber = 14,
  };
  // string nodePath = 1 [(.Analytics.editable_key) = true];
  void clear_nodepath();
  const std::string& nodepath() const;
  void set_nodepath(const std::string& value);
  void set_nodepath(std::string&& value);
  void set_nodepath(const char* value);
  void set_nodepath(const char* value, size_t size);
  std::string* mutable_nodepath();
  std::string* release_nodepath();
  void set_allocated_nodepath(std::string* nodepath);
  private:
  const std::string& _internal_nodepath() const;
  void _internal_set_nodepath(const std::string& value);
  std::string* _internal_mutable_nodepath();
  public:

  // string meshName = 4;
  void clear_meshname();
  const std::string& meshname() const;
  void set_meshname(const std::string& value);
  void set_meshname(std::string&& value);
  void set_meshname(const char* value);
  void set_meshname(const char* value, size_t size);
  std::string* mutable_meshname();
  std::string* release_meshname();
  void set_allocated_meshname(std::string* meshname);
  private:
  const std::string& _internal_meshname() const;
  void _internal_set_meshname(const std::string& value);
  std::string* _internal_mutable_meshname();
  public:

  // string entityName = 11;
  void clear_entityname();
  const std::string& entityname() const;
  void set_entityname(const std::string& value);
  void set_entityname(std::string&& value);
  void set_entityname(const char* value);
  void set_entityname(const char* value, size_t size);
  std::string* mutable_entityname();
  std::string* release_entityname();
  void set_allocated_entityname(std::string* entityname);
  private:
  const std::string& _internal_entityname() const;
  void _internal_set_entityname(const std::string& value);
  std::string* _internal_mutable_entityname();
  public:

  // .Analytics.Vec3 eulerRotation = 2;
  bool has_eulerrotation() const;
  private:
  bool _internal_has_eulerrotation() const;
  public:
  void clear_eulerrotation();
  const ::Analytics::Vec3& eulerrotation() const;
  ::Analytics::Vec3* release_eulerrotation();
  ::Analytics::Vec3* mutable_eulerrotation();
  void set_allocated_eulerrotation(::Analytics::Vec3* eulerrotation);
  private:
  const ::Analytics::Vec3& _internal_eulerrotation() const;
  ::Analytics::Vec3* _internal_mutable_eulerrotation();
  public:

  // .Analytics.Vec3 translation = 3;
  bool has_translation() const;
  private:
  bool _internal_has_translation() const;
  public:
  void clear_translation();
  const ::Analytics::Vec3& translation() const;
  ::Analytics::Vec3* release_translation();
  ::Analytics::Vec3* mutable_translation();
  void set_allocated_translation(::Analytics::Vec3* translation);
  private:
  const ::Analytics::Vec3& _internal_translation() const;
  ::Analytics::Vec3* _internal_mutable_translation();
  public:

  // int32 entityId = 10;
  void clear_entityid();
  ::PROTOBUF_NAMESPACE_ID::int32 entityid() const;
  void set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_entityid() const;
  void _internal_set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 activeState = 12 [(.Analytics.enumkey) = "MODEL_STATE"];
  void clear_activestate();
  ::PROTOBUF_NAMESPACE_ID::int32 activestate() const;
  void set_activestate(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_activestate() const;
  void _internal_set_activestate(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 shapeMode = 15 [(.Analytics.enumkey) = "SHAPEMODE", (.Analytics.editable) = true];
  void clear_shapemode();
  ::PROTOBUF_NAMESPACE_ID::int32 shapemode() const;
  void set_shapemode(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_shapemode() const;
  void _internal_set_shapemode(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int64 navFlagsActive = 13 [(.Analytics.enumkey) = "NAV_FLAGS"];
  void clear_navflagsactive();
  ::PROTOBUF_NAMESPACE_ID::int64 navflagsactive() const;
  void set_navflagsactive(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_navflagsactive() const;
  void _internal_set_navflagsactive(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 navFlagsOverride = 14 [(.Analytics.enumkey) = "NAV_FLAGS", (.Analytics.editable) = true];
  void clear_navflagsoverride();
  ::PROTOBUF_NAMESPACE_ID::int64 navflagsoverride() const;
  void set_navflagsoverride(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_navflagsoverride() const;
  void _internal_set_navflagsoverride(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameNode)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nodepath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meshname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr entityname_;
  ::Analytics::Vec3* eulerrotation_;
  ::Analytics::Vec3* translation_;
  ::PROTOBUF_NAMESPACE_ID::int32 entityid_;
  ::PROTOBUF_NAMESPACE_ID::int32 activestate_;
  ::PROTOBUF_NAMESPACE_ID::int32 shapemode_;
  ::PROTOBUF_NAMESPACE_ID::int64 navflagsactive_;
  ::PROTOBUF_NAMESPACE_ID::int64 navflagsoverride_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameWeaponFired :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameWeaponFired) */ {
 public:
  GameWeaponFired();
  virtual ~GameWeaponFired();

  GameWeaponFired(const GameWeaponFired& from);
  GameWeaponFired(GameWeaponFired&& from) noexcept
    : GameWeaponFired() {
    *this = ::std::move(from);
  }

  inline GameWeaponFired& operator=(const GameWeaponFired& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameWeaponFired& operator=(GameWeaponFired&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameWeaponFired& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameWeaponFired* internal_default_instance() {
    return reinterpret_cast<const GameWeaponFired*>(
               &_GameWeaponFired_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GameWeaponFired& a, GameWeaponFired& b) {
    a.Swap(&b);
  }
  inline void Swap(GameWeaponFired* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameWeaponFired* New() const final {
    return CreateMaybeMessage<GameWeaponFired>(nullptr);
  }

  GameWeaponFired* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameWeaponFired>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameWeaponFired& from);
  void MergeFrom(const GameWeaponFired& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameWeaponFired* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameWeaponFired";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kAttackTeamFieldNumber = 2,
    kWeaponIdFieldNumber = 3,
    kFiredByClassFieldNumber = 4,
  };
  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // int32 attackTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam() const;
  void set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attackteam() const;
  void _internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 weaponId = 3 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  void clear_weaponid();
  ::PROTOBUF_NAMESPACE_ID::int32 weaponid() const;
  void set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weaponid() const;
  void _internal_set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 firedByClass = 4 [(.Analytics.enumkey) = "CLASS_ID", (.Analytics.track_event) = true];
  void clear_firedbyclass();
  ::PROTOBUF_NAMESPACE_ID::int32 firedbyclass() const;
  void set_firedbyclass(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_firedbyclass() const;
  void _internal_set_firedbyclass(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameWeaponFired)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam_;
  ::PROTOBUF_NAMESPACE_ID::int32 weaponid_;
  ::PROTOBUF_NAMESPACE_ID::int32 firedbyclass_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameDeath :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameDeath) */ {
 public:
  GameDeath();
  virtual ~GameDeath();

  GameDeath(const GameDeath& from);
  GameDeath(GameDeath&& from) noexcept
    : GameDeath() {
    *this = ::std::move(from);
  }

  inline GameDeath& operator=(const GameDeath& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameDeath& operator=(GameDeath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameDeath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameDeath* internal_default_instance() {
    return reinterpret_cast<const GameDeath*>(
               &_GameDeath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GameDeath& a, GameDeath& b) {
    a.Swap(&b);
  }
  inline void Swap(GameDeath* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameDeath* New() const final {
    return CreateMaybeMessage<GameDeath>(nullptr);
  }

  GameDeath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameDeath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameDeath& from);
  void MergeFrom(const GameDeath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameDeath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameDeath";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeansOfDeathFieldNumber = 4,
    kPositionFieldNumber = 1,
    kVictimTeamFieldNumber = 2,
    kAttackTeamFieldNumber = 3,
  };
  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  void clear_meansofdeath();
  const std::string& meansofdeath() const;
  void set_meansofdeath(const std::string& value);
  void set_meansofdeath(std::string&& value);
  void set_meansofdeath(const char* value);
  void set_meansofdeath(const char* value, size_t size);
  std::string* mutable_meansofdeath();
  std::string* release_meansofdeath();
  void set_allocated_meansofdeath(std::string* meansofdeath);
  private:
  const std::string& _internal_meansofdeath() const;
  void _internal_set_meansofdeath(const std::string& value);
  std::string* _internal_mutable_meansofdeath();
  public:

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_victimteam();
  ::PROTOBUF_NAMESPACE_ID::int32 victimteam() const;
  void set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_victimteam() const;
  void _internal_set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam() const;
  void set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attackteam() const;
  void _internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameDeath)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meansofdeath_;
  ::Analytics::Vec3* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 victimteam_;
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameKilledSomeone :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameKilledSomeone) */ {
 public:
  GameKilledSomeone();
  virtual ~GameKilledSomeone();

  GameKilledSomeone(const GameKilledSomeone& from);
  GameKilledSomeone(GameKilledSomeone&& from) noexcept
    : GameKilledSomeone() {
    *this = ::std::move(from);
  }

  inline GameKilledSomeone& operator=(const GameKilledSomeone& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameKilledSomeone& operator=(GameKilledSomeone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameKilledSomeone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameKilledSomeone* internal_default_instance() {
    return reinterpret_cast<const GameKilledSomeone*>(
               &_GameKilledSomeone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(GameKilledSomeone& a, GameKilledSomeone& b) {
    a.Swap(&b);
  }
  inline void Swap(GameKilledSomeone* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameKilledSomeone* New() const final {
    return CreateMaybeMessage<GameKilledSomeone>(nullptr);
  }

  GameKilledSomeone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameKilledSomeone>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameKilledSomeone& from);
  void MergeFrom(const GameKilledSomeone& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameKilledSomeone* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameKilledSomeone";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMeansOfDeathFieldNumber = 4,
    kPositionFieldNumber = 1,
    kVictimTeamFieldNumber = 2,
    kAttackTeamFieldNumber = 3,
  };
  // string meansOfDeath = 4 [(.Analytics.track_event) = true];
  void clear_meansofdeath();
  const std::string& meansofdeath() const;
  void set_meansofdeath(const std::string& value);
  void set_meansofdeath(std::string&& value);
  void set_meansofdeath(const char* value);
  void set_meansofdeath(const char* value, size_t size);
  std::string* mutable_meansofdeath();
  std::string* release_meansofdeath();
  void set_allocated_meansofdeath(std::string* meansofdeath);
  private:
  const std::string& _internal_meansofdeath() const;
  void _internal_set_meansofdeath(const std::string& value);
  std::string* _internal_mutable_meansofdeath();
  public:

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_victimteam();
  ::PROTOBUF_NAMESPACE_ID::int32 victimteam() const;
  void set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_victimteam() const;
  void _internal_set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam() const;
  void set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attackteam() const;
  void _internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameKilledSomeone)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr meansofdeath_;
  ::Analytics::Vec3* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 victimteam_;
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameRecieveDamage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameRecieveDamage) */ {
 public:
  GameRecieveDamage();
  virtual ~GameRecieveDamage();

  GameRecieveDamage(const GameRecieveDamage& from);
  GameRecieveDamage(GameRecieveDamage&& from) noexcept
    : GameRecieveDamage() {
    *this = ::std::move(from);
  }

  inline GameRecieveDamage& operator=(const GameRecieveDamage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameRecieveDamage& operator=(GameRecieveDamage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameRecieveDamage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameRecieveDamage* internal_default_instance() {
    return reinterpret_cast<const GameRecieveDamage*>(
               &_GameRecieveDamage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GameRecieveDamage& a, GameRecieveDamage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameRecieveDamage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameRecieveDamage* New() const final {
    return CreateMaybeMessage<GameRecieveDamage>(nullptr);
  }

  GameRecieveDamage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameRecieveDamage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameRecieveDamage& from);
  void MergeFrom(const GameRecieveDamage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRecieveDamage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameRecieveDamage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDamageTypeFieldNumber = 5,
    kPositionFieldNumber = 1,
    kVictimTeamFieldNumber = 2,
    kAttackTeamFieldNumber = 3,
    kWeaponIdFieldNumber = 4,
    kDamageAmountFieldNumber = 6,
  };
  // string damageType = 5 [(.Analytics.track_event) = true];
  void clear_damagetype();
  const std::string& damagetype() const;
  void set_damagetype(const std::string& value);
  void set_damagetype(std::string&& value);
  void set_damagetype(const char* value);
  void set_damagetype(const char* value, size_t size);
  std::string* mutable_damagetype();
  std::string* release_damagetype();
  void set_allocated_damagetype(std::string* damagetype);
  private:
  const std::string& _internal_damagetype() const;
  void _internal_set_damagetype(const std::string& value);
  std::string* _internal_mutable_damagetype();
  public:

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_victimteam();
  ::PROTOBUF_NAMESPACE_ID::int32 victimteam() const;
  void set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_victimteam() const;
  void _internal_set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam() const;
  void set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attackteam() const;
  void _internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  void clear_weaponid();
  ::PROTOBUF_NAMESPACE_ID::int32 weaponid() const;
  void set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weaponid() const;
  void _internal_set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float damageAmount = 6;
  void clear_damageamount();
  float damageamount() const;
  void set_damageamount(float value);
  private:
  float _internal_damageamount() const;
  void _internal_set_damageamount(float value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameRecieveDamage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr damagetype_;
  ::Analytics::Vec3* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 victimteam_;
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam_;
  ::PROTOBUF_NAMESPACE_ID::int32 weaponid_;
  float damageamount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameInflictDamage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameInflictDamage) */ {
 public:
  GameInflictDamage();
  virtual ~GameInflictDamage();

  GameInflictDamage(const GameInflictDamage& from);
  GameInflictDamage(GameInflictDamage&& from) noexcept
    : GameInflictDamage() {
    *this = ::std::move(from);
  }

  inline GameInflictDamage& operator=(const GameInflictDamage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameInflictDamage& operator=(GameInflictDamage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameInflictDamage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameInflictDamage* internal_default_instance() {
    return reinterpret_cast<const GameInflictDamage*>(
               &_GameInflictDamage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(GameInflictDamage& a, GameInflictDamage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameInflictDamage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameInflictDamage* New() const final {
    return CreateMaybeMessage<GameInflictDamage>(nullptr);
  }

  GameInflictDamage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameInflictDamage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameInflictDamage& from);
  void MergeFrom(const GameInflictDamage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameInflictDamage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameInflictDamage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDamageTypeFieldNumber = 5,
    kPositionFieldNumber = 1,
    kVictimTeamFieldNumber = 2,
    kAttackTeamFieldNumber = 3,
    kWeaponIdFieldNumber = 4,
    kDamageAmountFieldNumber = 6,
  };
  // string damageType = 5 [(.Analytics.track_event) = true];
  void clear_damagetype();
  const std::string& damagetype() const;
  void set_damagetype(const std::string& value);
  void set_damagetype(std::string&& value);
  void set_damagetype(const char* value);
  void set_damagetype(const char* value, size_t size);
  std::string* mutable_damagetype();
  std::string* release_damagetype();
  void set_allocated_damagetype(std::string* damagetype);
  private:
  const std::string& _internal_damagetype() const;
  void _internal_set_damagetype(const std::string& value);
  std::string* _internal_mutable_damagetype();
  public:

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_victimteam();
  ::PROTOBUF_NAMESPACE_ID::int32 victimteam() const;
  void set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_victimteam() const;
  void _internal_set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
  void clear_attackteam();
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam() const;
  void set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_attackteam() const;
  void _internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
  void clear_weaponid();
  ::PROTOBUF_NAMESPACE_ID::int32 weaponid() const;
  void set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_weaponid() const;
  void _internal_set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float damageAmount = 6;
  void clear_damageamount();
  float damageamount() const;
  void set_damageamount(float value);
  private:
  float _internal_damageamount() const;
  void _internal_set_damageamount(float value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameInflictDamage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr damagetype_;
  ::Analytics::Vec3* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 victimteam_;
  ::PROTOBUF_NAMESPACE_ID::int32 attackteam_;
  ::PROTOBUF_NAMESPACE_ID::int32 weaponid_;
  float damageamount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameRadiusDamage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameRadiusDamage) */ {
 public:
  GameRadiusDamage();
  virtual ~GameRadiusDamage();

  GameRadiusDamage(const GameRadiusDamage& from);
  GameRadiusDamage(GameRadiusDamage&& from) noexcept
    : GameRadiusDamage() {
    *this = ::std::move(from);
  }

  inline GameRadiusDamage& operator=(const GameRadiusDamage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameRadiusDamage& operator=(GameRadiusDamage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameRadiusDamage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameRadiusDamage* internal_default_instance() {
    return reinterpret_cast<const GameRadiusDamage*>(
               &_GameRadiusDamage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GameRadiusDamage& a, GameRadiusDamage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameRadiusDamage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameRadiusDamage* New() const final {
    return CreateMaybeMessage<GameRadiusDamage>(nullptr);
  }

  GameRadiusDamage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameRadiusDamage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameRadiusDamage& from);
  void MergeFrom(const GameRadiusDamage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameRadiusDamage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameRadiusDamage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDamageTypeFieldNumber = 2,
    kPositionFieldNumber = 1,
    kDamageAmountFieldNumber = 3,
    kDamageRadiusFieldNumber = 4,
  };
  // string damageType = 2;
  void clear_damagetype();
  const std::string& damagetype() const;
  void set_damagetype(const std::string& value);
  void set_damagetype(std::string&& value);
  void set_damagetype(const char* value);
  void set_damagetype(const char* value, size_t size);
  std::string* mutable_damagetype();
  std::string* release_damagetype();
  void set_allocated_damagetype(std::string* damagetype);
  private:
  const std::string& _internal_damagetype() const;
  void _internal_set_damagetype(const std::string& value);
  std::string* _internal_mutable_damagetype();
  public:

  // .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // float damageAmount = 3;
  void clear_damageamount();
  float damageamount() const;
  void set_damageamount(float value);
  private:
  float _internal_damageamount() const;
  void _internal_set_damageamount(float value);
  public:

  // float damageRadius = 4;
  void clear_damageradius();
  float damageradius() const;
  void set_damageradius(float value);
  private:
  float _internal_damageradius() const;
  void _internal_set_damageradius(float value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameRadiusDamage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr damagetype_;
  ::Analytics::Vec3* position_;
  float damageamount_;
  float damageradius_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameNavigationStuck :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameNavigationStuck) */ {
 public:
  GameNavigationStuck();
  virtual ~GameNavigationStuck();

  GameNavigationStuck(const GameNavigationStuck& from);
  GameNavigationStuck(GameNavigationStuck&& from) noexcept
    : GameNavigationStuck() {
    *this = ::std::move(from);
  }

  inline GameNavigationStuck& operator=(const GameNavigationStuck& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameNavigationStuck& operator=(GameNavigationStuck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameNavigationStuck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameNavigationStuck* internal_default_instance() {
    return reinterpret_cast<const GameNavigationStuck*>(
               &_GameNavigationStuck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GameNavigationStuck& a, GameNavigationStuck& b) {
    a.Swap(&b);
  }
  inline void Swap(GameNavigationStuck* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameNavigationStuck* New() const final {
    return CreateMaybeMessage<GameNavigationStuck>(nullptr);
  }

  GameNavigationStuck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameNavigationStuck>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameNavigationStuck& from);
  void MergeFrom(const GameNavigationStuck& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameNavigationStuck* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameNavigationStuck";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 2,
    kEntityIdFieldNumber = 1,
  };
  // .Analytics.Vec3 position = 2 [(.Analytics.point_event) = {
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // int32 entityId = 1;
  void clear_entityid();
  ::PROTOBUF_NAMESPACE_ID::int32 entityid() const;
  void set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_entityid() const;
  void _internal_set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameNavigationStuck)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 entityid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameVoiceMacro :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameVoiceMacro) */ {
 public:
  GameVoiceMacro();
  virtual ~GameVoiceMacro();

  GameVoiceMacro(const GameVoiceMacro& from);
  GameVoiceMacro(GameVoiceMacro&& from) noexcept
    : GameVoiceMacro() {
    *this = ::std::move(from);
  }

  inline GameVoiceMacro& operator=(const GameVoiceMacro& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameVoiceMacro& operator=(GameVoiceMacro&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameVoiceMacro& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameVoiceMacro* internal_default_instance() {
    return reinterpret_cast<const GameVoiceMacro*>(
               &_GameVoiceMacro_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(GameVoiceMacro& a, GameVoiceMacro& b) {
    a.Swap(&b);
  }
  inline void Swap(GameVoiceMacro* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameVoiceMacro* New() const final {
    return CreateMaybeMessage<GameVoiceMacro>(nullptr);
  }

  GameVoiceMacro* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameVoiceMacro>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameVoiceMacro& from);
  void MergeFrom(const GameVoiceMacro& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameVoiceMacro* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameVoiceMacro";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 3,
    kEntityIdFieldNumber = 1,
    kVoiceMacroFieldNumber = 2,
  };
  // .Analytics.Vec3 position = 3 [(.Analytics.point_event) = {
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::Analytics::Vec3& position() const;
  ::Analytics::Vec3* release_position();
  ::Analytics::Vec3* mutable_position();
  void set_allocated_position(::Analytics::Vec3* position);
  private:
  const ::Analytics::Vec3& _internal_position() const;
  ::Analytics::Vec3* _internal_mutable_position();
  public:

  // int32 entityId = 1;
  void clear_entityid();
  ::PROTOBUF_NAMESPACE_ID::int32 entityid() const;
  void set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_entityid() const;
  void _internal_set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 voiceMacro = 2 [(.Analytics.enumkey) = "VOICE_MACRO", (.Analytics.track_event) = true];
  void clear_voicemacro();
  ::PROTOBUF_NAMESPACE_ID::int32 voicemacro() const;
  void set_voicemacro(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_voicemacro() const;
  void _internal_set_voicemacro(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameVoiceMacro)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::Analytics::Vec3* position_;
  ::PROTOBUF_NAMESPACE_ID::int32 entityid_;
  ::PROTOBUF_NAMESPACE_ID::int32 voicemacro_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// -------------------------------------------------------------------

class GameLogMessage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Analytics.GameLogMessage) */ {
 public:
  GameLogMessage();
  virtual ~GameLogMessage();

  GameLogMessage(const GameLogMessage& from);
  GameLogMessage(GameLogMessage&& from) noexcept
    : GameLogMessage() {
    *this = ::std::move(from);
  }

  inline GameLogMessage& operator=(const GameLogMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameLogMessage& operator=(GameLogMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GameLogMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameLogMessage* internal_default_instance() {
    return reinterpret_cast<const GameLogMessage*>(
               &_GameLogMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(GameLogMessage& a, GameLogMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GameLogMessage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GameLogMessage* New() const final {
    return CreateMaybeMessage<GameLogMessage>(nullptr);
  }

  GameLogMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GameLogMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GameLogMessage& from);
  void MergeFrom(const GameLogMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameLogMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Analytics.GameLogMessage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_analytics_2eproto);
    return ::descriptor_table_analytics_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogMessageFieldNumber = 2,
    kLogExtraInfoFieldNumber = 3,
    kLogTypeFieldNumber = 1,
  };
  // string logMessage = 2;
  void clear_logmessage();
  const std::string& logmessage() const;
  void set_logmessage(const std::string& value);
  void set_logmessage(std::string&& value);
  void set_logmessage(const char* value);
  void set_logmessage(const char* value, size_t size);
  std::string* mutable_logmessage();
  std::string* release_logmessage();
  void set_allocated_logmessage(std::string* logmessage);
  private:
  const std::string& _internal_logmessage() const;
  void _internal_set_logmessage(const std::string& value);
  std::string* _internal_mutable_logmessage();
  public:

  // string logExtraInfo = 3;
  void clear_logextrainfo();
  const std::string& logextrainfo() const;
  void set_logextrainfo(const std::string& value);
  void set_logextrainfo(std::string&& value);
  void set_logextrainfo(const char* value);
  void set_logextrainfo(const char* value, size_t size);
  std::string* mutable_logextrainfo();
  std::string* release_logextrainfo();
  void set_allocated_logextrainfo(std::string* logextrainfo);
  private:
  const std::string& _internal_logextrainfo() const;
  void _internal_set_logextrainfo(const std::string& value);
  std::string* _internal_mutable_logextrainfo();
  public:

  // .Analytics.LogType logType = 1;
  void clear_logtype();
  ::Analytics::LogType logtype() const;
  void set_logtype(::Analytics::LogType value);
  private:
  ::Analytics::LogType _internal_logtype() const;
  void _internal_set_logtype(::Analytics::LogType value);
  public:

  // @@protoc_insertion_point(class_scope:Analytics.GameLogMessage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logmessage_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logextrainfo_;
  int logtype_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_analytics_2eproto;
};
// ===================================================================

static const int kRediskeytypeFieldNumber = 5000;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::EnumTypeTraits< ::Analytics::RedisKeyType, ::Analytics::RedisKeyType_IsValid>, 14, false >
  rediskeytype;
static const int kRedishmsetkeyFieldNumber = 5001;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  redishmsetkey;
static const int kRediskeysuffixFieldNumber = 5002;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  rediskeysuffix;
static const int kUseJsonEncodingFieldNumber = 5003;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  useJsonEncoding;
static const int kObjectnameFieldNumber = 5005;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  objectname;
static const int kEnumkeyFieldNumber = 4001;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  enumkey;
static const int kEditableFieldNumber = 4002;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  editable;
static const int kExpiresFieldNumber = 4003;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< ::PROTOBUF_NAMESPACE_ID::int32 >, 5, false >
  expires;
static const int kEnumflagsFieldNumber = 4004;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  enumflags;
static const int kTooltipFieldNumber = 4005;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  tooltip;
static const int kHiddenFieldNumber = 4006;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  hidden;
static const int kEnumflagsindexedFieldNumber = 4007;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  enumflagsindexed;
static const int kEditableKeyFieldNumber = 4008;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  editable_key;
static const int kTrackEventFieldNumber = 4009;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  track_event;
static const int kPointEventFieldNumber = 4012;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::Analytics::PointEvent >, 11, false >
  point_event;
static const int kLineEventFieldNumber = 4013;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::Analytics::LineEvent >, 11, false >
  line_event;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PointEvent

// string radius = 1;
inline void PointEvent::clear_radius() {
  radius_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PointEvent::radius() const {
  // @@protoc_insertion_point(field_get:Analytics.PointEvent.radius)
  return _internal_radius();
}
inline void PointEvent::set_radius(const std::string& value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:Analytics.PointEvent.radius)
}
inline std::string* PointEvent::mutable_radius() {
  // @@protoc_insertion_point(field_mutable:Analytics.PointEvent.radius)
  return _internal_mutable_radius();
}
inline const std::string& PointEvent::_internal_radius() const {
  return radius_.GetNoArena();
}
inline void PointEvent::_internal_set_radius(const std::string& value) {
  
  radius_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PointEvent::set_radius(std::string&& value) {
  
  radius_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.PointEvent.radius)
}
inline void PointEvent::set_radius(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  radius_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.PointEvent.radius)
}
inline void PointEvent::set_radius(const char* value, size_t size) {
  
  radius_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.PointEvent.radius)
}
inline std::string* PointEvent::_internal_mutable_radius() {
  
  return radius_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PointEvent::release_radius() {
  // @@protoc_insertion_point(field_release:Analytics.PointEvent.radius)
  
  return radius_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PointEvent::set_allocated_radius(std::string* radius) {
  if (radius != nullptr) {
    
  } else {
    
  }
  radius_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), radius);
  // @@protoc_insertion_point(field_set_allocated:Analytics.PointEvent.radius)
}

// string weight = 2;
inline void PointEvent::clear_weight() {
  weight_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& PointEvent::weight() const {
  // @@protoc_insertion_point(field_get:Analytics.PointEvent.weight)
  return _internal_weight();
}
inline void PointEvent::set_weight(const std::string& value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:Analytics.PointEvent.weight)
}
inline std::string* PointEvent::mutable_weight() {
  // @@protoc_insertion_point(field_mutable:Analytics.PointEvent.weight)
  return _internal_mutable_weight();
}
inline const std::string& PointEvent::_internal_weight() const {
  return weight_.GetNoArena();
}
inline void PointEvent::_internal_set_weight(const std::string& value) {
  
  weight_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void PointEvent::set_weight(std::string&& value) {
  
  weight_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.PointEvent.weight)
}
inline void PointEvent::set_weight(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  weight_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.PointEvent.weight)
}
inline void PointEvent::set_weight(const char* value, size_t size) {
  
  weight_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.PointEvent.weight)
}
inline std::string* PointEvent::_internal_mutable_weight() {
  
  return weight_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PointEvent::release_weight() {
  // @@protoc_insertion_point(field_release:Analytics.PointEvent.weight)
  
  return weight_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PointEvent::set_allocated_weight(std::string* weight) {
  if (weight != nullptr) {
    
  } else {
    
  }
  weight_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), weight);
  // @@protoc_insertion_point(field_set_allocated:Analytics.PointEvent.weight)
}

// -------------------------------------------------------------------

// LineEvent

// string radius = 1;
inline void LineEvent::clear_radius() {
  radius_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LineEvent::radius() const {
  // @@protoc_insertion_point(field_get:Analytics.LineEvent.radius)
  return _internal_radius();
}
inline void LineEvent::set_radius(const std::string& value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:Analytics.LineEvent.radius)
}
inline std::string* LineEvent::mutable_radius() {
  // @@protoc_insertion_point(field_mutable:Analytics.LineEvent.radius)
  return _internal_mutable_radius();
}
inline const std::string& LineEvent::_internal_radius() const {
  return radius_.GetNoArena();
}
inline void LineEvent::_internal_set_radius(const std::string& value) {
  
  radius_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LineEvent::set_radius(std::string&& value) {
  
  radius_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.LineEvent.radius)
}
inline void LineEvent::set_radius(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  radius_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.LineEvent.radius)
}
inline void LineEvent::set_radius(const char* value, size_t size) {
  
  radius_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.LineEvent.radius)
}
inline std::string* LineEvent::_internal_mutable_radius() {
  
  return radius_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LineEvent::release_radius() {
  // @@protoc_insertion_point(field_release:Analytics.LineEvent.radius)
  
  return radius_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LineEvent::set_allocated_radius(std::string* radius) {
  if (radius != nullptr) {
    
  } else {
    
  }
  radius_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), radius);
  // @@protoc_insertion_point(field_set_allocated:Analytics.LineEvent.radius)
}

// string weight = 2;
inline void LineEvent::clear_weight() {
  weight_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& LineEvent::weight() const {
  // @@protoc_insertion_point(field_get:Analytics.LineEvent.weight)
  return _internal_weight();
}
inline void LineEvent::set_weight(const std::string& value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:Analytics.LineEvent.weight)
}
inline std::string* LineEvent::mutable_weight() {
  // @@protoc_insertion_point(field_mutable:Analytics.LineEvent.weight)
  return _internal_mutable_weight();
}
inline const std::string& LineEvent::_internal_weight() const {
  return weight_.GetNoArena();
}
inline void LineEvent::_internal_set_weight(const std::string& value) {
  
  weight_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LineEvent::set_weight(std::string&& value) {
  
  weight_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.LineEvent.weight)
}
inline void LineEvent::set_weight(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  weight_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.LineEvent.weight)
}
inline void LineEvent::set_weight(const char* value, size_t size) {
  
  weight_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.LineEvent.weight)
}
inline std::string* LineEvent::_internal_mutable_weight() {
  
  return weight_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LineEvent::release_weight() {
  // @@protoc_insertion_point(field_release:Analytics.LineEvent.weight)
  
  return weight_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LineEvent::set_allocated_weight(std::string* weight) {
  if (weight != nullptr) {
    
  } else {
    
  }
  weight_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), weight);
  // @@protoc_insertion_point(field_set_allocated:Analytics.LineEvent.weight)
}

// -------------------------------------------------------------------

// EditorChangeValue

// string messageType = 1;
inline void EditorChangeValue::clear_messagetype() {
  messagetype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EditorChangeValue::messagetype() const {
  // @@protoc_insertion_point(field_get:Analytics.EditorChangeValue.messageType)
  return _internal_messagetype();
}
inline void EditorChangeValue::set_messagetype(const std::string& value) {
  _internal_set_messagetype(value);
  // @@protoc_insertion_point(field_set:Analytics.EditorChangeValue.messageType)
}
inline std::string* EditorChangeValue::mutable_messagetype() {
  // @@protoc_insertion_point(field_mutable:Analytics.EditorChangeValue.messageType)
  return _internal_mutable_messagetype();
}
inline const std::string& EditorChangeValue::_internal_messagetype() const {
  return messagetype_.GetNoArena();
}
inline void EditorChangeValue::_internal_set_messagetype(const std::string& value) {
  
  messagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EditorChangeValue::set_messagetype(std::string&& value) {
  
  messagetype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.EditorChangeValue.messageType)
}
inline void EditorChangeValue::set_messagetype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  messagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.EditorChangeValue.messageType)
}
inline void EditorChangeValue::set_messagetype(const char* value, size_t size) {
  
  messagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.EditorChangeValue.messageType)
}
inline std::string* EditorChangeValue::_internal_mutable_messagetype() {
  
  return messagetype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EditorChangeValue::release_messagetype() {
  // @@protoc_insertion_point(field_release:Analytics.EditorChangeValue.messageType)
  
  return messagetype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EditorChangeValue::set_allocated_messagetype(std::string* messagetype) {
  if (messagetype != nullptr) {
    
  } else {
    
  }
  messagetype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), messagetype);
  // @@protoc_insertion_point(field_set_allocated:Analytics.EditorChangeValue.messageType)
}

// string fieldName = 2;
inline void EditorChangeValue::clear_fieldname() {
  fieldname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EditorChangeValue::fieldname() const {
  // @@protoc_insertion_point(field_get:Analytics.EditorChangeValue.fieldName)
  return _internal_fieldname();
}
inline void EditorChangeValue::set_fieldname(const std::string& value) {
  _internal_set_fieldname(value);
  // @@protoc_insertion_point(field_set:Analytics.EditorChangeValue.fieldName)
}
inline std::string* EditorChangeValue::mutable_fieldname() {
  // @@protoc_insertion_point(field_mutable:Analytics.EditorChangeValue.fieldName)
  return _internal_mutable_fieldname();
}
inline const std::string& EditorChangeValue::_internal_fieldname() const {
  return fieldname_.GetNoArena();
}
inline void EditorChangeValue::_internal_set_fieldname(const std::string& value) {
  
  fieldname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EditorChangeValue::set_fieldname(std::string&& value) {
  
  fieldname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.EditorChangeValue.fieldName)
}
inline void EditorChangeValue::set_fieldname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fieldname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.EditorChangeValue.fieldName)
}
inline void EditorChangeValue::set_fieldname(const char* value, size_t size) {
  
  fieldname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.EditorChangeValue.fieldName)
}
inline std::string* EditorChangeValue::_internal_mutable_fieldname() {
  
  return fieldname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EditorChangeValue::release_fieldname() {
  // @@protoc_insertion_point(field_release:Analytics.EditorChangeValue.fieldName)
  
  return fieldname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EditorChangeValue::set_allocated_fieldname(std::string* fieldname) {
  if (fieldname != nullptr) {
    
  } else {
    
  }
  fieldname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fieldname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.EditorChangeValue.fieldName)
}

// string payload = 3;
inline void EditorChangeValue::clear_payload() {
  payload_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& EditorChangeValue::payload() const {
  // @@protoc_insertion_point(field_get:Analytics.EditorChangeValue.payload)
  return _internal_payload();
}
inline void EditorChangeValue::set_payload(const std::string& value) {
  _internal_set_payload(value);
  // @@protoc_insertion_point(field_set:Analytics.EditorChangeValue.payload)
}
inline std::string* EditorChangeValue::mutable_payload() {
  // @@protoc_insertion_point(field_mutable:Analytics.EditorChangeValue.payload)
  return _internal_mutable_payload();
}
inline const std::string& EditorChangeValue::_internal_payload() const {
  return payload_.GetNoArena();
}
inline void EditorChangeValue::_internal_set_payload(const std::string& value) {
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void EditorChangeValue::set_payload(std::string&& value) {
  
  payload_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.EditorChangeValue.payload)
}
inline void EditorChangeValue::set_payload(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.EditorChangeValue.payload)
}
inline void EditorChangeValue::set_payload(const char* value, size_t size) {
  
  payload_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.EditorChangeValue.payload)
}
inline std::string* EditorChangeValue::_internal_mutable_payload() {
  
  return payload_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* EditorChangeValue::release_payload() {
  // @@protoc_insertion_point(field_release:Analytics.EditorChangeValue.payload)
  
  return payload_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void EditorChangeValue::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:Analytics.EditorChangeValue.payload)
}

// -------------------------------------------------------------------

// EditorChanges

// repeated .Analytics.EditorChangeValue changes = 1;
inline int EditorChanges::_internal_changes_size() const {
  return changes_.size();
}
inline int EditorChanges::changes_size() const {
  return _internal_changes_size();
}
inline void EditorChanges::clear_changes() {
  changes_.Clear();
}
inline ::Analytics::EditorChangeValue* EditorChanges::mutable_changes(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.EditorChanges.changes)
  return changes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::EditorChangeValue >*
EditorChanges::mutable_changes() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.EditorChanges.changes)
  return &changes_;
}
inline const ::Analytics::EditorChangeValue& EditorChanges::_internal_changes(int index) const {
  return changes_.Get(index);
}
inline const ::Analytics::EditorChangeValue& EditorChanges::changes(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.EditorChanges.changes)
  return _internal_changes(index);
}
inline ::Analytics::EditorChangeValue* EditorChanges::_internal_add_changes() {
  return changes_.Add();
}
inline ::Analytics::EditorChangeValue* EditorChanges::add_changes() {
  // @@protoc_insertion_point(field_add:Analytics.EditorChanges.changes)
  return _internal_add_changes();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::EditorChangeValue >&
EditorChanges::changes() const {
  // @@protoc_insertion_point(field_list:Analytics.EditorChanges.changes)
  return changes_;
}

// -------------------------------------------------------------------

// RangeF

// float min = 1;
inline void RangeF::clear_min() {
  min_ = 0;
}
inline float RangeF::_internal_min() const {
  return min_;
}
inline float RangeF::min() const {
  // @@protoc_insertion_point(field_get:Analytics.RangeF.min)
  return _internal_min();
}
inline void RangeF::_internal_set_min(float value) {
  
  min_ = value;
}
inline void RangeF::set_min(float value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:Analytics.RangeF.min)
}

// float max = 2;
inline void RangeF::clear_max() {
  max_ = 0;
}
inline float RangeF::_internal_max() const {
  return max_;
}
inline float RangeF::max() const {
  // @@protoc_insertion_point(field_get:Analytics.RangeF.max)
  return _internal_max();
}
inline void RangeF::_internal_set_max(float value) {
  
  max_ = value;
}
inline void RangeF::set_max(float value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:Analytics.RangeF.max)
}

// -------------------------------------------------------------------

// RangeI

// int32 min = 1;
inline void RangeI::clear_min() {
  min_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RangeI::_internal_min() const {
  return min_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RangeI::min() const {
  // @@protoc_insertion_point(field_get:Analytics.RangeI.min)
  return _internal_min();
}
inline void RangeI::_internal_set_min(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  min_ = value;
}
inline void RangeI::set_min(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:Analytics.RangeI.min)
}

// int32 max = 2;
inline void RangeI::clear_max() {
  max_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RangeI::_internal_max() const {
  return max_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RangeI::max() const {
  // @@protoc_insertion_point(field_get:Analytics.RangeI.max)
  return _internal_max();
}
inline void RangeI::_internal_set_max(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_ = value;
}
inline void RangeI::set_max(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:Analytics.RangeI.max)
}

// -------------------------------------------------------------------

// Vec3

// float x = 1;
inline void Vec3::clear_x() {
  x_ = 0;
}
inline float Vec3::_internal_x() const {
  return x_;
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3.x)
  return _internal_x();
}
inline void Vec3::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec3.x)
}

// float y = 2;
inline void Vec3::clear_y() {
  y_ = 0;
}
inline float Vec3::_internal_y() const {
  return y_;
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3.y)
  return _internal_y();
}
inline void Vec3::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec3.y)
}

// float z = 3;
inline void Vec3::clear_z() {
  z_ = 0;
}
inline float Vec3::_internal_z() const {
  return z_;
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3.z)
  return _internal_z();
}
inline void Vec3::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vec3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec3.z)
}

// -------------------------------------------------------------------

// Vec3Color

// float x = 1;
inline void Vec3Color::clear_x() {
  x_ = 0;
}
inline float Vec3Color::_internal_x() const {
  return x_;
}
inline float Vec3Color::x() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3Color.x)
  return _internal_x();
}
inline void Vec3Color::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec3Color::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec3Color.x)
}

// float y = 2;
inline void Vec3Color::clear_y() {
  y_ = 0;
}
inline float Vec3Color::_internal_y() const {
  return y_;
}
inline float Vec3Color::y() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3Color.y)
  return _internal_y();
}
inline void Vec3Color::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec3Color::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec3Color.y)
}

// float z = 3;
inline void Vec3Color::clear_z() {
  z_ = 0;
}
inline float Vec3Color::_internal_z() const {
  return z_;
}
inline float Vec3Color::z() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3Color.z)
  return _internal_z();
}
inline void Vec3Color::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vec3Color::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec3Color.z)
}

// uint32 color = 4;
inline void Vec3Color::clear_color() {
  color_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Vec3Color::_internal_color() const {
  return color_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Vec3Color::color() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec3Color.color)
  return _internal_color();
}
inline void Vec3Color::_internal_set_color(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  color_ = value;
}
inline void Vec3Color::set_color(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec3Color.color)
}

// -------------------------------------------------------------------

// Vec4

// float x = 1;
inline void Vec4::clear_x() {
  x_ = 0;
}
inline float Vec4::_internal_x() const {
  return x_;
}
inline float Vec4::x() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec4.x)
  return _internal_x();
}
inline void Vec4::_internal_set_x(float value) {
  
  x_ = value;
}
inline void Vec4::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec4.x)
}

// float y = 2;
inline void Vec4::clear_y() {
  y_ = 0;
}
inline float Vec4::_internal_y() const {
  return y_;
}
inline float Vec4::y() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec4.y)
  return _internal_y();
}
inline void Vec4::_internal_set_y(float value) {
  
  y_ = value;
}
inline void Vec4::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec4.y)
}

// float z = 3;
inline void Vec4::clear_z() {
  z_ = 0;
}
inline float Vec4::_internal_z() const {
  return z_;
}
inline float Vec4::z() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec4.z)
  return _internal_z();
}
inline void Vec4::_internal_set_z(float value) {
  
  z_ = value;
}
inline void Vec4::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec4.z)
}

// float w = 4;
inline void Vec4::clear_w() {
  w_ = 0;
}
inline float Vec4::_internal_w() const {
  return w_;
}
inline float Vec4::w() const {
  // @@protoc_insertion_point(field_get:Analytics.Vec4.w)
  return _internal_w();
}
inline void Vec4::_internal_set_w(float value) {
  
  w_ = value;
}
inline void Vec4::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:Analytics.Vec4.w)
}

// -------------------------------------------------------------------

// Line

// .Analytics.Vec3 p0 = 1;
inline bool Line::_internal_has_p0() const {
  return this != internal_default_instance() && p0_ != nullptr;
}
inline bool Line::has_p0() const {
  return _internal_has_p0();
}
inline void Line::clear_p0() {
  if (GetArenaNoVirtual() == nullptr && p0_ != nullptr) {
    delete p0_;
  }
  p0_ = nullptr;
}
inline const ::Analytics::Vec3& Line::_internal_p0() const {
  const ::Analytics::Vec3* p = p0_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& Line::p0() const {
  // @@protoc_insertion_point(field_get:Analytics.Line.p0)
  return _internal_p0();
}
inline ::Analytics::Vec3* Line::release_p0() {
  // @@protoc_insertion_point(field_release:Analytics.Line.p0)
  
  ::Analytics::Vec3* temp = p0_;
  p0_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* Line::_internal_mutable_p0() {
  
  if (p0_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    p0_ = p;
  }
  return p0_;
}
inline ::Analytics::Vec3* Line::mutable_p0() {
  // @@protoc_insertion_point(field_mutable:Analytics.Line.p0)
  return _internal_mutable_p0();
}
inline void Line::set_allocated_p0(::Analytics::Vec3* p0) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete p0_;
  }
  if (p0) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      p0 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p0, submessage_arena);
    }
    
  } else {
    
  }
  p0_ = p0;
  // @@protoc_insertion_point(field_set_allocated:Analytics.Line.p0)
}

// .Analytics.Vec3 p1 = 2;
inline bool Line::_internal_has_p1() const {
  return this != internal_default_instance() && p1_ != nullptr;
}
inline bool Line::has_p1() const {
  return _internal_has_p1();
}
inline void Line::clear_p1() {
  if (GetArenaNoVirtual() == nullptr && p1_ != nullptr) {
    delete p1_;
  }
  p1_ = nullptr;
}
inline const ::Analytics::Vec3& Line::_internal_p1() const {
  const ::Analytics::Vec3* p = p1_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& Line::p1() const {
  // @@protoc_insertion_point(field_get:Analytics.Line.p1)
  return _internal_p1();
}
inline ::Analytics::Vec3* Line::release_p1() {
  // @@protoc_insertion_point(field_release:Analytics.Line.p1)
  
  ::Analytics::Vec3* temp = p1_;
  p1_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* Line::_internal_mutable_p1() {
  
  if (p1_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    p1_ = p;
  }
  return p1_;
}
inline ::Analytics::Vec3* Line::mutable_p1() {
  // @@protoc_insertion_point(field_mutable:Analytics.Line.p1)
  return _internal_mutable_p1();
}
inline void Line::set_allocated_p1(::Analytics::Vec3* p1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete p1_;
  }
  if (p1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      p1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, p1, submessage_arena);
    }
    
  } else {
    
  }
  p1_ = p1;
  // @@protoc_insertion_point(field_set_allocated:Analytics.Line.p1)
}

// -------------------------------------------------------------------

// Euler

// float heading = 1;
inline void Euler::clear_heading() {
  heading_ = 0;
}
inline float Euler::_internal_heading() const {
  return heading_;
}
inline float Euler::heading() const {
  // @@protoc_insertion_point(field_get:Analytics.Euler.heading)
  return _internal_heading();
}
inline void Euler::_internal_set_heading(float value) {
  
  heading_ = value;
}
inline void Euler::set_heading(float value) {
  _internal_set_heading(value);
  // @@protoc_insertion_point(field_set:Analytics.Euler.heading)
}

// float pitch = 2;
inline void Euler::clear_pitch() {
  pitch_ = 0;
}
inline float Euler::_internal_pitch() const {
  return pitch_;
}
inline float Euler::pitch() const {
  // @@protoc_insertion_point(field_get:Analytics.Euler.pitch)
  return _internal_pitch();
}
inline void Euler::_internal_set_pitch(float value) {
  
  pitch_ = value;
}
inline void Euler::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:Analytics.Euler.pitch)
}

// float roll = 3;
inline void Euler::clear_roll() {
  roll_ = 0;
}
inline float Euler::_internal_roll() const {
  return roll_;
}
inline float Euler::roll() const {
  // @@protoc_insertion_point(field_get:Analytics.Euler.roll)
  return _internal_roll();
}
inline void Euler::_internal_set_roll(float value) {
  
  roll_ = value;
}
inline void Euler::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:Analytics.Euler.roll)
}

// -------------------------------------------------------------------

// Material

// string name = 1;
inline void Material::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Material::name() const {
  // @@protoc_insertion_point(field_get:Analytics.Material.name)
  return _internal_name();
}
inline void Material::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Analytics.Material.name)
}
inline std::string* Material::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Analytics.Material.name)
  return _internal_mutable_name();
}
inline const std::string& Material::_internal_name() const {
  return name_.GetNoArena();
}
inline void Material::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Material::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.Material.name)
}
inline void Material::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.Material.name)
}
inline void Material::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.Material.name)
}
inline std::string* Material::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Material::release_name() {
  // @@protoc_insertion_point(field_release:Analytics.Material.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Material::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Analytics.Material.name)
}

// uint32 contents = 2 [(.Analytics.enumkey) = "CONTENT_FLAGS", (.Analytics.enumflags) = true];
inline void Material::clear_contents() {
  contents_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Material::_internal_contents() const {
  return contents_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Material::contents() const {
  // @@protoc_insertion_point(field_get:Analytics.Material.contents)
  return _internal_contents();
}
inline void Material::_internal_set_contents(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  contents_ = value;
}
inline void Material::set_contents(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_contents(value);
  // @@protoc_insertion_point(field_set:Analytics.Material.contents)
}

// uint32 surfaceFlags = 3 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.enumflags) = true];
inline void Material::clear_surfaceflags() {
  surfaceflags_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Material::_internal_surfaceflags() const {
  return surfaceflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Material::surfaceflags() const {
  // @@protoc_insertion_point(field_get:Analytics.Material.surfaceFlags)
  return _internal_surfaceflags();
}
inline void Material::_internal_set_surfaceflags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  surfaceflags_ = value;
}
inline void Material::set_surfaceflags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_surfaceflags(value);
  // @@protoc_insertion_point(field_set:Analytics.Material.surfaceFlags)
}

// bool renderEvents = 4;
inline void Material::clear_renderevents() {
  renderevents_ = false;
}
inline bool Material::_internal_renderevents() const {
  return renderevents_;
}
inline bool Material::renderevents() const {
  // @@protoc_insertion_point(field_get:Analytics.Material.renderEvents)
  return _internal_renderevents();
}
inline void Material::_internal_set_renderevents(bool value) {
  
  renderevents_ = value;
}
inline void Material::set_renderevents(bool value) {
  _internal_set_renderevents(value);
  // @@protoc_insertion_point(field_set:Analytics.Material.renderEvents)
}

// -------------------------------------------------------------------

// PrimitiveOptions

// uint32 partIndex = 1 [(.Analytics.editable_key) = true];
inline void PrimitiveOptions::clear_partindex() {
  partindex_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PrimitiveOptions::_internal_partindex() const {
  return partindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PrimitiveOptions::partindex() const {
  // @@protoc_insertion_point(field_get:Analytics.PrimitiveOptions.partIndex)
  return _internal_partindex();
}
inline void PrimitiveOptions::_internal_set_partindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  partindex_ = value;
}
inline void PrimitiveOptions::set_partindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_partindex(value);
  // @@protoc_insertion_point(field_set:Analytics.PrimitiveOptions.partIndex)
}

// uint32 overrideSurfaceFlags = 2 [(.Analytics.enumkey) = "SURFACE_FLAGS", (.Analytics.editable) = true, (.Analytics.enumflags) = true];
inline void PrimitiveOptions::clear_overridesurfaceflags() {
  overridesurfaceflags_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PrimitiveOptions::_internal_overridesurfaceflags() const {
  return overridesurfaceflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 PrimitiveOptions::overridesurfaceflags() const {
  // @@protoc_insertion_point(field_get:Analytics.PrimitiveOptions.overrideSurfaceFlags)
  return _internal_overridesurfaceflags();
}
inline void PrimitiveOptions::_internal_set_overridesurfaceflags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  overridesurfaceflags_ = value;
}
inline void PrimitiveOptions::set_overridesurfaceflags(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_overridesurfaceflags(value);
  // @@protoc_insertion_point(field_set:Analytics.PrimitiveOptions.overrideSurfaceFlags)
}

// -------------------------------------------------------------------

// Primitive

// .Analytics.PrimitiveType type = 1;
inline void Primitive::clear_type() {
  type_ = 0;
}
inline ::Analytics::PrimitiveType Primitive::_internal_type() const {
  return static_cast< ::Analytics::PrimitiveType >(type_);
}
inline ::Analytics::PrimitiveType Primitive::type() const {
  // @@protoc_insertion_point(field_get:Analytics.Primitive.type)
  return _internal_type();
}
inline void Primitive::_internal_set_type(::Analytics::PrimitiveType value) {
  
  type_ = value;
}
inline void Primitive::set_type(::Analytics::PrimitiveType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Analytics.Primitive.type)
}

// uint32 materialIndex = 2;
inline void Primitive::clear_materialindex() {
  materialindex_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Primitive::_internal_materialindex() const {
  return materialindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Primitive::materialindex() const {
  // @@protoc_insertion_point(field_get:Analytics.Primitive.materialIndex)
  return _internal_materialindex();
}
inline void Primitive::_internal_set_materialindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  materialindex_ = value;
}
inline void Primitive::set_materialindex(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_materialindex(value);
  // @@protoc_insertion_point(field_set:Analytics.Primitive.materialIndex)
}

// .Analytics.PrimitiveOptions options = 3;
inline bool Primitive::_internal_has_options() const {
  return this != internal_default_instance() && options_ != nullptr;
}
inline bool Primitive::has_options() const {
  return _internal_has_options();
}
inline void Primitive::clear_options() {
  if (GetArenaNoVirtual() == nullptr && options_ != nullptr) {
    delete options_;
  }
  options_ = nullptr;
}
inline const ::Analytics::PrimitiveOptions& Primitive::_internal_options() const {
  const ::Analytics::PrimitiveOptions* p = options_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::PrimitiveOptions*>(
      &::Analytics::_PrimitiveOptions_default_instance_);
}
inline const ::Analytics::PrimitiveOptions& Primitive::options() const {
  // @@protoc_insertion_point(field_get:Analytics.Primitive.options)
  return _internal_options();
}
inline ::Analytics::PrimitiveOptions* Primitive::release_options() {
  // @@protoc_insertion_point(field_release:Analytics.Primitive.options)
  
  ::Analytics::PrimitiveOptions* temp = options_;
  options_ = nullptr;
  return temp;
}
inline ::Analytics::PrimitiveOptions* Primitive::_internal_mutable_options() {
  
  if (options_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::PrimitiveOptions>(GetArenaNoVirtual());
    options_ = p;
  }
  return options_;
}
inline ::Analytics::PrimitiveOptions* Primitive::mutable_options() {
  // @@protoc_insertion_point(field_mutable:Analytics.Primitive.options)
  return _internal_mutable_options();
}
inline void Primitive::set_allocated_options(::Analytics::PrimitiveOptions* options) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete options_;
  }
  if (options) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      options = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, options, submessage_arena);
    }
    
  } else {
    
  }
  options_ = options;
  // @@protoc_insertion_point(field_set_allocated:Analytics.Primitive.options)
}

// float size = 4;
inline void Primitive::clear_size() {
  size_ = 0;
}
inline float Primitive::_internal_size() const {
  return size_;
}
inline float Primitive::size() const {
  // @@protoc_insertion_point(field_get:Analytics.Primitive.size)
  return _internal_size();
}
inline void Primitive::_internal_set_size(float value) {
  
  size_ = value;
}
inline void Primitive::set_size(float value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:Analytics.Primitive.size)
}

// repeated .Analytics.Vec3Color vertices = 5;
inline int Primitive::_internal_vertices_size() const {
  return vertices_.size();
}
inline int Primitive::vertices_size() const {
  return _internal_vertices_size();
}
inline void Primitive::clear_vertices() {
  vertices_.Clear();
}
inline ::Analytics::Vec3Color* Primitive::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.Primitive.vertices)
  return vertices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Vec3Color >*
Primitive::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.Primitive.vertices)
  return &vertices_;
}
inline const ::Analytics::Vec3Color& Primitive::_internal_vertices(int index) const {
  return vertices_.Get(index);
}
inline const ::Analytics::Vec3Color& Primitive::vertices(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.Primitive.vertices)
  return _internal_vertices(index);
}
inline ::Analytics::Vec3Color* Primitive::_internal_add_vertices() {
  return vertices_.Add();
}
inline ::Analytics::Vec3Color* Primitive::add_vertices() {
  // @@protoc_insertion_point(field_add:Analytics.Primitive.vertices)
  return _internal_add_vertices();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Vec3Color >&
Primitive::vertices() const {
  // @@protoc_insertion_point(field_list:Analytics.Primitive.vertices)
  return vertices_;
}

// -------------------------------------------------------------------

// Mesh

// repeated .Analytics.Primitive primitives = 1;
inline int Mesh::_internal_primitives_size() const {
  return primitives_.size();
}
inline int Mesh::primitives_size() const {
  return _internal_primitives_size();
}
inline void Mesh::clear_primitives() {
  primitives_.Clear();
}
inline ::Analytics::Primitive* Mesh::mutable_primitives(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.Mesh.primitives)
  return primitives_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Primitive >*
Mesh::mutable_primitives() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.Mesh.primitives)
  return &primitives_;
}
inline const ::Analytics::Primitive& Mesh::_internal_primitives(int index) const {
  return primitives_.Get(index);
}
inline const ::Analytics::Primitive& Mesh::primitives(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.Mesh.primitives)
  return _internal_primitives(index);
}
inline ::Analytics::Primitive* Mesh::_internal_add_primitives() {
  return primitives_.Add();
}
inline ::Analytics::Primitive* Mesh::add_primitives() {
  // @@protoc_insertion_point(field_add:Analytics.Mesh.primitives)
  return _internal_add_primitives();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Primitive >&
Mesh::primitives() const {
  // @@protoc_insertion_point(field_list:Analytics.Mesh.primitives)
  return primitives_;
}

// repeated .Analytics.Material materials = 2;
inline int Mesh::_internal_materials_size() const {
  return materials_.size();
}
inline int Mesh::materials_size() const {
  return _internal_materials_size();
}
inline void Mesh::clear_materials() {
  materials_.Clear();
}
inline ::Analytics::Material* Mesh::mutable_materials(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.Mesh.materials)
  return materials_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Material >*
Mesh::mutable_materials() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.Mesh.materials)
  return &materials_;
}
inline const ::Analytics::Material& Mesh::_internal_materials(int index) const {
  return materials_.Get(index);
}
inline const ::Analytics::Material& Mesh::materials(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.Mesh.materials)
  return _internal_materials(index);
}
inline ::Analytics::Material* Mesh::_internal_add_materials() {
  return materials_.Add();
}
inline ::Analytics::Material* Mesh::add_materials() {
  // @@protoc_insertion_point(field_add:Analytics.Mesh.materials)
  return _internal_add_materials();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::Material >&
Mesh::materials() const {
  // @@protoc_insertion_point(field_list:Analytics.Mesh.materials)
  return materials_;
}

// string name = 3;
inline void Mesh::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& Mesh::name() const {
  // @@protoc_insertion_point(field_get:Analytics.Mesh.name)
  return _internal_name();
}
inline void Mesh::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Analytics.Mesh.name)
}
inline std::string* Mesh::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Analytics.Mesh.name)
  return _internal_mutable_name();
}
inline const std::string& Mesh::_internal_name() const {
  return name_.GetNoArena();
}
inline void Mesh::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Mesh::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.Mesh.name)
}
inline void Mesh::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.Mesh.name)
}
inline void Mesh::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.Mesh.name)
}
inline std::string* Mesh::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Mesh::release_name() {
  // @@protoc_insertion_point(field_release:Analytics.Mesh.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Mesh::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Analytics.Mesh.name)
}

// -------------------------------------------------------------------

// UTCTime

// int32 hour = 1;
inline void UTCTime::clear_hour() {
  hour_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::_internal_hour() const {
  return hour_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::hour() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.hour)
  return _internal_hour();
}
inline void UTCTime::_internal_set_hour(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  hour_ = value;
}
inline void UTCTime::set_hour(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hour(value);
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.hour)
}

// int32 minute = 2;
inline void UTCTime::clear_minute() {
  minute_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::_internal_minute() const {
  return minute_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::minute() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.minute)
  return _internal_minute();
}
inline void UTCTime::_internal_set_minute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  minute_ = value;
}
inline void UTCTime::set_minute(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minute(value);
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.minute)
}

// int32 second = 3;
inline void UTCTime::clear_second() {
  second_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::_internal_second() const {
  return second_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::second() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.second)
  return _internal_second();
}
inline void UTCTime::_internal_set_second(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  second_ = value;
}
inline void UTCTime::set_second(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_second(value);
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.second)
}

// int32 day = 4;
inline void UTCTime::clear_day() {
  day_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::_internal_day() const {
  return day_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::day() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.day)
  return _internal_day();
}
inline void UTCTime::_internal_set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  day_ = value;
}
inline void UTCTime::set_day(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.day)
}

// int32 month = 5;
inline void UTCTime::clear_month() {
  month_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::_internal_month() const {
  return month_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::month() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.month)
  return _internal_month();
}
inline void UTCTime::_internal_set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  month_ = value;
}
inline void UTCTime::set_month(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.month)
}

// int32 year = 6;
inline void UTCTime::clear_year() {
  year_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::_internal_year() const {
  return year_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 UTCTime::year() const {
  // @@protoc_insertion_point(field_get:Analytics.UTCTime.year)
  return _internal_year();
}
inline void UTCTime::_internal_set_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  year_ = value;
}
inline void UTCTime::set_year(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:Analytics.UTCTime.year)
}

// -------------------------------------------------------------------

// GameInfo

// .Analytics.UTCTime timeStamp = 1;
inline bool GameInfo::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool GameInfo::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void GameInfo::clear_timestamp() {
  if (GetArenaNoVirtual() == nullptr && timestamp_ != nullptr) {
    delete timestamp_;
  }
  timestamp_ = nullptr;
}
inline const ::Analytics::UTCTime& GameInfo::_internal_timestamp() const {
  const ::Analytics::UTCTime* p = timestamp_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::UTCTime*>(
      &::Analytics::_UTCTime_default_instance_);
}
inline const ::Analytics::UTCTime& GameInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInfo.timeStamp)
  return _internal_timestamp();
}
inline ::Analytics::UTCTime* GameInfo::release_timestamp() {
  // @@protoc_insertion_point(field_release:Analytics.GameInfo.timeStamp)
  
  ::Analytics::UTCTime* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::Analytics::UTCTime* GameInfo::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::UTCTime>(GetArenaNoVirtual());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::Analytics::UTCTime* GameInfo::mutable_timestamp() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameInfo.timeStamp)
  return _internal_mutable_timestamp();
}
inline void GameInfo::set_allocated_timestamp(::Analytics::UTCTime* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete timestamp_;
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInfo.timeStamp)
}

// string mapName = 2;
inline void GameInfo::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameInfo::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInfo.mapName)
  return _internal_mapname();
}
inline void GameInfo::set_mapname(const std::string& value) {
  _internal_set_mapname(value);
  // @@protoc_insertion_point(field_set:Analytics.GameInfo.mapName)
}
inline std::string* GameInfo::mutable_mapname() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameInfo.mapName)
  return _internal_mutable_mapname();
}
inline const std::string& GameInfo::_internal_mapname() const {
  return mapname_.GetNoArena();
}
inline void GameInfo::_internal_set_mapname(const std::string& value) {
  
  mapname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameInfo::set_mapname(std::string&& value) {
  
  mapname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameInfo.mapName)
}
inline void GameInfo::set_mapname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mapname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameInfo.mapName)
}
inline void GameInfo::set_mapname(const char* value, size_t size) {
  
  mapname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameInfo.mapName)
}
inline std::string* GameInfo::_internal_mutable_mapname() {
  
  return mapname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameInfo::release_mapname() {
  // @@protoc_insertion_point(field_release:Analytics.GameInfo.mapName)
  
  return mapname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo::set_allocated_mapname(std::string* mapname) {
  if (mapname != nullptr) {
    
  } else {
    
  }
  mapname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInfo.mapName)
}

// string gameName = 3;
inline void GameInfo::clear_gamename() {
  gamename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameInfo::gamename() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInfo.gameName)
  return _internal_gamename();
}
inline void GameInfo::set_gamename(const std::string& value) {
  _internal_set_gamename(value);
  // @@protoc_insertion_point(field_set:Analytics.GameInfo.gameName)
}
inline std::string* GameInfo::mutable_gamename() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameInfo.gameName)
  return _internal_mutable_gamename();
}
inline const std::string& GameInfo::_internal_gamename() const {
  return gamename_.GetNoArena();
}
inline void GameInfo::_internal_set_gamename(const std::string& value) {
  
  gamename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameInfo::set_gamename(std::string&& value) {
  
  gamename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameInfo.gameName)
}
inline void GameInfo::set_gamename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gamename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameInfo.gameName)
}
inline void GameInfo::set_gamename(const char* value, size_t size) {
  
  gamename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameInfo.gameName)
}
inline std::string* GameInfo::_internal_mutable_gamename() {
  
  return gamename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameInfo::release_gamename() {
  // @@protoc_insertion_point(field_release:Analytics.GameInfo.gameName)
  
  return gamename_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo::set_allocated_gamename(std::string* gamename) {
  if (gamename != nullptr) {
    
  } else {
    
  }
  gamename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamename);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInfo.gameName)
}

// string gameVersion = 4;
inline void GameInfo::clear_gameversion() {
  gameversion_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameInfo::gameversion() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInfo.gameVersion)
  return _internal_gameversion();
}
inline void GameInfo::set_gameversion(const std::string& value) {
  _internal_set_gameversion(value);
  // @@protoc_insertion_point(field_set:Analytics.GameInfo.gameVersion)
}
inline std::string* GameInfo::mutable_gameversion() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameInfo.gameVersion)
  return _internal_mutable_gameversion();
}
inline const std::string& GameInfo::_internal_gameversion() const {
  return gameversion_.GetNoArena();
}
inline void GameInfo::_internal_set_gameversion(const std::string& value) {
  
  gameversion_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameInfo::set_gameversion(std::string&& value) {
  
  gameversion_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameInfo.gameVersion)
}
inline void GameInfo::set_gameversion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  gameversion_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameInfo.gameVersion)
}
inline void GameInfo::set_gameversion(const char* value, size_t size) {
  
  gameversion_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameInfo.gameVersion)
}
inline std::string* GameInfo::_internal_mutable_gameversion() {
  
  return gameversion_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameInfo::release_gameversion() {
  // @@protoc_insertion_point(field_release:Analytics.GameInfo.gameVersion)
  
  return gameversion_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameInfo::set_allocated_gameversion(std::string* gameversion) {
  if (gameversion != nullptr) {
    
  } else {
    
  }
  gameversion_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gameversion);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInfo.gameVersion)
}

// -------------------------------------------------------------------

// GameEnum_EnumPair

// string name = 1;
inline void GameEnum_EnumPair::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameEnum_EnumPair::name() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.EnumPair.name)
  return _internal_name();
}
inline void GameEnum_EnumPair::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEnum.EnumPair.name)
}
inline std::string* GameEnum_EnumPair::mutable_name() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEnum.EnumPair.name)
  return _internal_mutable_name();
}
inline const std::string& GameEnum_EnumPair::_internal_name() const {
  return name_.GetNoArena();
}
inline void GameEnum_EnumPair::_internal_set_name(const std::string& value) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameEnum_EnumPair::set_name(std::string&& value) {
  
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameEnum.EnumPair.name)
}
inline void GameEnum_EnumPair::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameEnum.EnumPair.name)
}
inline void GameEnum_EnumPair::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameEnum.EnumPair.name)
}
inline std::string* GameEnum_EnumPair::_internal_mutable_name() {
  
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameEnum_EnumPair::release_name() {
  // @@protoc_insertion_point(field_release:Analytics.GameEnum.EnumPair.name)
  
  return name_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameEnum_EnumPair::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEnum.EnumPair.name)
}

// int64 value = 2;
inline void GameEnum_EnumPair::clear_value() {
  value_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameEnum_EnumPair::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameEnum_EnumPair::value() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.EnumPair.value)
  return _internal_value();
}
inline void GameEnum_EnumPair::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  value_ = value;
}
inline void GameEnum_EnumPair::set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEnum.EnumPair.value)
}

// -------------------------------------------------------------------

// GameEnum

// repeated .Analytics.GameEnum.EnumPair values = 1;
inline int GameEnum::_internal_values_size() const {
  return values_.size();
}
inline int GameEnum::values_size() const {
  return _internal_values_size();
}
inline void GameEnum::clear_values() {
  values_.Clear();
}
inline ::Analytics::GameEnum_EnumPair* GameEnum::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEnum.values)
  return values_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEnum_EnumPair >*
GameEnum::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.GameEnum.values)
  return &values_;
}
inline const ::Analytics::GameEnum_EnumPair& GameEnum::_internal_values(int index) const {
  return values_.Get(index);
}
inline const ::Analytics::GameEnum_EnumPair& GameEnum::values(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.values)
  return _internal_values(index);
}
inline ::Analytics::GameEnum_EnumPair* GameEnum::_internal_add_values() {
  return values_.Add();
}
inline ::Analytics::GameEnum_EnumPair* GameEnum::add_values() {
  // @@protoc_insertion_point(field_add:Analytics.GameEnum.values)
  return _internal_add_values();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEnum_EnumPair >&
GameEnum::values() const {
  // @@protoc_insertion_point(field_list:Analytics.GameEnum.values)
  return values_;
}

// string enumname = 2;
inline void GameEnum::clear_enumname() {
  enumname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameEnum::enumname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.enumname)
  return _internal_enumname();
}
inline void GameEnum::set_enumname(const std::string& value) {
  _internal_set_enumname(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEnum.enumname)
}
inline std::string* GameEnum::mutable_enumname() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEnum.enumname)
  return _internal_mutable_enumname();
}
inline const std::string& GameEnum::_internal_enumname() const {
  return enumname_.GetNoArena();
}
inline void GameEnum::_internal_set_enumname(const std::string& value) {
  
  enumname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameEnum::set_enumname(std::string&& value) {
  
  enumname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameEnum.enumname)
}
inline void GameEnum::set_enumname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  enumname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameEnum.enumname)
}
inline void GameEnum::set_enumname(const char* value, size_t size) {
  
  enumname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameEnum.enumname)
}
inline std::string* GameEnum::_internal_mutable_enumname() {
  
  return enumname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameEnum::release_enumname() {
  // @@protoc_insertion_point(field_release:Analytics.GameEnum.enumname)
  
  return enumname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameEnum::set_allocated_enumname(std::string* enumname) {
  if (enumname != nullptr) {
    
  } else {
    
  }
  enumname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), enumname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEnum.enumname)
}

// bool isbitfield = 3;
inline void GameEnum::clear_isbitfield() {
  isbitfield_ = false;
}
inline bool GameEnum::_internal_isbitfield() const {
  return isbitfield_;
}
inline bool GameEnum::isbitfield() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEnum.isbitfield)
  return _internal_isbitfield();
}
inline void GameEnum::_internal_set_isbitfield(bool value) {
  
  isbitfield_ = value;
}
inline void GameEnum::set_isbitfield(bool value) {
  _internal_set_isbitfield(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEnum.isbitfield)
}

// -------------------------------------------------------------------

// GameNavNotFound

// string mapName = 1;
inline void GameNavNotFound::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameNavNotFound::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavNotFound.mapName)
  return _internal_mapname();
}
inline void GameNavNotFound::set_mapname(const std::string& value) {
  _internal_set_mapname(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNavNotFound.mapName)
}
inline std::string* GameNavNotFound::mutable_mapname() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameNavNotFound.mapName)
  return _internal_mutable_mapname();
}
inline const std::string& GameNavNotFound::_internal_mapname() const {
  return mapname_.GetNoArena();
}
inline void GameNavNotFound::_internal_set_mapname(const std::string& value) {
  
  mapname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameNavNotFound::set_mapname(std::string&& value) {
  
  mapname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNavNotFound.mapName)
}
inline void GameNavNotFound::set_mapname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mapname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNavNotFound.mapName)
}
inline void GameNavNotFound::set_mapname(const char* value, size_t size) {
  
  mapname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNavNotFound.mapName)
}
inline std::string* GameNavNotFound::_internal_mutable_mapname() {
  
  return mapname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameNavNotFound::release_mapname() {
  // @@protoc_insertion_point(field_release:Analytics.GameNavNotFound.mapName)
  
  return mapname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameNavNotFound::set_allocated_mapname(std::string* mapname) {
  if (mapname != nullptr) {
    
  } else {
    
  }
  mapname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNavNotFound.mapName)
}

// -------------------------------------------------------------------

// GameNavAutoDownloaded

// string mapName = 1;
inline void GameNavAutoDownloaded::clear_mapname() {
  mapname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameNavAutoDownloaded::mapname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavAutoDownloaded.mapName)
  return _internal_mapname();
}
inline void GameNavAutoDownloaded::set_mapname(const std::string& value) {
  _internal_set_mapname(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNavAutoDownloaded.mapName)
}
inline std::string* GameNavAutoDownloaded::mutable_mapname() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameNavAutoDownloaded.mapName)
  return _internal_mutable_mapname();
}
inline const std::string& GameNavAutoDownloaded::_internal_mapname() const {
  return mapname_.GetNoArena();
}
inline void GameNavAutoDownloaded::_internal_set_mapname(const std::string& value) {
  
  mapname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameNavAutoDownloaded::set_mapname(std::string&& value) {
  
  mapname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNavAutoDownloaded.mapName)
}
inline void GameNavAutoDownloaded::set_mapname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  mapname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNavAutoDownloaded.mapName)
}
inline void GameNavAutoDownloaded::set_mapname(const char* value, size_t size) {
  
  mapname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNavAutoDownloaded.mapName)
}
inline std::string* GameNavAutoDownloaded::_internal_mutable_mapname() {
  
  return mapname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameNavAutoDownloaded::release_mapname() {
  // @@protoc_insertion_point(field_release:Analytics.GameNavAutoDownloaded.mapName)
  
  return mapname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameNavAutoDownloaded::set_allocated_mapname(std::string* mapname) {
  if (mapname != nullptr) {
    
  } else {
    
  }
  mapname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mapname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNavAutoDownloaded.mapName)
}

// -------------------------------------------------------------------

// GameAssert

// string condition = 1;
inline void GameAssert::clear_condition() {
  condition_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameAssert::condition() const {
  // @@protoc_insertion_point(field_get:Analytics.GameAssert.condition)
  return _internal_condition();
}
inline void GameAssert::set_condition(const std::string& value) {
  _internal_set_condition(value);
  // @@protoc_insertion_point(field_set:Analytics.GameAssert.condition)
}
inline std::string* GameAssert::mutable_condition() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameAssert.condition)
  return _internal_mutable_condition();
}
inline const std::string& GameAssert::_internal_condition() const {
  return condition_.GetNoArena();
}
inline void GameAssert::_internal_set_condition(const std::string& value) {
  
  condition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameAssert::set_condition(std::string&& value) {
  
  condition_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameAssert.condition)
}
inline void GameAssert::set_condition(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  condition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameAssert.condition)
}
inline void GameAssert::set_condition(const char* value, size_t size) {
  
  condition_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameAssert.condition)
}
inline std::string* GameAssert::_internal_mutable_condition() {
  
  return condition_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameAssert::release_condition() {
  // @@protoc_insertion_point(field_release:Analytics.GameAssert.condition)
  
  return condition_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameAssert::set_allocated_condition(std::string* condition) {
  if (condition != nullptr) {
    
  } else {
    
  }
  condition_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), condition);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameAssert.condition)
}

// string file = 2;
inline void GameAssert::clear_file() {
  file_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameAssert::file() const {
  // @@protoc_insertion_point(field_get:Analytics.GameAssert.file)
  return _internal_file();
}
inline void GameAssert::set_file(const std::string& value) {
  _internal_set_file(value);
  // @@protoc_insertion_point(field_set:Analytics.GameAssert.file)
}
inline std::string* GameAssert::mutable_file() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameAssert.file)
  return _internal_mutable_file();
}
inline const std::string& GameAssert::_internal_file() const {
  return file_.GetNoArena();
}
inline void GameAssert::_internal_set_file(const std::string& value) {
  
  file_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameAssert::set_file(std::string&& value) {
  
  file_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameAssert.file)
}
inline void GameAssert::set_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  file_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameAssert.file)
}
inline void GameAssert::set_file(const char* value, size_t size) {
  
  file_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameAssert.file)
}
inline std::string* GameAssert::_internal_mutable_file() {
  
  return file_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameAssert::release_file() {
  // @@protoc_insertion_point(field_release:Analytics.GameAssert.file)
  
  return file_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameAssert::set_allocated_file(std::string* file) {
  if (file != nullptr) {
    
  } else {
    
  }
  file_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameAssert.file)
}

// int32 line = 3;
inline void GameAssert::clear_line() {
  line_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameAssert::_internal_line() const {
  return line_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameAssert::line() const {
  // @@protoc_insertion_point(field_get:Analytics.GameAssert.line)
  return _internal_line();
}
inline void GameAssert::_internal_set_line(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  line_ = value;
}
inline void GameAssert::set_line(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_line(value);
  // @@protoc_insertion_point(field_set:Analytics.GameAssert.line)
}

// -------------------------------------------------------------------

// GameCrash

// string info = 1;
inline void GameCrash::clear_info() {
  info_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameCrash::info() const {
  // @@protoc_insertion_point(field_get:Analytics.GameCrash.info)
  return _internal_info();
}
inline void GameCrash::set_info(const std::string& value) {
  _internal_set_info(value);
  // @@protoc_insertion_point(field_set:Analytics.GameCrash.info)
}
inline std::string* GameCrash::mutable_info() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameCrash.info)
  return _internal_mutable_info();
}
inline const std::string& GameCrash::_internal_info() const {
  return info_.GetNoArena();
}
inline void GameCrash::_internal_set_info(const std::string& value) {
  
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameCrash::set_info(std::string&& value) {
  
  info_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameCrash.info)
}
inline void GameCrash::set_info(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameCrash.info)
}
inline void GameCrash::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameCrash.info)
}
inline std::string* GameCrash::_internal_mutable_info() {
  
  return info_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameCrash::release_info() {
  // @@protoc_insertion_point(field_release:Analytics.GameCrash.info)
  
  return info_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameCrash::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameCrash.info)
}

// -------------------------------------------------------------------

// GameMeshData

// .Analytics.Compression compressionType = 1;
inline void GameMeshData::clear_compressiontype() {
  compressiontype_ = 0;
}
inline ::Analytics::Compression GameMeshData::_internal_compressiontype() const {
  return static_cast< ::Analytics::Compression >(compressiontype_);
}
inline ::Analytics::Compression GameMeshData::compressiontype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameMeshData.compressionType)
  return _internal_compressiontype();
}
inline void GameMeshData::_internal_set_compressiontype(::Analytics::Compression value) {
  
  compressiontype_ = value;
}
inline void GameMeshData::set_compressiontype(::Analytics::Compression value) {
  _internal_set_compressiontype(value);
  // @@protoc_insertion_point(field_set:Analytics.GameMeshData.compressionType)
}

// string modelName = 2;
inline void GameMeshData::clear_modelname() {
  modelname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameMeshData::modelname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameMeshData.modelName)
  return _internal_modelname();
}
inline void GameMeshData::set_modelname(const std::string& value) {
  _internal_set_modelname(value);
  // @@protoc_insertion_point(field_set:Analytics.GameMeshData.modelName)
}
inline std::string* GameMeshData::mutable_modelname() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameMeshData.modelName)
  return _internal_mutable_modelname();
}
inline const std::string& GameMeshData::_internal_modelname() const {
  return modelname_.GetNoArena();
}
inline void GameMeshData::_internal_set_modelname(const std::string& value) {
  
  modelname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameMeshData::set_modelname(std::string&& value) {
  
  modelname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameMeshData.modelName)
}
inline void GameMeshData::set_modelname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  modelname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameMeshData.modelName)
}
inline void GameMeshData::set_modelname(const char* value, size_t size) {
  
  modelname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameMeshData.modelName)
}
inline std::string* GameMeshData::_internal_mutable_modelname() {
  
  return modelname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameMeshData::release_modelname() {
  // @@protoc_insertion_point(field_release:Analytics.GameMeshData.modelName)
  
  return modelname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameMeshData::set_allocated_modelname(std::string* modelname) {
  if (modelname != nullptr) {
    
  } else {
    
  }
  modelname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameMeshData.modelName)
}

// bytes modelBytes = 3;
inline void GameMeshData::clear_modelbytes() {
  modelbytes_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameMeshData::modelbytes() const {
  // @@protoc_insertion_point(field_get:Analytics.GameMeshData.modelBytes)
  return _internal_modelbytes();
}
inline void GameMeshData::set_modelbytes(const std::string& value) {
  _internal_set_modelbytes(value);
  // @@protoc_insertion_point(field_set:Analytics.GameMeshData.modelBytes)
}
inline std::string* GameMeshData::mutable_modelbytes() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameMeshData.modelBytes)
  return _internal_mutable_modelbytes();
}
inline const std::string& GameMeshData::_internal_modelbytes() const {
  return modelbytes_.GetNoArena();
}
inline void GameMeshData::_internal_set_modelbytes(const std::string& value) {
  
  modelbytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameMeshData::set_modelbytes(std::string&& value) {
  
  modelbytes_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameMeshData.modelBytes)
}
inline void GameMeshData::set_modelbytes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  modelbytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameMeshData.modelBytes)
}
inline void GameMeshData::set_modelbytes(const void* value, size_t size) {
  
  modelbytes_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameMeshData.modelBytes)
}
inline std::string* GameMeshData::_internal_mutable_modelbytes() {
  
  return modelbytes_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameMeshData::release_modelbytes() {
  // @@protoc_insertion_point(field_release:Analytics.GameMeshData.modelBytes)
  
  return modelbytes_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameMeshData::set_allocated_modelbytes(std::string* modelbytes) {
  if (modelbytes != nullptr) {
    
  } else {
    
  }
  modelbytes_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), modelbytes);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameMeshData.modelBytes)
}

// uint32 modelBytesUncompressed = 4;
inline void GameMeshData::clear_modelbytesuncompressed() {
  modelbytesuncompressed_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameMeshData::_internal_modelbytesuncompressed() const {
  return modelbytesuncompressed_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameMeshData::modelbytesuncompressed() const {
  // @@protoc_insertion_point(field_get:Analytics.GameMeshData.modelBytesUncompressed)
  return _internal_modelbytesuncompressed();
}
inline void GameMeshData::_internal_set_modelbytesuncompressed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  modelbytesuncompressed_ = value;
}
inline void GameMeshData::set_modelbytesuncompressed(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_modelbytesuncompressed(value);
  // @@protoc_insertion_point(field_set:Analytics.GameMeshData.modelBytesUncompressed)
}

// -------------------------------------------------------------------

// GameEntityInfo_Ammo

// uint32 ammoType = 1 [(.Analytics.enumkey) = "AMMO_TYPE"];
inline void GameEntityInfo_Ammo::clear_ammotype() {
  ammotype_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameEntityInfo_Ammo::_internal_ammotype() const {
  return ammotype_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameEntityInfo_Ammo::ammotype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.Ammo.ammoType)
  return _internal_ammotype();
}
inline void GameEntityInfo_Ammo::_internal_set_ammotype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ammotype_ = value;
}
inline void GameEntityInfo_Ammo::set_ammotype(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ammotype(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.Ammo.ammoType)
}

// uint32 ammoCount = 2;
inline void GameEntityInfo_Ammo::clear_ammocount() {
  ammocount_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameEntityInfo_Ammo::_internal_ammocount() const {
  return ammocount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 GameEntityInfo_Ammo::ammocount() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.Ammo.ammoCount)
  return _internal_ammocount();
}
inline void GameEntityInfo_Ammo::_internal_set_ammocount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  ammocount_ = value;
}
inline void GameEntityInfo_Ammo::set_ammocount(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_ammocount(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.Ammo.ammoCount)
}

// -------------------------------------------------------------------

// GameEntityInfo

// string entityName = 1;
inline void GameEntityInfo::clear_entityname() {
  entityname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameEntityInfo::entityname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entityName)
  return _internal_entityname();
}
inline void GameEntityInfo::set_entityname(const std::string& value) {
  _internal_set_entityname(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entityName)
}
inline std::string* GameEntityInfo::mutable_entityname() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.entityName)
  return _internal_mutable_entityname();
}
inline const std::string& GameEntityInfo::_internal_entityname() const {
  return entityname_.GetNoArena();
}
inline void GameEntityInfo::_internal_set_entityname(const std::string& value) {
  
  entityname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameEntityInfo::set_entityname(std::string&& value) {
  
  entityname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameEntityInfo.entityName)
}
inline void GameEntityInfo::set_entityname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entityname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameEntityInfo.entityName)
}
inline void GameEntityInfo::set_entityname(const char* value, size_t size) {
  
  entityname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameEntityInfo.entityName)
}
inline std::string* GameEntityInfo::_internal_mutable_entityname() {
  
  return entityname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameEntityInfo::release_entityname() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.entityName)
  
  return entityname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameEntityInfo::set_allocated_entityname(std::string* entityname) {
  if (entityname != nullptr) {
    
  } else {
    
  }
  entityname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entityname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.entityName)
}

// int32 entityIndex = 2;
inline void GameEntityInfo::clear_entityindex() {
  entityindex_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::_internal_entityindex() const {
  return entityindex_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::entityindex() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entityIndex)
  return _internal_entityindex();
}
inline void GameEntityInfo::_internal_set_entityindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  entityindex_ = value;
}
inline void GameEntityInfo::set_entityindex(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_entityindex(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entityIndex)
}

// int32 entitySerial = 3;
inline void GameEntityInfo::clear_entityserial() {
  entityserial_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::_internal_entityserial() const {
  return entityserial_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::entityserial() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entitySerial)
  return _internal_entityserial();
}
inline void GameEntityInfo::_internal_set_entityserial(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  entityserial_ = value;
}
inline void GameEntityInfo::set_entityserial(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_entityserial(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entitySerial)
}

// int32 groupId = 4 [(.Analytics.enumkey) = "GROUP_ID"];
inline void GameEntityInfo::clear_groupid() {
  groupid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::_internal_groupid() const {
  return groupid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::groupid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.groupId)
  return _internal_groupid();
}
inline void GameEntityInfo::_internal_set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  groupid_ = value;
}
inline void GameEntityInfo::set_groupid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_groupid(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.groupId)
}

// int32 classId = 5 [(.Analytics.enumkey) = "CLASS_ID"];
inline void GameEntityInfo::clear_classid() {
  classid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::_internal_classid() const {
  return classid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::classid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.classId)
  return _internal_classid();
}
inline void GameEntityInfo::_internal_set_classid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  classid_ = value;
}
inline void GameEntityInfo::set_classid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_classid(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.classId)
}

// int32 team = 6 [(.Analytics.enumkey) = "TEAM_ID"];
inline void GameEntityInfo::clear_team() {
  team_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::_internal_team() const {
  return team_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::team() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.team)
  return _internal_team();
}
inline void GameEntityInfo::_internal_set_team(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  team_ = value;
}
inline void GameEntityInfo::set_team(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_team(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.team)
}

// int64 entityFlags = 7 [(.Analytics.enumkey) = "ENTITY_FLAGS", (.Analytics.enumflagsindexed) = true];
inline void GameEntityInfo::clear_entityflags() {
  entityflags_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameEntityInfo::_internal_entityflags() const {
  return entityflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameEntityInfo::entityflags() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.entityFlags)
  return _internal_entityflags();
}
inline void GameEntityInfo::_internal_set_entityflags(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  entityflags_ = value;
}
inline void GameEntityInfo::set_entityflags(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_entityflags(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.entityFlags)
}

// int32 category = 8 [(.Analytics.enumkey) = "CATEGORY_ID", (.Analytics.enumflagsindexed) = true];
inline void GameEntityInfo::clear_category() {
  category_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::_internal_category() const {
  return category_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::category() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.category)
  return _internal_category();
}
inline void GameEntityInfo::_internal_set_category(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  category_ = value;
}
inline void GameEntityInfo::set_category(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_category(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.category)
}

// int32 powerUps = 9 [(.Analytics.enumkey) = "POWERUP_ID", (.Analytics.enumflagsindexed) = true];
inline void GameEntityInfo::clear_powerups() {
  powerups_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::_internal_powerups() const {
  return powerups_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityInfo::powerups() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.powerUps)
  return _internal_powerups();
}
inline void GameEntityInfo::_internal_set_powerups(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  powerups_ = value;
}
inline void GameEntityInfo::set_powerups(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_powerups(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.powerUps)
}

// int64 navFlags = 10 [(.Analytics.enumkey) = "NAV_FLAGS"];
inline void GameEntityInfo::clear_navflags() {
  navflags_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameEntityInfo::_internal_navflags() const {
  return navflags_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameEntityInfo::navflags() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.navFlags)
  return _internal_navflags();
}
inline void GameEntityInfo::_internal_set_navflags(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  navflags_ = value;
}
inline void GameEntityInfo::set_navflags(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_navflags(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.navFlags)
}

// .Analytics.Vec3 eulerRotation = 11 [(.Analytics.hidden) = true];
inline bool GameEntityInfo::_internal_has_eulerrotation() const {
  return this != internal_default_instance() && eulerrotation_ != nullptr;
}
inline bool GameEntityInfo::has_eulerrotation() const {
  return _internal_has_eulerrotation();
}
inline void GameEntityInfo::clear_eulerrotation() {
  if (GetArenaNoVirtual() == nullptr && eulerrotation_ != nullptr) {
    delete eulerrotation_;
  }
  eulerrotation_ = nullptr;
}
inline const ::Analytics::Vec3& GameEntityInfo::_internal_eulerrotation() const {
  const ::Analytics::Vec3* p = eulerrotation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameEntityInfo::eulerrotation() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.eulerRotation)
  return _internal_eulerrotation();
}
inline ::Analytics::Vec3* GameEntityInfo::release_eulerrotation() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.eulerRotation)
  
  ::Analytics::Vec3* temp = eulerrotation_;
  eulerrotation_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::_internal_mutable_eulerrotation() {
  
  if (eulerrotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    eulerrotation_ = p;
  }
  return eulerrotation_;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_eulerrotation() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.eulerRotation)
  return _internal_mutable_eulerrotation();
}
inline void GameEntityInfo::set_allocated_eulerrotation(::Analytics::Vec3* eulerrotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete eulerrotation_;
  }
  if (eulerrotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eulerrotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eulerrotation, submessage_arena);
    }
    
  } else {
    
  }
  eulerrotation_ = eulerrotation;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.eulerRotation)
}

// .Analytics.Vec3 position = 12 [(.Analytics.hidden) = true];
inline bool GameEntityInfo::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameEntityInfo::has_position() const {
  return _internal_has_position();
}
inline void GameEntityInfo::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameEntityInfo::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameEntityInfo::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameEntityInfo::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.position)
  return _internal_mutable_position();
}
inline void GameEntityInfo::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.position)
}

// .Analytics.Vec3 eyeOffset = 13 [(.Analytics.hidden) = true];
inline bool GameEntityInfo::_internal_has_eyeoffset() const {
  return this != internal_default_instance() && eyeoffset_ != nullptr;
}
inline bool GameEntityInfo::has_eyeoffset() const {
  return _internal_has_eyeoffset();
}
inline void GameEntityInfo::clear_eyeoffset() {
  if (GetArenaNoVirtual() == nullptr && eyeoffset_ != nullptr) {
    delete eyeoffset_;
  }
  eyeoffset_ = nullptr;
}
inline const ::Analytics::Vec3& GameEntityInfo::_internal_eyeoffset() const {
  const ::Analytics::Vec3* p = eyeoffset_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameEntityInfo::eyeoffset() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.eyeOffset)
  return _internal_eyeoffset();
}
inline ::Analytics::Vec3* GameEntityInfo::release_eyeoffset() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.eyeOffset)
  
  ::Analytics::Vec3* temp = eyeoffset_;
  eyeoffset_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::_internal_mutable_eyeoffset() {
  
  if (eyeoffset_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    eyeoffset_ = p;
  }
  return eyeoffset_;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_eyeoffset() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.eyeOffset)
  return _internal_mutable_eyeoffset();
}
inline void GameEntityInfo::set_allocated_eyeoffset(::Analytics::Vec3* eyeoffset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete eyeoffset_;
  }
  if (eyeoffset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eyeoffset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eyeoffset, submessage_arena);
    }
    
  } else {
    
  }
  eyeoffset_ = eyeoffset;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.eyeOffset)
}

// .Analytics.Vec3 eyeDir = 14 [(.Analytics.hidden) = true];
inline bool GameEntityInfo::_internal_has_eyedir() const {
  return this != internal_default_instance() && eyedir_ != nullptr;
}
inline bool GameEntityInfo::has_eyedir() const {
  return _internal_has_eyedir();
}
inline void GameEntityInfo::clear_eyedir() {
  if (GetArenaNoVirtual() == nullptr && eyedir_ != nullptr) {
    delete eyedir_;
  }
  eyedir_ = nullptr;
}
inline const ::Analytics::Vec3& GameEntityInfo::_internal_eyedir() const {
  const ::Analytics::Vec3* p = eyedir_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameEntityInfo::eyedir() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.eyeDir)
  return _internal_eyedir();
}
inline ::Analytics::Vec3* GameEntityInfo::release_eyedir() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.eyeDir)
  
  ::Analytics::Vec3* temp = eyedir_;
  eyedir_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::_internal_mutable_eyedir() {
  
  if (eyedir_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    eyedir_ = p;
  }
  return eyedir_;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_eyedir() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.eyeDir)
  return _internal_mutable_eyedir();
}
inline void GameEntityInfo::set_allocated_eyedir(::Analytics::Vec3* eyedir) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete eyedir_;
  }
  if (eyedir) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eyedir = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eyedir, submessage_arena);
    }
    
  } else {
    
  }
  eyedir_ = eyedir;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.eyeDir)
}

// .Analytics.RangeI health = 15;
inline bool GameEntityInfo::_internal_has_health() const {
  return this != internal_default_instance() && health_ != nullptr;
}
inline bool GameEntityInfo::has_health() const {
  return _internal_has_health();
}
inline void GameEntityInfo::clear_health() {
  if (GetArenaNoVirtual() == nullptr && health_ != nullptr) {
    delete health_;
  }
  health_ = nullptr;
}
inline const ::Analytics::RangeI& GameEntityInfo::_internal_health() const {
  const ::Analytics::RangeI* p = health_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::RangeI*>(
      &::Analytics::_RangeI_default_instance_);
}
inline const ::Analytics::RangeI& GameEntityInfo::health() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.health)
  return _internal_health();
}
inline ::Analytics::RangeI* GameEntityInfo::release_health() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.health)
  
  ::Analytics::RangeI* temp = health_;
  health_ = nullptr;
  return temp;
}
inline ::Analytics::RangeI* GameEntityInfo::_internal_mutable_health() {
  
  if (health_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::RangeI>(GetArenaNoVirtual());
    health_ = p;
  }
  return health_;
}
inline ::Analytics::RangeI* GameEntityInfo::mutable_health() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.health)
  return _internal_mutable_health();
}
inline void GameEntityInfo::set_allocated_health(::Analytics::RangeI* health) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete health_;
  }
  if (health) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      health = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, health, submessage_arena);
    }
    
  } else {
    
  }
  health_ = health;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.health)
}

// .Analytics.RangeI armor = 16;
inline bool GameEntityInfo::_internal_has_armor() const {
  return this != internal_default_instance() && armor_ != nullptr;
}
inline bool GameEntityInfo::has_armor() const {
  return _internal_has_armor();
}
inline void GameEntityInfo::clear_armor() {
  if (GetArenaNoVirtual() == nullptr && armor_ != nullptr) {
    delete armor_;
  }
  armor_ = nullptr;
}
inline const ::Analytics::RangeI& GameEntityInfo::_internal_armor() const {
  const ::Analytics::RangeI* p = armor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::RangeI*>(
      &::Analytics::_RangeI_default_instance_);
}
inline const ::Analytics::RangeI& GameEntityInfo::armor() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.armor)
  return _internal_armor();
}
inline ::Analytics::RangeI* GameEntityInfo::release_armor() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.armor)
  
  ::Analytics::RangeI* temp = armor_;
  armor_ = nullptr;
  return temp;
}
inline ::Analytics::RangeI* GameEntityInfo::_internal_mutable_armor() {
  
  if (armor_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::RangeI>(GetArenaNoVirtual());
    armor_ = p;
  }
  return armor_;
}
inline ::Analytics::RangeI* GameEntityInfo::mutable_armor() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.armor)
  return _internal_mutable_armor();
}
inline void GameEntityInfo::set_allocated_armor(::Analytics::RangeI* armor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete armor_;
  }
  if (armor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      armor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, armor, submessage_arena);
    }
    
  } else {
    
  }
  armor_ = armor;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.armor)
}

// .Analytics.Vec3 boundsMin = 17;
inline bool GameEntityInfo::_internal_has_boundsmin() const {
  return this != internal_default_instance() && boundsmin_ != nullptr;
}
inline bool GameEntityInfo::has_boundsmin() const {
  return _internal_has_boundsmin();
}
inline void GameEntityInfo::clear_boundsmin() {
  if (GetArenaNoVirtual() == nullptr && boundsmin_ != nullptr) {
    delete boundsmin_;
  }
  boundsmin_ = nullptr;
}
inline const ::Analytics::Vec3& GameEntityInfo::_internal_boundsmin() const {
  const ::Analytics::Vec3* p = boundsmin_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameEntityInfo::boundsmin() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.boundsMin)
  return _internal_boundsmin();
}
inline ::Analytics::Vec3* GameEntityInfo::release_boundsmin() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.boundsMin)
  
  ::Analytics::Vec3* temp = boundsmin_;
  boundsmin_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::_internal_mutable_boundsmin() {
  
  if (boundsmin_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    boundsmin_ = p;
  }
  return boundsmin_;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_boundsmin() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.boundsMin)
  return _internal_mutable_boundsmin();
}
inline void GameEntityInfo::set_allocated_boundsmin(::Analytics::Vec3* boundsmin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete boundsmin_;
  }
  if (boundsmin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      boundsmin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boundsmin, submessage_arena);
    }
    
  } else {
    
  }
  boundsmin_ = boundsmin;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.boundsMin)
}

// .Analytics.Vec3 boundsMax = 18;
inline bool GameEntityInfo::_internal_has_boundsmax() const {
  return this != internal_default_instance() && boundsmax_ != nullptr;
}
inline bool GameEntityInfo::has_boundsmax() const {
  return _internal_has_boundsmax();
}
inline void GameEntityInfo::clear_boundsmax() {
  if (GetArenaNoVirtual() == nullptr && boundsmax_ != nullptr) {
    delete boundsmax_;
  }
  boundsmax_ = nullptr;
}
inline const ::Analytics::Vec3& GameEntityInfo::_internal_boundsmax() const {
  const ::Analytics::Vec3* p = boundsmax_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameEntityInfo::boundsmax() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.boundsMax)
  return _internal_boundsmax();
}
inline ::Analytics::Vec3* GameEntityInfo::release_boundsmax() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityInfo.boundsMax)
  
  ::Analytics::Vec3* temp = boundsmax_;
  boundsmax_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameEntityInfo::_internal_mutable_boundsmax() {
  
  if (boundsmax_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    boundsmax_ = p;
  }
  return boundsmax_;
}
inline ::Analytics::Vec3* GameEntityInfo::mutable_boundsmax() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.boundsMax)
  return _internal_mutable_boundsmax();
}
inline void GameEntityInfo::set_allocated_boundsmax(::Analytics::Vec3* boundsmax) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete boundsmax_;
  }
  if (boundsmax) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      boundsmax = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, boundsmax, submessage_arena);
    }
    
  } else {
    
  }
  boundsmax_ = boundsmax;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityInfo.boundsMax)
}

// repeated .Analytics.GameEntityInfo.Ammo ammo = 19;
inline int GameEntityInfo::_internal_ammo_size() const {
  return ammo_.size();
}
inline int GameEntityInfo::ammo_size() const {
  return _internal_ammo_size();
}
inline void GameEntityInfo::clear_ammo() {
  ammo_.Clear();
}
inline ::Analytics::GameEntityInfo_Ammo* GameEntityInfo::mutable_ammo(int index) {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityInfo.ammo)
  return ammo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >*
GameEntityInfo::mutable_ammo() {
  // @@protoc_insertion_point(field_mutable_list:Analytics.GameEntityInfo.ammo)
  return &ammo_;
}
inline const ::Analytics::GameEntityInfo_Ammo& GameEntityInfo::_internal_ammo(int index) const {
  return ammo_.Get(index);
}
inline const ::Analytics::GameEntityInfo_Ammo& GameEntityInfo::ammo(int index) const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.ammo)
  return _internal_ammo(index);
}
inline ::Analytics::GameEntityInfo_Ammo* GameEntityInfo::_internal_add_ammo() {
  return ammo_.Add();
}
inline ::Analytics::GameEntityInfo_Ammo* GameEntityInfo::add_ammo() {
  // @@protoc_insertion_point(field_add:Analytics.GameEntityInfo.ammo)
  return _internal_add_ammo();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Analytics::GameEntityInfo_Ammo >&
GameEntityInfo::ammo() const {
  // @@protoc_insertion_point(field_list:Analytics.GameEntityInfo.ammo)
  return ammo_;
}

// bool deleted = 1000 [(.Analytics.hidden) = true];
inline void GameEntityInfo::clear_deleted() {
  deleted_ = false;
}
inline bool GameEntityInfo::_internal_deleted() const {
  return deleted_;
}
inline bool GameEntityInfo::deleted() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityInfo.deleted)
  return _internal_deleted();
}
inline void GameEntityInfo::_internal_set_deleted(bool value) {
  
  deleted_ = value;
}
inline void GameEntityInfo::set_deleted(bool value) {
  _internal_set_deleted(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityInfo.deleted)
}

// -------------------------------------------------------------------

// GameEntityPosition

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameEntityPosition::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameEntityPosition::has_position() const {
  return _internal_has_position();
}
inline void GameEntityPosition::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameEntityPosition::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameEntityPosition::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityPosition.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameEntityPosition::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameEntityPosition.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameEntityPosition::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameEntityPosition::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameEntityPosition.position)
  return _internal_mutable_position();
}
inline void GameEntityPosition::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameEntityPosition.position)
}

// int32 team = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameEntityPosition::clear_team() {
  team_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityPosition::_internal_team() const {
  return team_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameEntityPosition::team() const {
  // @@protoc_insertion_point(field_get:Analytics.GameEntityPosition.team)
  return _internal_team();
}
inline void GameEntityPosition::_internal_set_team(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  team_ = value;
}
inline void GameEntityPosition::set_team(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_team(value);
  // @@protoc_insertion_point(field_set:Analytics.GameEntityPosition.team)
}

// -------------------------------------------------------------------

// GameNode

// string nodePath = 1 [(.Analytics.editable_key) = true];
inline void GameNode::clear_nodepath() {
  nodepath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameNode::nodepath() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.nodePath)
  return _internal_nodepath();
}
inline void GameNode::set_nodepath(const std::string& value) {
  _internal_set_nodepath(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.nodePath)
}
inline std::string* GameNode::mutable_nodepath() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.nodePath)
  return _internal_mutable_nodepath();
}
inline const std::string& GameNode::_internal_nodepath() const {
  return nodepath_.GetNoArena();
}
inline void GameNode::_internal_set_nodepath(const std::string& value) {
  
  nodepath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameNode::set_nodepath(std::string&& value) {
  
  nodepath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNode.nodePath)
}
inline void GameNode::set_nodepath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  nodepath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNode.nodePath)
}
inline void GameNode::set_nodepath(const char* value, size_t size) {
  
  nodepath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNode.nodePath)
}
inline std::string* GameNode::_internal_mutable_nodepath() {
  
  return nodepath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameNode::release_nodepath() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.nodePath)
  
  return nodepath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameNode::set_allocated_nodepath(std::string* nodepath) {
  if (nodepath != nullptr) {
    
  } else {
    
  }
  nodepath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nodepath);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.nodePath)
}

// .Analytics.Vec3 eulerRotation = 2;
inline bool GameNode::_internal_has_eulerrotation() const {
  return this != internal_default_instance() && eulerrotation_ != nullptr;
}
inline bool GameNode::has_eulerrotation() const {
  return _internal_has_eulerrotation();
}
inline void GameNode::clear_eulerrotation() {
  if (GetArenaNoVirtual() == nullptr && eulerrotation_ != nullptr) {
    delete eulerrotation_;
  }
  eulerrotation_ = nullptr;
}
inline const ::Analytics::Vec3& GameNode::_internal_eulerrotation() const {
  const ::Analytics::Vec3* p = eulerrotation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameNode::eulerrotation() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.eulerRotation)
  return _internal_eulerrotation();
}
inline ::Analytics::Vec3* GameNode::release_eulerrotation() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.eulerRotation)
  
  ::Analytics::Vec3* temp = eulerrotation_;
  eulerrotation_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameNode::_internal_mutable_eulerrotation() {
  
  if (eulerrotation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    eulerrotation_ = p;
  }
  return eulerrotation_;
}
inline ::Analytics::Vec3* GameNode::mutable_eulerrotation() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.eulerRotation)
  return _internal_mutable_eulerrotation();
}
inline void GameNode::set_allocated_eulerrotation(::Analytics::Vec3* eulerrotation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete eulerrotation_;
  }
  if (eulerrotation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      eulerrotation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, eulerrotation, submessage_arena);
    }
    
  } else {
    
  }
  eulerrotation_ = eulerrotation;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.eulerRotation)
}

// .Analytics.Vec3 translation = 3;
inline bool GameNode::_internal_has_translation() const {
  return this != internal_default_instance() && translation_ != nullptr;
}
inline bool GameNode::has_translation() const {
  return _internal_has_translation();
}
inline void GameNode::clear_translation() {
  if (GetArenaNoVirtual() == nullptr && translation_ != nullptr) {
    delete translation_;
  }
  translation_ = nullptr;
}
inline const ::Analytics::Vec3& GameNode::_internal_translation() const {
  const ::Analytics::Vec3* p = translation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameNode::translation() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.translation)
  return _internal_translation();
}
inline ::Analytics::Vec3* GameNode::release_translation() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.translation)
  
  ::Analytics::Vec3* temp = translation_;
  translation_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameNode::_internal_mutable_translation() {
  
  if (translation_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    translation_ = p;
  }
  return translation_;
}
inline ::Analytics::Vec3* GameNode::mutable_translation() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.translation)
  return _internal_mutable_translation();
}
inline void GameNode::set_allocated_translation(::Analytics::Vec3* translation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete translation_;
  }
  if (translation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      translation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, translation, submessage_arena);
    }
    
  } else {
    
  }
  translation_ = translation;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.translation)
}

// string meshName = 4;
inline void GameNode::clear_meshname() {
  meshname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameNode::meshname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.meshName)
  return _internal_meshname();
}
inline void GameNode::set_meshname(const std::string& value) {
  _internal_set_meshname(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.meshName)
}
inline std::string* GameNode::mutable_meshname() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.meshName)
  return _internal_mutable_meshname();
}
inline const std::string& GameNode::_internal_meshname() const {
  return meshname_.GetNoArena();
}
inline void GameNode::_internal_set_meshname(const std::string& value) {
  
  meshname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameNode::set_meshname(std::string&& value) {
  
  meshname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNode.meshName)
}
inline void GameNode::set_meshname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  meshname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNode.meshName)
}
inline void GameNode::set_meshname(const char* value, size_t size) {
  
  meshname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNode.meshName)
}
inline std::string* GameNode::_internal_mutable_meshname() {
  
  return meshname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameNode::release_meshname() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.meshName)
  
  return meshname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameNode::set_allocated_meshname(std::string* meshname) {
  if (meshname != nullptr) {
    
  } else {
    
  }
  meshname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), meshname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.meshName)
}

// int32 entityId = 10;
inline void GameNode::clear_entityid() {
  entityid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameNode::_internal_entityid() const {
  return entityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameNode::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.entityId)
  return _internal_entityid();
}
inline void GameNode::_internal_set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  entityid_ = value;
}
inline void GameNode::set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_entityid(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.entityId)
}

// string entityName = 11;
inline void GameNode::clear_entityname() {
  entityname_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameNode::entityname() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.entityName)
  return _internal_entityname();
}
inline void GameNode::set_entityname(const std::string& value) {
  _internal_set_entityname(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.entityName)
}
inline std::string* GameNode::mutable_entityname() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameNode.entityName)
  return _internal_mutable_entityname();
}
inline const std::string& GameNode::_internal_entityname() const {
  return entityname_.GetNoArena();
}
inline void GameNode::_internal_set_entityname(const std::string& value) {
  
  entityname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameNode::set_entityname(std::string&& value) {
  
  entityname_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameNode.entityName)
}
inline void GameNode::set_entityname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  entityname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameNode.entityName)
}
inline void GameNode::set_entityname(const char* value, size_t size) {
  
  entityname_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameNode.entityName)
}
inline std::string* GameNode::_internal_mutable_entityname() {
  
  return entityname_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameNode::release_entityname() {
  // @@protoc_insertion_point(field_release:Analytics.GameNode.entityName)
  
  return entityname_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameNode::set_allocated_entityname(std::string* entityname) {
  if (entityname != nullptr) {
    
  } else {
    
  }
  entityname_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), entityname);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNode.entityName)
}

// int32 activeState = 12 [(.Analytics.enumkey) = "MODEL_STATE"];
inline void GameNode::clear_activestate() {
  activestate_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameNode::_internal_activestate() const {
  return activestate_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameNode::activestate() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.activeState)
  return _internal_activestate();
}
inline void GameNode::_internal_set_activestate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  activestate_ = value;
}
inline void GameNode::set_activestate(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_activestate(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.activeState)
}

// int64 navFlagsActive = 13 [(.Analytics.enumkey) = "NAV_FLAGS"];
inline void GameNode::clear_navflagsactive() {
  navflagsactive_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameNode::_internal_navflagsactive() const {
  return navflagsactive_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameNode::navflagsactive() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.navFlagsActive)
  return _internal_navflagsactive();
}
inline void GameNode::_internal_set_navflagsactive(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  navflagsactive_ = value;
}
inline void GameNode::set_navflagsactive(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_navflagsactive(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.navFlagsActive)
}

// int64 navFlagsOverride = 14 [(.Analytics.enumkey) = "NAV_FLAGS", (.Analytics.editable) = true];
inline void GameNode::clear_navflagsoverride() {
  navflagsoverride_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameNode::_internal_navflagsoverride() const {
  return navflagsoverride_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GameNode::navflagsoverride() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.navFlagsOverride)
  return _internal_navflagsoverride();
}
inline void GameNode::_internal_set_navflagsoverride(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  navflagsoverride_ = value;
}
inline void GameNode::set_navflagsoverride(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_navflagsoverride(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.navFlagsOverride)
}

// int32 shapeMode = 15 [(.Analytics.enumkey) = "SHAPEMODE", (.Analytics.editable) = true];
inline void GameNode::clear_shapemode() {
  shapemode_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameNode::_internal_shapemode() const {
  return shapemode_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameNode::shapemode() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNode.shapeMode)
  return _internal_shapemode();
}
inline void GameNode::_internal_set_shapemode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  shapemode_ = value;
}
inline void GameNode::set_shapemode(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_shapemode(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNode.shapeMode)
}

// -------------------------------------------------------------------

// GameWeaponFired

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameWeaponFired::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameWeaponFired::has_position() const {
  return _internal_has_position();
}
inline void GameWeaponFired::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameWeaponFired::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameWeaponFired::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameWeaponFired::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameWeaponFired.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameWeaponFired::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameWeaponFired::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameWeaponFired.position)
  return _internal_mutable_position();
}
inline void GameWeaponFired::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameWeaponFired.position)
}

// int32 attackTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameWeaponFired::clear_attackteam() {
  attackteam_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameWeaponFired::_internal_attackteam() const {
  return attackteam_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameWeaponFired::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.attackTeam)
  return _internal_attackteam();
}
inline void GameWeaponFired::_internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attackteam_ = value;
}
inline void GameWeaponFired::set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attackteam(value);
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.attackTeam)
}

// int32 weaponId = 3 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
inline void GameWeaponFired::clear_weaponid() {
  weaponid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameWeaponFired::_internal_weaponid() const {
  return weaponid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameWeaponFired::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.weaponId)
  return _internal_weaponid();
}
inline void GameWeaponFired::_internal_set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weaponid_ = value;
}
inline void GameWeaponFired::set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weaponid(value);
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.weaponId)
}

// int32 firedByClass = 4 [(.Analytics.enumkey) = "CLASS_ID", (.Analytics.track_event) = true];
inline void GameWeaponFired::clear_firedbyclass() {
  firedbyclass_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameWeaponFired::_internal_firedbyclass() const {
  return firedbyclass_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameWeaponFired::firedbyclass() const {
  // @@protoc_insertion_point(field_get:Analytics.GameWeaponFired.firedByClass)
  return _internal_firedbyclass();
}
inline void GameWeaponFired::_internal_set_firedbyclass(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  firedbyclass_ = value;
}
inline void GameWeaponFired::set_firedbyclass(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_firedbyclass(value);
  // @@protoc_insertion_point(field_set:Analytics.GameWeaponFired.firedByClass)
}

// -------------------------------------------------------------------

// GameDeath

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameDeath::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameDeath::has_position() const {
  return _internal_has_position();
}
inline void GameDeath::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameDeath::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameDeath::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameDeath::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameDeath.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameDeath::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameDeath::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameDeath.position)
  return _internal_mutable_position();
}
inline void GameDeath::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameDeath.position)
}

// int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameDeath::clear_victimteam() {
  victimteam_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameDeath::_internal_victimteam() const {
  return victimteam_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameDeath::victimteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.victimTeam)
  return _internal_victimteam();
}
inline void GameDeath::_internal_set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  victimteam_ = value;
}
inline void GameDeath::set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_victimteam(value);
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.victimTeam)
}

// int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameDeath::clear_attackteam() {
  attackteam_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameDeath::_internal_attackteam() const {
  return attackteam_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameDeath::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.attackTeam)
  return _internal_attackteam();
}
inline void GameDeath::_internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attackteam_ = value;
}
inline void GameDeath::set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attackteam(value);
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.attackTeam)
}

// string meansOfDeath = 4 [(.Analytics.track_event) = true];
inline void GameDeath::clear_meansofdeath() {
  meansofdeath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameDeath::meansofdeath() const {
  // @@protoc_insertion_point(field_get:Analytics.GameDeath.meansOfDeath)
  return _internal_meansofdeath();
}
inline void GameDeath::set_meansofdeath(const std::string& value) {
  _internal_set_meansofdeath(value);
  // @@protoc_insertion_point(field_set:Analytics.GameDeath.meansOfDeath)
}
inline std::string* GameDeath::mutable_meansofdeath() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameDeath.meansOfDeath)
  return _internal_mutable_meansofdeath();
}
inline const std::string& GameDeath::_internal_meansofdeath() const {
  return meansofdeath_.GetNoArena();
}
inline void GameDeath::_internal_set_meansofdeath(const std::string& value) {
  
  meansofdeath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameDeath::set_meansofdeath(std::string&& value) {
  
  meansofdeath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameDeath.meansOfDeath)
}
inline void GameDeath::set_meansofdeath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  meansofdeath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameDeath.meansOfDeath)
}
inline void GameDeath::set_meansofdeath(const char* value, size_t size) {
  
  meansofdeath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameDeath.meansOfDeath)
}
inline std::string* GameDeath::_internal_mutable_meansofdeath() {
  
  return meansofdeath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameDeath::release_meansofdeath() {
  // @@protoc_insertion_point(field_release:Analytics.GameDeath.meansOfDeath)
  
  return meansofdeath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameDeath::set_allocated_meansofdeath(std::string* meansofdeath) {
  if (meansofdeath != nullptr) {
    
  } else {
    
  }
  meansofdeath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), meansofdeath);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameDeath.meansOfDeath)
}

// -------------------------------------------------------------------

// GameKilledSomeone

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameKilledSomeone::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameKilledSomeone::has_position() const {
  return _internal_has_position();
}
inline void GameKilledSomeone::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameKilledSomeone::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameKilledSomeone::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameKilledSomeone.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameKilledSomeone::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameKilledSomeone.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameKilledSomeone::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameKilledSomeone::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameKilledSomeone.position)
  return _internal_mutable_position();
}
inline void GameKilledSomeone::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameKilledSomeone.position)
}

// int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameKilledSomeone::clear_victimteam() {
  victimteam_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameKilledSomeone::_internal_victimteam() const {
  return victimteam_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameKilledSomeone::victimteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameKilledSomeone.victimTeam)
  return _internal_victimteam();
}
inline void GameKilledSomeone::_internal_set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  victimteam_ = value;
}
inline void GameKilledSomeone::set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_victimteam(value);
  // @@protoc_insertion_point(field_set:Analytics.GameKilledSomeone.victimTeam)
}

// int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameKilledSomeone::clear_attackteam() {
  attackteam_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameKilledSomeone::_internal_attackteam() const {
  return attackteam_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameKilledSomeone::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameKilledSomeone.attackTeam)
  return _internal_attackteam();
}
inline void GameKilledSomeone::_internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attackteam_ = value;
}
inline void GameKilledSomeone::set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attackteam(value);
  // @@protoc_insertion_point(field_set:Analytics.GameKilledSomeone.attackTeam)
}

// string meansOfDeath = 4 [(.Analytics.track_event) = true];
inline void GameKilledSomeone::clear_meansofdeath() {
  meansofdeath_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameKilledSomeone::meansofdeath() const {
  // @@protoc_insertion_point(field_get:Analytics.GameKilledSomeone.meansOfDeath)
  return _internal_meansofdeath();
}
inline void GameKilledSomeone::set_meansofdeath(const std::string& value) {
  _internal_set_meansofdeath(value);
  // @@protoc_insertion_point(field_set:Analytics.GameKilledSomeone.meansOfDeath)
}
inline std::string* GameKilledSomeone::mutable_meansofdeath() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameKilledSomeone.meansOfDeath)
  return _internal_mutable_meansofdeath();
}
inline const std::string& GameKilledSomeone::_internal_meansofdeath() const {
  return meansofdeath_.GetNoArena();
}
inline void GameKilledSomeone::_internal_set_meansofdeath(const std::string& value) {
  
  meansofdeath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameKilledSomeone::set_meansofdeath(std::string&& value) {
  
  meansofdeath_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameKilledSomeone.meansOfDeath)
}
inline void GameKilledSomeone::set_meansofdeath(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  meansofdeath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameKilledSomeone.meansOfDeath)
}
inline void GameKilledSomeone::set_meansofdeath(const char* value, size_t size) {
  
  meansofdeath_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameKilledSomeone.meansOfDeath)
}
inline std::string* GameKilledSomeone::_internal_mutable_meansofdeath() {
  
  return meansofdeath_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameKilledSomeone::release_meansofdeath() {
  // @@protoc_insertion_point(field_release:Analytics.GameKilledSomeone.meansOfDeath)
  
  return meansofdeath_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameKilledSomeone::set_allocated_meansofdeath(std::string* meansofdeath) {
  if (meansofdeath != nullptr) {
    
  } else {
    
  }
  meansofdeath_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), meansofdeath);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameKilledSomeone.meansOfDeath)
}

// -------------------------------------------------------------------

// GameRecieveDamage

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameRecieveDamage::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameRecieveDamage::has_position() const {
  return _internal_has_position();
}
inline void GameRecieveDamage::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameRecieveDamage::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameRecieveDamage::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameRecieveDamage::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameRecieveDamage.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameRecieveDamage::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameRecieveDamage::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameRecieveDamage.position)
  return _internal_mutable_position();
}
inline void GameRecieveDamage::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameRecieveDamage.position)
}

// int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameRecieveDamage::clear_victimteam() {
  victimteam_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameRecieveDamage::_internal_victimteam() const {
  return victimteam_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameRecieveDamage::victimteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.victimTeam)
  return _internal_victimteam();
}
inline void GameRecieveDamage::_internal_set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  victimteam_ = value;
}
inline void GameRecieveDamage::set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_victimteam(value);
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.victimTeam)
}

// int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameRecieveDamage::clear_attackteam() {
  attackteam_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameRecieveDamage::_internal_attackteam() const {
  return attackteam_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameRecieveDamage::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.attackTeam)
  return _internal_attackteam();
}
inline void GameRecieveDamage::_internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attackteam_ = value;
}
inline void GameRecieveDamage::set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attackteam(value);
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.attackTeam)
}

// int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
inline void GameRecieveDamage::clear_weaponid() {
  weaponid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameRecieveDamage::_internal_weaponid() const {
  return weaponid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameRecieveDamage::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.weaponId)
  return _internal_weaponid();
}
inline void GameRecieveDamage::_internal_set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weaponid_ = value;
}
inline void GameRecieveDamage::set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weaponid(value);
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.weaponId)
}

// string damageType = 5 [(.Analytics.track_event) = true];
inline void GameRecieveDamage::clear_damagetype() {
  damagetype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameRecieveDamage::damagetype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.damageType)
  return _internal_damagetype();
}
inline void GameRecieveDamage::set_damagetype(const std::string& value) {
  _internal_set_damagetype(value);
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.damageType)
}
inline std::string* GameRecieveDamage::mutable_damagetype() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameRecieveDamage.damageType)
  return _internal_mutable_damagetype();
}
inline const std::string& GameRecieveDamage::_internal_damagetype() const {
  return damagetype_.GetNoArena();
}
inline void GameRecieveDamage::_internal_set_damagetype(const std::string& value) {
  
  damagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameRecieveDamage::set_damagetype(std::string&& value) {
  
  damagetype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameRecieveDamage.damageType)
}
inline void GameRecieveDamage::set_damagetype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  damagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameRecieveDamage.damageType)
}
inline void GameRecieveDamage::set_damagetype(const char* value, size_t size) {
  
  damagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameRecieveDamage.damageType)
}
inline std::string* GameRecieveDamage::_internal_mutable_damagetype() {
  
  return damagetype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameRecieveDamage::release_damagetype() {
  // @@protoc_insertion_point(field_release:Analytics.GameRecieveDamage.damageType)
  
  return damagetype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameRecieveDamage::set_allocated_damagetype(std::string* damagetype) {
  if (damagetype != nullptr) {
    
  } else {
    
  }
  damagetype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), damagetype);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameRecieveDamage.damageType)
}

// float damageAmount = 6;
inline void GameRecieveDamage::clear_damageamount() {
  damageamount_ = 0;
}
inline float GameRecieveDamage::_internal_damageamount() const {
  return damageamount_;
}
inline float GameRecieveDamage::damageamount() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRecieveDamage.damageAmount)
  return _internal_damageamount();
}
inline void GameRecieveDamage::_internal_set_damageamount(float value) {
  
  damageamount_ = value;
}
inline void GameRecieveDamage::set_damageamount(float value) {
  _internal_set_damageamount(value);
  // @@protoc_insertion_point(field_set:Analytics.GameRecieveDamage.damageAmount)
}

// -------------------------------------------------------------------

// GameInflictDamage

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameInflictDamage::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameInflictDamage::has_position() const {
  return _internal_has_position();
}
inline void GameInflictDamage::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameInflictDamage::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameInflictDamage::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameInflictDamage::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameInflictDamage.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameInflictDamage::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameInflictDamage::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameInflictDamage.position)
  return _internal_mutable_position();
}
inline void GameInflictDamage::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInflictDamage.position)
}

// int32 victimTeam = 2 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameInflictDamage::clear_victimteam() {
  victimteam_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameInflictDamage::_internal_victimteam() const {
  return victimteam_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameInflictDamage::victimteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.victimTeam)
  return _internal_victimteam();
}
inline void GameInflictDamage::_internal_set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  victimteam_ = value;
}
inline void GameInflictDamage::set_victimteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_victimteam(value);
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.victimTeam)
}

// int32 attackTeam = 3 [(.Analytics.enumkey) = "TEAM_ID", (.Analytics.track_event) = true];
inline void GameInflictDamage::clear_attackteam() {
  attackteam_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameInflictDamage::_internal_attackteam() const {
  return attackteam_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameInflictDamage::attackteam() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.attackTeam)
  return _internal_attackteam();
}
inline void GameInflictDamage::_internal_set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  attackteam_ = value;
}
inline void GameInflictDamage::set_attackteam(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_attackteam(value);
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.attackTeam)
}

// int32 weaponId = 4 [(.Analytics.enumkey) = "WEAPON_ID", (.Analytics.track_event) = true];
inline void GameInflictDamage::clear_weaponid() {
  weaponid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameInflictDamage::_internal_weaponid() const {
  return weaponid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameInflictDamage::weaponid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.weaponId)
  return _internal_weaponid();
}
inline void GameInflictDamage::_internal_set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  weaponid_ = value;
}
inline void GameInflictDamage::set_weaponid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_weaponid(value);
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.weaponId)
}

// string damageType = 5 [(.Analytics.track_event) = true];
inline void GameInflictDamage::clear_damagetype() {
  damagetype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameInflictDamage::damagetype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.damageType)
  return _internal_damagetype();
}
inline void GameInflictDamage::set_damagetype(const std::string& value) {
  _internal_set_damagetype(value);
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.damageType)
}
inline std::string* GameInflictDamage::mutable_damagetype() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameInflictDamage.damageType)
  return _internal_mutable_damagetype();
}
inline const std::string& GameInflictDamage::_internal_damagetype() const {
  return damagetype_.GetNoArena();
}
inline void GameInflictDamage::_internal_set_damagetype(const std::string& value) {
  
  damagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameInflictDamage::set_damagetype(std::string&& value) {
  
  damagetype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameInflictDamage.damageType)
}
inline void GameInflictDamage::set_damagetype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  damagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameInflictDamage.damageType)
}
inline void GameInflictDamage::set_damagetype(const char* value, size_t size) {
  
  damagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameInflictDamage.damageType)
}
inline std::string* GameInflictDamage::_internal_mutable_damagetype() {
  
  return damagetype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameInflictDamage::release_damagetype() {
  // @@protoc_insertion_point(field_release:Analytics.GameInflictDamage.damageType)
  
  return damagetype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameInflictDamage::set_allocated_damagetype(std::string* damagetype) {
  if (damagetype != nullptr) {
    
  } else {
    
  }
  damagetype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), damagetype);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameInflictDamage.damageType)
}

// float damageAmount = 6;
inline void GameInflictDamage::clear_damageamount() {
  damageamount_ = 0;
}
inline float GameInflictDamage::_internal_damageamount() const {
  return damageamount_;
}
inline float GameInflictDamage::damageamount() const {
  // @@protoc_insertion_point(field_get:Analytics.GameInflictDamage.damageAmount)
  return _internal_damageamount();
}
inline void GameInflictDamage::_internal_set_damageamount(float value) {
  
  damageamount_ = value;
}
inline void GameInflictDamage::set_damageamount(float value) {
  _internal_set_damageamount(value);
  // @@protoc_insertion_point(field_set:Analytics.GameInflictDamage.damageAmount)
}

// -------------------------------------------------------------------

// GameRadiusDamage

// .Analytics.Vec3 position = 1 [(.Analytics.point_event) = {
inline bool GameRadiusDamage::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameRadiusDamage::has_position() const {
  return _internal_has_position();
}
inline void GameRadiusDamage::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameRadiusDamage::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameRadiusDamage::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRadiusDamage.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameRadiusDamage::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameRadiusDamage.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameRadiusDamage::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameRadiusDamage::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameRadiusDamage.position)
  return _internal_mutable_position();
}
inline void GameRadiusDamage::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameRadiusDamage.position)
}

// string damageType = 2;
inline void GameRadiusDamage::clear_damagetype() {
  damagetype_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameRadiusDamage::damagetype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRadiusDamage.damageType)
  return _internal_damagetype();
}
inline void GameRadiusDamage::set_damagetype(const std::string& value) {
  _internal_set_damagetype(value);
  // @@protoc_insertion_point(field_set:Analytics.GameRadiusDamage.damageType)
}
inline std::string* GameRadiusDamage::mutable_damagetype() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameRadiusDamage.damageType)
  return _internal_mutable_damagetype();
}
inline const std::string& GameRadiusDamage::_internal_damagetype() const {
  return damagetype_.GetNoArena();
}
inline void GameRadiusDamage::_internal_set_damagetype(const std::string& value) {
  
  damagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameRadiusDamage::set_damagetype(std::string&& value) {
  
  damagetype_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameRadiusDamage.damageType)
}
inline void GameRadiusDamage::set_damagetype(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  damagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameRadiusDamage.damageType)
}
inline void GameRadiusDamage::set_damagetype(const char* value, size_t size) {
  
  damagetype_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameRadiusDamage.damageType)
}
inline std::string* GameRadiusDamage::_internal_mutable_damagetype() {
  
  return damagetype_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameRadiusDamage::release_damagetype() {
  // @@protoc_insertion_point(field_release:Analytics.GameRadiusDamage.damageType)
  
  return damagetype_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameRadiusDamage::set_allocated_damagetype(std::string* damagetype) {
  if (damagetype != nullptr) {
    
  } else {
    
  }
  damagetype_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), damagetype);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameRadiusDamage.damageType)
}

// float damageAmount = 3;
inline void GameRadiusDamage::clear_damageamount() {
  damageamount_ = 0;
}
inline float GameRadiusDamage::_internal_damageamount() const {
  return damageamount_;
}
inline float GameRadiusDamage::damageamount() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRadiusDamage.damageAmount)
  return _internal_damageamount();
}
inline void GameRadiusDamage::_internal_set_damageamount(float value) {
  
  damageamount_ = value;
}
inline void GameRadiusDamage::set_damageamount(float value) {
  _internal_set_damageamount(value);
  // @@protoc_insertion_point(field_set:Analytics.GameRadiusDamage.damageAmount)
}

// float damageRadius = 4;
inline void GameRadiusDamage::clear_damageradius() {
  damageradius_ = 0;
}
inline float GameRadiusDamage::_internal_damageradius() const {
  return damageradius_;
}
inline float GameRadiusDamage::damageradius() const {
  // @@protoc_insertion_point(field_get:Analytics.GameRadiusDamage.damageRadius)
  return _internal_damageradius();
}
inline void GameRadiusDamage::_internal_set_damageradius(float value) {
  
  damageradius_ = value;
}
inline void GameRadiusDamage::set_damageradius(float value) {
  _internal_set_damageradius(value);
  // @@protoc_insertion_point(field_set:Analytics.GameRadiusDamage.damageRadius)
}

// -------------------------------------------------------------------

// GameNavigationStuck

// int32 entityId = 1;
inline void GameNavigationStuck::clear_entityid() {
  entityid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameNavigationStuck::_internal_entityid() const {
  return entityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameNavigationStuck::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.entityId)
  return _internal_entityid();
}
inline void GameNavigationStuck::_internal_set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  entityid_ = value;
}
inline void GameNavigationStuck::set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_entityid(value);
  // @@protoc_insertion_point(field_set:Analytics.GameNavigationStuck.entityId)
}

// .Analytics.Vec3 position = 2 [(.Analytics.point_event) = {
inline bool GameNavigationStuck::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameNavigationStuck::has_position() const {
  return _internal_has_position();
}
inline void GameNavigationStuck::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameNavigationStuck::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameNavigationStuck::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameNavigationStuck.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameNavigationStuck::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameNavigationStuck.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameNavigationStuck::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameNavigationStuck::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameNavigationStuck.position)
  return _internal_mutable_position();
}
inline void GameNavigationStuck::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameNavigationStuck.position)
}

// -------------------------------------------------------------------

// GameVoiceMacro

// int32 entityId = 1;
inline void GameVoiceMacro::clear_entityid() {
  entityid_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameVoiceMacro::_internal_entityid() const {
  return entityid_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameVoiceMacro::entityid() const {
  // @@protoc_insertion_point(field_get:Analytics.GameVoiceMacro.entityId)
  return _internal_entityid();
}
inline void GameVoiceMacro::_internal_set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  entityid_ = value;
}
inline void GameVoiceMacro::set_entityid(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_entityid(value);
  // @@protoc_insertion_point(field_set:Analytics.GameVoiceMacro.entityId)
}

// int32 voiceMacro = 2 [(.Analytics.enumkey) = "VOICE_MACRO", (.Analytics.track_event) = true];
inline void GameVoiceMacro::clear_voicemacro() {
  voicemacro_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameVoiceMacro::_internal_voicemacro() const {
  return voicemacro_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 GameVoiceMacro::voicemacro() const {
  // @@protoc_insertion_point(field_get:Analytics.GameVoiceMacro.voiceMacro)
  return _internal_voicemacro();
}
inline void GameVoiceMacro::_internal_set_voicemacro(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  voicemacro_ = value;
}
inline void GameVoiceMacro::set_voicemacro(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_voicemacro(value);
  // @@protoc_insertion_point(field_set:Analytics.GameVoiceMacro.voiceMacro)
}

// .Analytics.Vec3 position = 3 [(.Analytics.point_event) = {
inline bool GameVoiceMacro::_internal_has_position() const {
  return this != internal_default_instance() && position_ != nullptr;
}
inline bool GameVoiceMacro::has_position() const {
  return _internal_has_position();
}
inline void GameVoiceMacro::clear_position() {
  if (GetArenaNoVirtual() == nullptr && position_ != nullptr) {
    delete position_;
  }
  position_ = nullptr;
}
inline const ::Analytics::Vec3& GameVoiceMacro::_internal_position() const {
  const ::Analytics::Vec3* p = position_;
  return p != nullptr ? *p : *reinterpret_cast<const ::Analytics::Vec3*>(
      &::Analytics::_Vec3_default_instance_);
}
inline const ::Analytics::Vec3& GameVoiceMacro::position() const {
  // @@protoc_insertion_point(field_get:Analytics.GameVoiceMacro.position)
  return _internal_position();
}
inline ::Analytics::Vec3* GameVoiceMacro::release_position() {
  // @@protoc_insertion_point(field_release:Analytics.GameVoiceMacro.position)
  
  ::Analytics::Vec3* temp = position_;
  position_ = nullptr;
  return temp;
}
inline ::Analytics::Vec3* GameVoiceMacro::_internal_mutable_position() {
  
  if (position_ == nullptr) {
    auto* p = CreateMaybeMessage<::Analytics::Vec3>(GetArenaNoVirtual());
    position_ = p;
  }
  return position_;
}
inline ::Analytics::Vec3* GameVoiceMacro::mutable_position() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameVoiceMacro.position)
  return _internal_mutable_position();
}
inline void GameVoiceMacro::set_allocated_position(::Analytics::Vec3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete position_;
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameVoiceMacro.position)
}

// -------------------------------------------------------------------

// GameLogMessage

// .Analytics.LogType logType = 1;
inline void GameLogMessage::clear_logtype() {
  logtype_ = 0;
}
inline ::Analytics::LogType GameLogMessage::_internal_logtype() const {
  return static_cast< ::Analytics::LogType >(logtype_);
}
inline ::Analytics::LogType GameLogMessage::logtype() const {
  // @@protoc_insertion_point(field_get:Analytics.GameLogMessage.logType)
  return _internal_logtype();
}
inline void GameLogMessage::_internal_set_logtype(::Analytics::LogType value) {
  
  logtype_ = value;
}
inline void GameLogMessage::set_logtype(::Analytics::LogType value) {
  _internal_set_logtype(value);
  // @@protoc_insertion_point(field_set:Analytics.GameLogMessage.logType)
}

// string logMessage = 2;
inline void GameLogMessage::clear_logmessage() {
  logmessage_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameLogMessage::logmessage() const {
  // @@protoc_insertion_point(field_get:Analytics.GameLogMessage.logMessage)
  return _internal_logmessage();
}
inline void GameLogMessage::set_logmessage(const std::string& value) {
  _internal_set_logmessage(value);
  // @@protoc_insertion_point(field_set:Analytics.GameLogMessage.logMessage)
}
inline std::string* GameLogMessage::mutable_logmessage() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameLogMessage.logMessage)
  return _internal_mutable_logmessage();
}
inline const std::string& GameLogMessage::_internal_logmessage() const {
  return logmessage_.GetNoArena();
}
inline void GameLogMessage::_internal_set_logmessage(const std::string& value) {
  
  logmessage_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameLogMessage::set_logmessage(std::string&& value) {
  
  logmessage_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameLogMessage.logMessage)
}
inline void GameLogMessage::set_logmessage(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  logmessage_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameLogMessage.logMessage)
}
inline void GameLogMessage::set_logmessage(const char* value, size_t size) {
  
  logmessage_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameLogMessage.logMessage)
}
inline std::string* GameLogMessage::_internal_mutable_logmessage() {
  
  return logmessage_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameLogMessage::release_logmessage() {
  // @@protoc_insertion_point(field_release:Analytics.GameLogMessage.logMessage)
  
  return logmessage_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameLogMessage::set_allocated_logmessage(std::string* logmessage) {
  if (logmessage != nullptr) {
    
  } else {
    
  }
  logmessage_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logmessage);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameLogMessage.logMessage)
}

// string logExtraInfo = 3;
inline void GameLogMessage::clear_logextrainfo() {
  logextrainfo_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& GameLogMessage::logextrainfo() const {
  // @@protoc_insertion_point(field_get:Analytics.GameLogMessage.logExtraInfo)
  return _internal_logextrainfo();
}
inline void GameLogMessage::set_logextrainfo(const std::string& value) {
  _internal_set_logextrainfo(value);
  // @@protoc_insertion_point(field_set:Analytics.GameLogMessage.logExtraInfo)
}
inline std::string* GameLogMessage::mutable_logextrainfo() {
  // @@protoc_insertion_point(field_mutable:Analytics.GameLogMessage.logExtraInfo)
  return _internal_mutable_logextrainfo();
}
inline const std::string& GameLogMessage::_internal_logextrainfo() const {
  return logextrainfo_.GetNoArena();
}
inline void GameLogMessage::_internal_set_logextrainfo(const std::string& value) {
  
  logextrainfo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void GameLogMessage::set_logextrainfo(std::string&& value) {
  
  logextrainfo_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Analytics.GameLogMessage.logExtraInfo)
}
inline void GameLogMessage::set_logextrainfo(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  logextrainfo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Analytics.GameLogMessage.logExtraInfo)
}
inline void GameLogMessage::set_logextrainfo(const char* value, size_t size) {
  
  logextrainfo_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Analytics.GameLogMessage.logExtraInfo)
}
inline std::string* GameLogMessage::_internal_mutable_logextrainfo() {
  
  return logextrainfo_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GameLogMessage::release_logextrainfo() {
  // @@protoc_insertion_point(field_release:Analytics.GameLogMessage.logExtraInfo)
  
  return logextrainfo_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GameLogMessage::set_allocated_logextrainfo(std::string* logextrainfo) {
  if (logextrainfo != nullptr) {
    
  } else {
    
  }
  logextrainfo_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), logextrainfo);
  // @@protoc_insertion_point(field_set_allocated:Analytics.GameLogMessage.logExtraInfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Analytics

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Analytics::RedisKeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::RedisKeyType>() {
  return ::Analytics::RedisKeyType_descriptor();
}
template <> struct is_proto_enum< ::Analytics::PrimitiveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::PrimitiveType>() {
  return ::Analytics::PrimitiveType_descriptor();
}
template <> struct is_proto_enum< ::Analytics::Compression> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::Compression>() {
  return ::Analytics::Compression_descriptor();
}
template <> struct is_proto_enum< ::Analytics::LogType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Analytics::LogType>() {
  return ::Analytics::LogType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_analytics_2eproto
