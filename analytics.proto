
package Analytics;

import "google/protobuf/descriptor.proto";

extend google.protobuf.MessageOptions 
{
	// if this option is defined the library will cache the last message of this type into memory so that even if the
	// visualization application connects to the host application 'late', the cached values of all events may be sent
	// to seed the visualizer with up to date information with regards to whatever messages utilize this option
	optional bool cachelastvalue	= 5000;

	// this suffix may be optionally used when generating the key value for caching the contents of a message, 
	// so that multiple types of a given message may be cached, using this suffix prepended to the message type name
	optional string cachekeysuffix	= 5001;
}

// compression schemes may be utilized to reduce the size of certain message types
enum Compression
{
	Compression_None	= 0;
	Compression_FastLZ	= 1;
}

message TopicSubscribe
{
	required string					topic						= 1;
}

message TopicUnsubscribe
{
	required string					topic						= 1;
}

message GameInfo
{
	option (cachelastvalue) = true;

	required string					mapName						= 1;
}

message GameNavNotFound
{
	required string					mapName						= 1;
}

message GameNavAutoDownloaded
{
	required string					mapName						= 1;
}

message GameAssert
{
	required string					condition					= 1;
	optional string					file						= 2;
	optional int32					line						= 3;
}

message GameCrash
{
	required string					info						= 1;
}

message GameModelData
{
	option (cachelastvalue) = true;
	option (cachekeysuffix) = "modelName";

	optional Compression			compressionType				= 1 [default=Compression_None];
	required string					modelName					= 2;
	required bytes					modelBytes					= 3;
	optional uint32					modelBytesUncompressed		= 4;
}

message GameEntityInfo
{
	message Ammo
	{
		required uint32				ammoType					= 1;
		optional uint32				ammoCount					= 2;
	}

	optional string					name						= 1;
	required int32					entityId					= 2;
	optional int32					groupId						= 3;
	optional int32					classId						= 4;
	optional float					positionX					= 5;
	optional float					positionY					= 6;
	optional float					positionZ					= 7;
	optional float					heading						= 8;
	optional float					pitch						= 9;
	optional float					roll						= 10;
	optional uint32					health						= 12;
	optional uint32					healthMax					= 13;
	optional uint32					armor						= 14;
	optional uint32					armorMax					= 15;
	optional uint32					team						= 16;
	repeated Ammo					ammo						= 20;
}

message GameEntityList
{
	option (cachelastvalue) = true;

	repeated GameEntityInfo			entities					= 1;
}

message GameWeaponFired
{
	required int32					weaponId					= 1;
	optional float					positionX					= 2;
	optional float					positionY					= 3;
	optional float					positionZ					= 4;
	optional uint32					fireMode					= 5;
	optional int32					team						= 6;
}

message GameDeath
{
	required int32					killedByClass				= 1; // this class Id maps to an enumeration defined by the client who is communicating this message
	required int32					killedByWeapon				= 2; // this weapon Id maps to an enumeration defined by the client who is communicating this message
	required int32					killedByHealth				= 3; // how much health did they have left when they killed me
	optional uint32					team						= 4;
}

message GameTookDamage
{
	required int32					weaponId					= 1;
	required float					positionX					= 2;
	required float					positionY					= 3;
	required float					positionZ					= 4;
	optional uint32					team						= 5;
}

message GameNavigationStuck
{
	required int32					entityId					= 1;
	required float					positionX					= 2;
	required float					positionY					= 3;
	required float					positionZ					= 4;
}

// This message type represents the root message type of the data sent between the application and the library
// Since the contents of this message form a union between one of an extendable number and types of message payloads,
// the data is very easily extendable or modifiable without the need to worry about versioning or breaking the format
message MessageUnion
{
	required int64					timestamp						= 1;

	oneof msg {
		GameInfo					gameInfo						= 9;
		GameNavNotFound				gameNavNotFound					= 10;
		GameNavAutoDownloaded		systemNavDownloaded				= 11;
		GameAssert					gameAssert						= 12;
		GameCrash					gameCrash						= 13;
		GameModelData				gameModelData					= 14;

		GameEntityList				gameEntityList					= 100;
		GameWeaponFired				gameWeaponFired					= 101;
		GameDeath					gameDeath						= 102;
		GameTookDamage				gameTookDamage					= 103;
		GameNavigationStuck			gameNavigationStuck				= 104;

		TopicSubscribe				topicSubscribe					= 1000;
		TopicUnsubscribe			topicUnsubscribe				= 1001;
	}
}
